#include <stdbool.h>
#include "core/unused_api.h"
#include "core/minmax.h"
#include "core/divmodmul.h"
#include "core/arraydef.h"

/*
 * Qsort routine from Bentley & McIlroy's "Engineering a Sort Function".
 */

#define GT_QSORT_SWAP(A,B)\
        if ((A) != (B))\
        {\
          tmp = *(A);\
          *(A) = *(B);\
          *(B) = tmp;\
        }

#define GT_QSORT_VECSWAP(A,B,N)\
        aptr = A;\
        bptr = B;\
        while ((N)-- > 0)\
        {\
          tmp = *aptr;\
          *aptr++ = *bptr;\
          *bptr++ = tmp;\
        }

static inline Sorttype *gt_inlined_qsort_r_med3 (Sorttype *a, Sorttype *b,
                                                 Sorttype *c, void *data)
{
  return qsortcmp (a, b, data) < 0
           ? (qsortcmp (b, c, data) < 0
                ? b
                : (qsortcmp (a, c, data) < 0
                     ? c : a))
           : (qsortcmp (b, c, data) > 0
                ? b
                : (qsortcmp (a, c, data) < 0
                     ? a
                     : c));
}

typedef struct
{
  Sorttype *startptr;
  unsigned long len;
} Intervaltobesorted;

GT_DECLAREARRAYSTRUCT(Intervaltobesorted);

#define STACKTOP\
        stack.spaceIntervaltobesorted[stack.nextfreeIntervaltobesorted]

#define PUSHSTACK(START,LEN)\
  GT_CHECKARRAYSPACE(&stack,Intervaltobesorted,32);\
  STACKTOP.startptr = START;\
  STACKTOP.len = LEN;\
  stack.nextfreeIntervaltobesorted++

void gt_inlined_qsort_r (Sorttype *a,unsigned long n,void *data)
{
  Sorttype tmp, *pa, *pb, *pc, *pd, *pl, *pm, *pn, *aptr, *bptr;
  unsigned long d, minval;
  int r;
  bool swapped;
  GtArrayIntervaltobesorted stack;

  GT_INITARRAY(&stack,Intervaltobesorted);
  PUSHSTACK(a,n);
  while (stack.nextfreeIntervaltobesorted > 0)
  {
    stack.nextfreeIntervaltobesorted--;
    a = STACKTOP.startptr;
    n = STACKTOP.len;
    swapped = false;
    if (n < 7UL)
    {
      for (pm = a + 1; pm < a + n; pm++)
      {
       for (pl = pm;
	 pl > a && qsortcmp (pl - 1, pl, data) > 0;
             pl--)
        {
          GT_QSORT_SWAP (pl, pl - 1);
        }
      }
      break;
    }
    pm = a + GT_DIV2 (n);
    if (n > 7UL)
    {
      pl = a;
      pn = a + n - 1;
      if (n > 40UL)
      {
        d = GT_DIV8 (n);
        pl = gt_inlined_qsort_r_med3 (pl, pl + d, pl + GT_MULT2 (d), data);
        pm = gt_inlined_qsort_r_med3 (pm - d, pm, pm + d, data);
        pn = gt_inlined_qsort_r_med3 (pn - GT_MULT2 (d), pn - d, pn, data);
      }
      pm = gt_inlined_qsort_r_med3 (pl, pm, pn, data);
    }
    GT_QSORT_SWAP (a, pm);
    pa = pb = a + 1;
    pc = pd = a + n - 1;
    while (1)
    {
      while (pb <= pc
             && (r = qsortcmp (pb, a, data)) <= 0)
      {
        if (r == 0)
        {
          swapped = true;
          GT_QSORT_SWAP (pa, pb);
          pa++;
        }
        pb++;
      }
      while (pb <= pc
             && (r = qsortcmp (pc, a, data)) >= 0)
      {
        if (r == 0)
        {
          swapped = true;
          GT_QSORT_SWAP (pc, pd);
          pd--;
        }
        pc--;
      }
      if (pb > pc)
      {
        break;
      }
      GT_QSORT_SWAP (pb, pc);
      swapped = true;
      pb++;
      pc--;
    }
    if (!swapped)
    {                                  /* Switch to insertion sort */
      for (pm = a + 1; pm < a + n; pm++)
      {
        for (pl = pm;
             pl > a && qsortcmp (pl - 1, pl, data) > 0;
             pl--)
        {
          GT_QSORT_SWAP (pl, pl - 1);
        }
      }
      break;
    }
    pn = a + n;
    minval = MIN ((unsigned long) (pa - a), (unsigned long) (pb - pa));
    GT_QSORT_VECSWAP (a, pb - minval, minval);
    minval = MIN ((unsigned long) (pd - pc), (unsigned long) (pn - pd - 1));
    GT_QSORT_VECSWAP (pb, pn - minval, minval);
    if ((minval = (unsigned long) (pb - pa)) > 1UL)
    {
      PUSHSTACK(a,minval);
    }
    if ((minval = (unsigned long) (pd - pc)) > 1UL)
    {
      PUSHSTACK(pn - minval,minval);
    } else
    {
      break;
    }
  }
  GT_FREEARRAY(&stack,Intervaltobesorted);
}
