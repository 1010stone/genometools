/*
** Copyright (C) 2007 Thomas Jahns <Thomas.Jahns@gmx.net>
**
** See LICENSE file or http://genometools.org/license.html for license details.
**
*/
#include <assert.h>
#include <limits.h>
#include <stdio.h>
#include <stdlib.h>
#include <inttypes.h>

#include <time.h>
#include <sys/time.h>

#include <libgtcore/bitpackstring.h>
#include <libgtcore/env.h>
#include <libgtcore/ensure.h>

enum {
/*   MAX_RND_NUMS = 10, */
  MAX_RND_NUMS = 100000,
};

static inline int
icmp(uint@LEN@_t a, uint@LEN@_t b)
{
  if (a > b)
    return 1;
  else if (a < b)
    return -1;
  else /* if (a == b) */
    return 0;
}

#define freeResourcesAndReturn(retval) \
  do {                                 \
    env_ma_free(randSrc, env);         \
    env_ma_free(randCmp, env);         \
    env_ma_free(bitStore, env);        \
    env_ma_free(bitStoreCopy, env);    \
    return retval;                     \
  } while(0)


int
bitPackString@LEN@_unit_test(Env *env)
{
  BitString bitStore = NULL;
  BitString bitStoreCopy = NULL;
  uint@LEN@_t *randSrc = NULL; /*< create random ints here for input as bit
                                *  store */
  uint@LEN@_t *randCmp = NULL; /*< used for random ints read back */
  size_t i, numRnd;
  BitOffset offsetStart, offset;
  unsigned long seedval;
  int had_err = 0;
  {
    struct timeval seed;
    gettimeofday(&seed, NULL);
    srandom(seedval = seed.tv_sec + seed.tv_usec);
  }
  offset = offsetStart = random()%(sizeof (uint@LEN@_t) * CHAR_BIT);
  numRnd = random() % (MAX_RND_NUMS + 1);
#ifdef VERBOSE_UNIT_TEST
  fprintf(stderr, "seedval = %lu, offset=%lu, numRnd=%lu\n", seedval,
          (long unsigned)offsetStart, (long unsigned)numRnd);
#endif /* VERBOSE_UNIT_TEST */
  {
    BitOffset numBits = sizeof (uint@LEN@_t) * CHAR_BIT * numRnd + offsetStart;
    ensure(had_err, (randSrc = env_ma_malloc(env, sizeof (uint@LEN@_t)*numRnd))
           && (bitStore = env_ma_malloc(env, bitElemsAllocSize(numBits)
                                        * sizeof (BitElem)))
           && (bitStoreCopy = env_ma_malloc(env, bitElemsAllocSize(numBits)
                                            * sizeof (BitElem)))
           && (randCmp = env_ma_malloc(env, sizeof (uint@LEN@_t)*numRnd)));
  }
  if (had_err)
  {
    if (randSrc)
      env_ma_free(randSrc, env);
    if (randCmp)
      env_ma_free(randCmp, env);
    if (bitStore)
      env_ma_free(bitStore, env);
    if (bitStoreCopy)
      env_ma_free(bitStoreCopy, env);
#ifdef VERBOSE_UNIT_TEST
    perror("Storage allocations failed");
#endif /* VERBOSE_UNIT_TEST */
    return had_err;
  }
  /* first test unsigned types */
#ifdef VERBOSE_UNIT_TEST
  fputs("bsStoreUInt@LEN@/bsGetUInt@LEN@: ", stderr);
#endif /* VERBOSE_UNIT_TEST */
  for (i = 0; i < numRnd; ++i)
  {
#if @LEN@ > 32 && LONG_BIT < @LEN@
    uint@LEN@_t v = randSrc[i] = (uint@LEN@_t)random() << 32 | random();
#else /* @LEN@ > 32 && LONG_BIT < @LEN@ */
    uint@LEN@_t v = randSrc[i] = random();
#endif /* @LEN@ > 32 && LONG_BIT < @LEN@ */
    int bits = requiredUInt@LEN@Bits(v);
    bsStoreUInt@LEN@(bitStore, offset, bits, v);
    offset += bits;
  }
  offset = offsetStart;
  for (i = 0; i < numRnd; ++i)
  {
    uint@LEN@_t v = randSrc[i];
    int bits = requiredUInt@LEN@Bits(v);
    uint@LEN@_t r = bsGetUInt@LEN@(bitStore, offset, bits);
    ensure(had_err, r == v);
    if (had_err)
    {
#ifdef VERBOSE_UNIT_TEST
      fprintf(stderr, "Expected %"PRIu@LEN@", got %"PRIu@LEN@", seed = %lu, i = %lu\n",
              v, r, seedval, (unsigned long)i);
#endif /* VERBOSE_UNIT_TEST */
      freeResourcesAndReturn(had_err);
    }
    offset += bits;
  }
#ifdef VERBOSE_UNIT_TEST
  fputs("passed\n", stderr);
  fputs("bsCompare: ", stderr);
#endif /* VERBOSE_UNIT_TEST */
  {
    uint@LEN@_t v0 = randSrc[0];
    int bits0 = requiredUInt@LEN@Bits(v0);
    uint@LEN@_t r0;
    offset = offsetStart;
    r0 = bsGetUInt@LEN@(bitStore, offset, bits0);
    for (i = 1; i < numRnd; ++i)
    {
      uint@LEN@_t v1 = randSrc[i];
      int bits1 = requiredUInt@LEN@Bits(v1);
      uint@LEN@_t r1 = bsGetUInt@LEN@(bitStore, offset + bits0, bits1);
      int result = -2;   /*< -2 is not a return value of bsCompare, thus
                          *   if it is displayed, there was an earlier
                          *   error. */
      ensure(had_err, r0 == v0 && r1 == v1);
      ensure(had_err, icmp(v0, v1) ==
             (result = bsCompare(bitStore, offset, bits0,
                                 bitStore, offset + bits0, bits1)));
      if (had_err)
      {
#ifdef VERBOSE_UNIT_TEST
        fprintf(stderr, "Expected v0 %s v1, got v0 %s v1,\n for v0=%"PRIu@LEN@
                " and v1=%"PRIu@LEN@",\n"
                "seed = %lu, i = %lu, bits0=%u, bits1=%u\n",
                (v0 > v1?">":(v0 < v1?"<":"==")),
                (result > 0?">":(result < 0?"<":"==")), v0, v1,
                seedval, (unsigned long)i, bits0, bits1);
#endif /* VERBOSE_UNIT_TEST */
        freeResourcesAndReturn(had_err);
      }
      offset += bits0;
      bits0 = bits1;
      v0 = v1;
      r0 = r1;
    }
  }
#ifdef VERBOSE_UNIT_TEST
  fputs("passed\n", stderr);
  fputs("bsStoreUniformUInt@LEN@Array/bsGetUInt@LEN@: ", stderr);
#endif /* VERBOSE_UNIT_TEST */
  {
    unsigned numBits = random()%(sizeof (uint@LEN@_t)*CHAR_BIT) + 1;
    uint@LEN@_t mask = ~(uint@LEN@_t)0;
    if (numBits < @LEN@)
      mask = ~(mask << numBits);
    offset = offsetStart;
    bsStoreUniformUInt@LEN@Array(bitStore, offset, numBits, numRnd, randSrc);
    for (i = 0; i < numRnd; ++i)
    {
      uint@LEN@_t v = randSrc[i] & mask;
      uint@LEN@_t r = bsGetUInt@LEN@(bitStore, offset, numBits);
      ensure(had_err, r == v);
      if (had_err)
      {
#ifdef VERBOSE_UNIT_TEST
        fprintf(stderr, "Expected %"PRIu@LEN@", got %"PRIu@LEN@",\n seed = %lu,"
                " i = %lu, bits=%u\n",
                v, r, seedval, (unsigned long)i, numBits);
#endif /* VERBOSE_UNIT_TEST */
        freeResourcesAndReturn(had_err);
      }
      offset += numBits;
    }
#ifdef VERBOSE_UNIT_TEST
    fputs("passed\n", stderr);
    fputs("bsStoreUniformUInt@LEN@Array/bsGetUniformUInt@LEN@Array: ", stderr);
#endif /* VERBOSE_UNIT_TEST */
    bsGetUniformUInt@LEN@Array(bitStore, offset = offsetStart,
                               numBits, numRnd, randCmp);
    for (i = 0; i < numRnd; ++i)
    {
      uint@LEN@_t v = randSrc[i] & mask;
      uint@LEN@_t r = randCmp[i];
      ensure(had_err, r == v);
      if (had_err)
      {
#ifdef VERBOSE_UNIT_TEST
        fprintf(stderr,
                "Expected %"PRIu@LEN@", got %"PRIu@LEN@",\n seed = %lu,"
                " i = %lu, bits=%u\n",
                v, r, seedval, (unsigned long)i, numBits);
#endif /* VERBOSE_UNIT_TEST */
        freeResourcesAndReturn(had_err);
      }
    }
    {
      uint@LEN@_t v = randSrc[0] & mask;
      uint@LEN@_t r;
      bsGetUniformUInt@LEN@Array(bitStore, offsetStart,
                            numBits, 1, &r);
      if (r != v)
      {
#ifdef VERBOSE_UNIT_TEST
        fprintf(stderr,
                "Expected %"PRIu@LEN@", got %"PRIu@LEN@", seed = %lu,"
                " one value extraction\n",
                v, r, seedval);
#endif /* VERBOSE_UNIT_TEST */
        freeResourcesAndReturn(had_err);
      }
    }
#ifdef VERBOSE_UNIT_TEST
    fputs(" passed\n", stderr);
#endif /* VERBOSE_UNIT_TEST */
  }
  /* int types */
#ifdef VERBOSE_UNIT_TEST
  fputs("bsStoreInt@LEN@/bsGetInt@LEN@: ", stderr);
#endif /* VERBOSE_UNIT_TEST */  
  for (i = 0; i < numRnd; ++i)
  {
    int@LEN@_t v = (int@LEN@_t)randSrc[i];
    unsigned bits = requiredInt@LEN@Bits(v);
    bsStoreInt@LEN@(bitStore, offset, bits, v);
    offset += bits;
  }
  offset = offsetStart;
  for (i = 0; i < numRnd; ++i)
  {
    int@LEN@_t v = randSrc[i];
    unsigned bits = requiredInt@LEN@Bits(v);
    int@LEN@_t r = bsGetInt@LEN@(bitStore, offset, bits);
    ensure(had_err, r == v);
    if (had_err)
    {
#ifdef VERBOSE_UNIT_TEST
      fprintf(stderr, "Expected %"PRId@LEN@", got %"PRId@LEN@",\n"
              "seed = %lu, i = %lu, bits=%u\n",
              v, r, seedval, (unsigned long)i, bits);
#endif /* VERBOSE_UNIT_TEST */
      freeResourcesAndReturn(had_err);
    }
    offset += bits;
  }
#ifdef VERBOSE_UNIT_TEST
  fputs("passed\n", stderr);
  fputs("bsStoreUniformInt@LEN@Array/bsGetInt@LEN@: ", stderr);
#endif /* VERBOSE_UNIT_TEST */
  {
    unsigned numBits = random()%(sizeof (int@LEN@_t)*CHAR_BIT) + 1;
    int@LEN@_t mask = ~(int@LEN@_t)0;
    if (numBits < @LEN@)
      mask = ~(mask << numBits);
    offset = offsetStart;
    bsStoreUniformInt@LEN@Array(bitStore, offset, numBits, numRnd,
                                (int@LEN@_t *)randSrc);
    for (i = 0; i < numRnd; ++i)
    {
      int@LEN@_t m = (int@LEN@_t)1 << (numBits - 1);
      int@LEN@_t v = (int@LEN@_t)((randSrc[i] & mask) ^ m) - m;
      int@LEN@_t r = bsGetInt@LEN@(bitStore, offset, numBits);
      ensure(had_err, r == v);
      if (had_err)
      {
#ifdef VERBOSE_UNIT_TEST
        fprintf(stderr, "Expected %"PRId@LEN@", got %"PRId@LEN@",\n"
                "seed = %lu, i = %lu, numBits=%u\n",
                v, r, seedval, (unsigned long)i, numBits);
#endif /* VERBOSE_UNIT_TEST */
        freeResourcesAndReturn(had_err);
      }
      offset += numBits;
    }
#ifdef VERBOSE_UNIT_TEST
    fputs("passed\n", stderr);
    fputs("bsStoreUniformInt@LEN@Array/bsGetUniformInt@LEN@Array: ", stderr);
#endif /* VERBOSE_UNIT_TEST */
    bsGetUniformInt@LEN@Array(bitStore, offset = offsetStart,
                              numBits, numRnd, (int@LEN@_t *)randCmp);
    for (i = 0; i < numRnd; ++i)
    {
      int@LEN@_t m = (int@LEN@_t)1 << (numBits - 1);
      int@LEN@_t v = (int@LEN@_t)((randSrc[i] & mask) ^ m) - m;
      int@LEN@_t r = randCmp[i];
      ensure(had_err, r == v);
      if (had_err)
      {
#ifdef VERBOSE_UNIT_TEST
        fprintf(stderr, "Expected %"PRId@LEN@", got %"PRId@LEN@
                ", seed = %lu, i = %lu\n",
                v, r, seedval, (unsigned long)i);
#endif /* VERBOSE_UNIT_TEST */
        freeResourcesAndReturn(had_err);
      }
    }
    {
      int@LEN@_t m = (int@LEN@_t)1 << (numBits - 1);
      int@LEN@_t v = (int@LEN@_t)((randSrc[0] & mask) ^ m) - m;
      int@LEN@_t r;
      bsGetUniformInt@LEN@Array(bitStore, offsetStart,
                                numBits, 1, &r);
      ensure(had_err, r == v);
      if (had_err)
      {
#ifdef VERBOSE_UNIT_TEST
        fprintf(stderr, "Expected %"PRId@LEN@", got %"PRId@LEN@
                ", seed = %lu, one value extraction\n",
                v, r, seedval);
#endif /* VERBOSE_UNIT_TEST */
        freeResourcesAndReturn(had_err);
      }
    }
#ifdef VERBOSE_UNIT_TEST
    fputs("passed\n", stderr);
#endif /* VERBOSE_UNIT_TEST */
  }
  {
#ifdef VERBOSE_UNIT_TEST
    fputs("bsCopy: ", stderr);
#endif /* VERBOSE_UNIT_TEST */
    /* first decide how many of the values to use and at which to start */
    size_t numValueCopies, copyStart;
    BitOffset numCopyBits = 0, destOffset;
    unsigned numBits = random()%(sizeof (uint@LEN@_t)*CHAR_BIT) + 1;
    uint@LEN@_t mask = ~(uint@LEN@_t)0;
    if (numBits < @LEN@)
      mask = ~(mask << numBits);
    if(random()&1)
    {
      numValueCopies = random()%(numRnd + 1);
      copyStart = random()%(numRnd - numValueCopies);
    }
    else
    {
      copyStart = random() % numRnd;
      numValueCopies = random()%(numRnd - copyStart + 1);
    }
    assert(copyStart + numValueCopies <= numRnd);
    offset = offsetStart + (BitOffset)copyStart * numBits;
    destOffset = random()%
      (offsetStart
       + (sizeof (uint@LEN@_t)*CHAR_BIT)
       * (BitOffset)(copyStart + numRnd - numValueCopies));
    numCopyBits = (BitOffset)numBits * numValueCopies;
    /* the following bsCopy should be equivalent to:
     * bsStoreUniformUInt@LEN@Array(bitStoreCopy, destOffset,
     *                              numBits, numValueCopies, randSrc); */
    bsCopy(bitStore, offset, bitStoreCopy, destOffset, numCopyBits);
    ensure(had_err,
           bsCompare(bitStore, offset, numCopyBits,
                     bitStoreCopy, destOffset, numCopyBits) == 0);
  }
  freeResourcesAndReturn(had_err);
}

