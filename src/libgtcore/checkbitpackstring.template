/*
  Copyright (C) 2007 Thomas Jahns <Thomas.Jahns@gmx.net>

  Permission to use, copy, modify, and distribute this software for any
  purpose with or without fee is hereby granted, provided that the above
  copyright notice and this permission notice appear in all copies.

  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
*/

#include <assert.h>
#include <limits.h>
#include <stdio.h>
#include <stdlib.h>
#include <inttypes.h>

#include <time.h>
#include <sys/time.h>

#include "libgtcore/bitpackstring.h"
#include "libgtcore/env.h"
#include "libgtcore/ensure.h"

enum {
/*   MAX_RND_NUMS = 10, */
  MAX_RND_NUMS = 100000,
};

static inline int
icmp(@uOpType@ a, @uOpType@ b)
{
  if (a > b)
    return 1;
  else if (a < b)
    return -1;
  else /* if (a == b) */
    return 0;
}

/**
 * \brief bit count reference
 * @param v count the number of bits set in v
 */
static inline int
genBitCount(@uOpType@ v)
{
  unsigned c; /* c accumulates the total bits set in v */
  for (c = 0; v; c++)
    v &= v - 1; /* clear the least significant bit set */
  return c;
}

#define freeResourcesAndReturn(retval) \
  do {                                 \
    env_ma_free(randSrc, env);         \
    env_ma_free(randCmp, env);         \
    env_ma_free(bitStore, env);        \
    env_ma_free(bitStoreCopy, env);    \
    return retval;                     \
  } while (0)

int
bitPackString@iTypeTag@_unit_test(Env *env)
{
  BitString bitStore = NULL;
  BitString bitStoreCopy = NULL;
  @uOpType@ *randSrc = NULL; /*< create random ints here for input as bit
                                *  store */
  @uOpType@ *randCmp = NULL; /*< used for random ints read back */
  size_t i, numRnd;
  BitOffset offsetStart, offset;
  unsigned long seedval;
  int had_err = 0;
  {
    struct timeval seed;
    gettimeofday(&seed, NULL);
    seedval = seed.tv_sec + seed.tv_usec;
    srandom(seedval);
  }
  offset = offsetStart = random()%(sizeof (@uOpType@) * CHAR_BIT);
  numRnd = random() % (MAX_RND_NUMS + 1);
  env_log_log(env, "seedval = %lu, offset=%lu, numRnd=%lu\n", seedval,
              (long unsigned)offsetStart, (long unsigned)numRnd);
  {
    BitOffset numBits = sizeof (@uOpType@) * CHAR_BIT * numRnd + offsetStart;
    randSrc = env_ma_malloc(env, sizeof (@uOpType@)*numRnd);
    bitStore = env_ma_malloc(env, bitElemsAllocSize(numBits)
                             * sizeof (BitElem));
    bitStoreCopy = env_ma_calloc(env, bitElemsAllocSize(numBits),
                                 sizeof (BitElem));
    randCmp = env_ma_malloc(env, sizeof (@uOpType@)*numRnd);
  }
  /* first test unsigned types */
  env_log_log(env, "bsStore@uTypeTag@/bsGet@uTypeTag@: ");
  for (i = 0; i < numRnd; ++i)
  {
#if @bitSize@ > 32 && LONG_BIT < @bitSize@
    @uOpType@ v = randSrc[i] = (@uOpType@)random() << 32 | random();
#else /* @bitSize@ > 32 && LONG_BIT < @bitSize@ */
    @uOpType@ v = randSrc[i] = random();
#endif /* @bitSize@ > 32 && LONG_BIT < @bitSize@ */
    int bits = required@uTypeTag@Bits(v);
    bsStore@uTypeTag@(bitStore, offset, bits, v);
    offset += bits;
  }
  offset = offsetStart;
  for (i = 0; i < numRnd; ++i)
  {
    @uOpType@ v = randSrc[i];
    int bits = required@uTypeTag@Bits(v);
    @uOpType@ r = bsGet@uTypeTag@(bitStore, offset, bits);
    ensure(had_err, r == v);
    if (had_err)
    {
      env_log_log(env, "Expected %"@uOpPRI@", got %"@uOpPRI@
                  ", seed = %lu, i = %lu\n",
                  v, r, seedval, (unsigned long)i);
      freeResourcesAndReturn(had_err);
    }
    offset += bits;
  }
  env_log_log(env, "passed\n");
  if (numRnd > 0)
  {
    @uOpType@ v = randSrc[0], r = 0;
    unsigned numBits = required@uTypeTag@Bits(v);
    BitOffset i = offsetStart + numBits;
    @uOpType@ mask = ~(@uOpType@)0;
    if (numBits < @bitSize@)
      mask = ~(mask << numBits);
    env_log_log(env, "bsSetBit, bsClearBit, bsToggleBit, bsGetBit: ");
    while (v)
    {
      int lowBit = v & 1;
      v >>= 1;
      ensure(had_err, lowBit == (r = bsGetBit(bitStore, --i)));
      if (had_err)
      {
        env_log_log(env, "Expected %d, got %d, seed = %lu, i = %llu\n",
                    lowBit, (int)r, seedval, (unsigned long long)i);
        freeResourcesAndReturn(had_err);
      }
    }
    i = offsetStart + numBits;
    bsClear(bitStoreCopy, offsetStart, numBits, random()&1);
    v = randSrc[0];
    while (v)
    {
      int lowBit = v & 1;
      v >>= 1;
      if (lowBit)
        bsSetBit(bitStoreCopy, --i);
      else
        bsClearBit(bitStoreCopy, --i);
    }
    v = randSrc[0];
    r = bsGet@uTypeTag@(bitStoreCopy, offsetStart, numBits);
    ensure(had_err, r == v);
    if (had_err)
    {
      env_log_log(env, "Expected %"@uOpPRI@", got %"@uOpPRI@
                  ", seed = %lu\n", v, r, seedval);
      freeResourcesAndReturn(had_err);
    }
    for (i = 0; i < numBits; ++i)
      bsToggleBit(bitStoreCopy, offsetStart + i);
    r = bsGet@uTypeTag@(bitStoreCopy, offsetStart, numBits);
    ensure(had_err, r == (v = (~v & mask)));
    if (had_err)
    {
      env_log_log(env, "Expected %"@uOpPRI@", got %"@uOpPRI@
                  ", seed = %lu\n", v, r, seedval);
      freeResourcesAndReturn(had_err);
    }
    env_log_log(env, "passed\n");
  }
  if (numRnd > 1)
  {
    env_log_log(env, "bsCompare: ");
    {
      @uOpType@ v0 = randSrc[0];
      int bits0 = required@uTypeTag@Bits(v0);
      @uOpType@ r0;
      offset = offsetStart;
      r0 = bsGet@uTypeTag@(bitStore, offset, bits0);
      for (i = 1; i < numRnd; ++i)
      {
        @uOpType@ v1 = randSrc[i];
        int bits1 = required@uTypeTag@Bits(v1);
        @uOpType@ r1 = bsGet@uTypeTag@(bitStore, offset + bits0, bits1);
        int result = -2;   /*< -2 is not a return value of bsCompare, thus
                            *   if it is displayed, there was an earlier
                            *   error. */
        ensure(had_err, r0 == v0 && r1 == v1);
        ensure(had_err, icmp(v0, v1) ==
               (result = bsCompare(bitStore, offset, bits0,
                                   bitStore, offset + bits0, bits1)));
        if (had_err)
        {
          env_log_log(env, "Expected v0 %s v1, got v0 %s v1,\n for v0=%"
                      @uOpPRI@" and v1=%"@uOpPRI@",\n"
                      "seed = %lu, i = %lu, bits0=%u, bits1=%u\n",
                      (v0 > v1?">":(v0 < v1?"<":"==")),
                      (result > 0?">":(result < 0?"<":"==")), v0, v1,
                      seedval, (unsigned long)i, bits0, bits1);
          freeResourcesAndReturn(had_err);
        }
        offset += bits0;
        bits0 = bits1;
        v0 = v1;
        r0 = r1;
      }
    }
    env_log_log(env, "passed\n");
  }
  env_log_log(env, "bsStoreUniform@uTypeTag@Array/bsGet@uTypeTag@: ");
  {
    unsigned numBits = random()%@bitSize@ + 1;
    @uOpType@ mask = ~(@uOpType@)0;
    if (numBits < @bitSize@)
      mask = ~(mask << numBits);
    offset = offsetStart;
    bsStoreUniform@uTypeTag@Array(bitStore, offset, numBits, numRnd, randSrc);
    for (i = 0; i < numRnd; ++i)
    {
      @uOpType@ v = randSrc[i] & mask;
      @uOpType@ r = bsGet@uTypeTag@(bitStore, offset, numBits);
      ensure(had_err, r == v);
      if (had_err)
      {
        env_log_log(env, "Expected %"@uOpPRI@", got %"@uOpPRI@",\n"
                    "seed = %lu, i = %lu, bits=%u\n",
                    v, r, seedval, (unsigned long)i, numBits);
        freeResourcesAndReturn(had_err);
      }
      offset += numBits;
    }
    env_log_log(env, "passed\n");
    env_log_log(env,
                "bsStoreUniform@uTypeTag@Array/bsGetUniform@uTypeTag@Array: ");
    bsGetUniform@uTypeTag@Array(bitStore, offset = offsetStart,
                               numBits, numRnd, randCmp);
    for (i = 0; i < numRnd; ++i)
    {
      @uOpType@ v = randSrc[i] & mask;
      @uOpType@ r = randCmp[i];
      ensure(had_err, r == v);
      if (had_err)
      {
        env_log_log(env,
                    "Expected %"@uOpPRI@", got %"@uOpPRI@",\n seed = %lu,"
                    " i = %lu, bits=%u\n",
                    v, r, seedval, (unsigned long)i, numBits);
        freeResourcesAndReturn(had_err);
      }
    }
    if (numRnd > 1)
    {
      @uOpType@ v = randSrc[0] & mask;
      @uOpType@ r;
      bsGetUniform@uTypeTag@Array(bitStore, offsetStart,
                                 numBits, 1, &r);
      if (r != v)
      {
        env_log_log(env,
                    "Expected %"@uOpPRI@", got %"@uOpPRI@", seed = %lu,"
                    " one value extraction\n",
                    v, r, seedval);
        freeResourcesAndReturn(had_err);
      }
    }
    env_log_log(env, " passed\n");
  }
  /* int types */
  env_log_log(env, "bsStore@iTypeTag@/bsGet@iTypeTag@: ");
  for (i = 0; i < numRnd; ++i)
  {
    @iOpType@ v = (@iOpType@)randSrc[i];
    unsigned bits = required@iTypeTag@Bits(v);
    bsStore@iTypeTag@(bitStore, offset, bits, v);
    offset += bits;
  }
  offset = offsetStart;
  for (i = 0; i < numRnd; ++i)
  {
    @iOpType@ v = randSrc[i];
    unsigned bits = required@iTypeTag@Bits(v);
    @iOpType@ r = bsGet@iTypeTag@(bitStore, offset, bits);
    ensure(had_err, r == v);
    if (had_err)
    {
      env_log_log(env, "Expected %"@dOpPRI@", got %"@dOpPRI@",\n"
                  "seed = %lu, i = %lu, bits=%u\n",
                  v, r, seedval, (unsigned long)i, bits);
      freeResourcesAndReturn(had_err);
    }
    offset += bits;
  }
  env_log_log(env, "passed\n");
  env_log_log(env, "bsStoreUniform@iTypeTag@Array/bsGet@iTypeTag@: ");
  {
    unsigned numBits = random()%@bitSize@ + 1;
    @iOpType@ mask = ~(@iOpType@)0;
    if (numBits < @bitSize@)
      mask = ~(mask << numBits);
    offset = offsetStart;
    bsStoreUniform@iTypeTag@Array(bitStore, offset, numBits, numRnd,
                                (@iOpType@ *)randSrc);
    for (i = 0; i < numRnd; ++i)
    {
      @iOpType@ m = (@iOpType@)1 << (numBits - 1);
      @iOpType@ v = (@iOpType@)((randSrc[i] & mask) ^ m) - m;
      @iOpType@ r = bsGet@iTypeTag@(bitStore, offset, numBits);
      ensure(had_err, r == v);
      if (had_err)
      {
        env_log_log(env, "Expected %"@dOpPRI@", got %"@dOpPRI@",\n"
                    "seed = %lu, i = %lu, numBits=%u\n",
                    v, r, seedval, (unsigned long)i, numBits);
        freeResourcesAndReturn(had_err);
      }
      offset += numBits;
    }
    env_log_log(env, "passed\n");
    env_log_log(env, "bsStoreUniform@iTypeTag@Array/bsGetUniform@iTypeTag@Array: ");
    bsGetUniform@iTypeTag@Array(bitStore, offset = offsetStart,
                              numBits, numRnd, (@iOpType@ *)randCmp);
    for (i = 0; i < numRnd; ++i)
    {
      @iOpType@ m = (@iOpType@)1 << (numBits - 1);
      @iOpType@ v = (@iOpType@)((randSrc[i] & mask) ^ m) - m;
      @iOpType@ r = randCmp[i];
      ensure(had_err, r == v);
      if (had_err)
      {
        env_log_log(env, "Expected %"@dOpPRI@", got %"@dOpPRI@
                    ", seed = %lu, i = %lu\n",
                    v, r, seedval, (unsigned long)i);
        freeResourcesAndReturn(had_err);
      }
    }
    if (numRnd > 0)
    {
      @iOpType@ m = (@iOpType@)1 << (numBits - 1);
      @iOpType@ v = (@iOpType@)((randSrc[0] & mask) ^ m) - m;
      @iOpType@ r;
      bsGetUniform@iTypeTag@Array(bitStore, offsetStart,
                                numBits, 1, &r);
      ensure(had_err, r == v);
      if (had_err)
      {
        env_log_log(env, "Expected %"@dOpPRI@", got %"@dOpPRI@
                    ", seed = %lu, one value extraction\n",
                    v, r, seedval);
        freeResourcesAndReturn(had_err);
      }
    }
    env_log_log(env, "passed\n");
  }
  if (numRnd > 0)
  {
    env_log_log(env, "bsCopy: ");
    {
      /* first decide how many of the values to use and at which to start */
      size_t numValueCopies, copyStart;
      BitOffset numCopyBits = 0, destOffset;
      unsigned numBits = random()%@bitSize@ + 1;
      @uOpType@ mask = ~(@uOpType@)0;
      if (numBits < @bitSize@)
        mask = ~(mask << numBits);
      if (random()&1)
      {
        numValueCopies = random()%(numRnd + 1);
        copyStart = random()%(numRnd - numValueCopies + 1);
      }
      else
      {
        copyStart = random() % numRnd;
        numValueCopies = random()%(numRnd - copyStart) + 1;
      }
      assert(copyStart + numValueCopies <= numRnd);
      offset = offsetStart + (BitOffset)copyStart * numBits;
      bsStoreUniform@uTypeTag@Array(bitStore, offset, numBits, numValueCopies,
                                    randSrc);
      destOffset = random()%(offsetStart + @bitSize@
                             * (BitOffset)(numRnd - numValueCopies) + 1);
      numCopyBits = (BitOffset)numBits * numValueCopies;
      /* the following bsCopy should be equivalent to:
       * bsStoreUniform@uTypeTag@Array(bitStoreCopy, destOffset,
       *                              numBits, numValueCopies, randSrc); */
      bsCopy(bitStore, offset, bitStoreCopy, destOffset, numCopyBits);
      ensure(had_err,
             bsCompare(bitStore, offset, numCopyBits,
                       bitStoreCopy, destOffset, numCopyBits) == 0);
      if (had_err)
      {
        env_log_log(env, "Expected equality on bitstrings\n"
                    "seed = %lu, offset = %llu, destOffset = %llu,"
                    " numCopyBits=%llu\n",
                    seedval, (unsigned long long)offset,
                    (unsigned long long)destOffset,
                    (unsigned long long)numCopyBits);
        /* FIXME: implement bitstring output function */
        freeResourcesAndReturn(had_err);
      }
      env_log_log(env, "passed\n");
    }
  }
  if (numRnd > 0)
  {
    env_log_log(env, "bsClear: ");
    {
      /* first decide how many of the values to use and at which to start */
      size_t numResetValues, resetStart;
      BitOffset numResetBits = 0;
      unsigned numBits = random()%@bitSize@ + 1;
      int bitVal = random()&1;
      @iOpType@ cmpVal = bitVal?-1:0;
      @uOpType@ mask = ~(@uOpType@)0;
      if (numBits < @bitSize@)
        mask = ~(mask << numBits);
      if (random()&1)
      {
        numResetValues = random()%(numRnd + 1);
        resetStart = random()%(numRnd - numResetValues + 1);
      }
      else
      {
        resetStart = random() % numRnd;
        numResetValues = random()%(numRnd - resetStart) + 1;
      }
      assert(resetStart + numResetValues <= numRnd);
      offset = offsetStart;
      bsStoreUniform@iTypeTag@Array(bitStore, offset, numBits, numRnd,
                                    (@iOpType@ *)randSrc);
      numResetBits = (BitOffset)numBits * numResetValues;
      bsClear(bitStore, offset + (BitOffset)resetStart * numBits,
              numResetBits, bitVal);
      {
        @iOpType@ m = (@iOpType@)1 << (numBits - 1);
        for (i = 0; i < resetStart; ++i)
        {
          @iOpType@ v = (@iOpType@)((randSrc[i] & mask) ^ m) - m;
          @iOpType@ r = bsGet@iTypeTag@(bitStore, offset, numBits);
          ensure(had_err, r == v);
          if (had_err)
          {
            env_log_log(env, "Expected %"@dOpPRI@", got %"@dOpPRI@",\n"
                        "seed = %lu, i = %lu, numBits=%u\n",
                        v, r, seedval, (unsigned long)i, numBits);
            freeResourcesAndReturn(had_err);
          }
          offset += numBits;
        }
        for (; i < resetStart + numResetValues; ++i)
        {
          @iOpType@ r = bsGet@iTypeTag@(bitStore, offset, numBits);
          ensure(had_err, r == cmpVal);
          if (had_err)
          {
            env_log_log(env, "Expected %"@dOpPRI@", got %"@dOpPRI@",\n"
                        "seed = %lu, i = %lu, numBits=%u\n",
                        cmpVal, r, seedval, (unsigned long)i, numBits);
            freeResourcesAndReturn(had_err);
          }
          offset += numBits;
        }
        for (; i < numRnd; ++i)
        {
          @iOpType@ v = (@iOpType@)((randSrc[i] & mask) ^ m) - m;
          @iOpType@ r = bsGet@iTypeTag@(bitStore, offset, numBits);
          ensure(had_err, r == v);
          if (had_err)
          {
            env_log_log(env, "Expected %"@dOpPRI@", got %"@dOpPRI@",\n"
                        "seed = %lu, i = %lu, numBits=%u\n",
                        v, r, seedval, (unsigned long)i, numBits);
            freeResourcesAndReturn(had_err);
          }
          offset += numBits;
        }
      }
    }
    env_log_log(env, "passed\n");
  }
  if (numRnd > 0)
  {
    env_log_log(env, "bs1BitsCount: ");
    {
      /* first decide how many of the values to use and at which to start */
      size_t numCountValues, countStart;
      BitOffset numCountBits = 0, bitCountRef = 0, bitCountCmp;
      unsigned numBits = random()%@bitSize@ + 1;
      @uOpType@ mask = ~(@uOpType@)0;
      if (numBits < @bitSize@)
        mask = ~(mask << numBits);
      if (random()&1)
      {
        numCountValues = random()%(numRnd + 1);
        countStart = random()%(numRnd - numCountValues + 1);
      }
      else
      {
        countStart = random() % numRnd;
        numCountValues = random()%(numRnd - countStart) + 1;
      }
      assert(countStart + numCountValues <= numRnd);
      offset = offsetStart;
      bsStoreUniform@uTypeTag@Array(bitStore, offset, numBits, numRnd, randSrc);
      numCountBits = (BitOffset)numBits * numCountValues;
      bitCountCmp = bs1BitsCount(bitStore,
                                 offset + (BitOffset)countStart * numBits,
                                 numCountBits);
      for (i = countStart; i < countStart + numCountValues; ++i)
      {
        @uOpType@ v = (@uOpType@)randSrc[i] & mask;
        bitCountRef += genBitCount(v);
      }
      ensure(had_err, bitCountRef == bitCountCmp);
      if (had_err)
      {
        env_log_log(env, "Expected %llu, got %llu,\n"
                    "seed = %lu, numBits=%u\n", (unsigned long long)bitCountRef,
                    (unsigned long long)bitCountCmp, seedval, numBits);
        freeResourcesAndReturn(had_err);
      }
      offset += numBits;
    }
    env_log_log(env, "passed\n");
  }
  freeResourcesAndReturn(had_err);
}
