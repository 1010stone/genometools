<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>GenomeTools C API</title>
<link rel="stylesheet" type="text/css" href="style.css">
</head>
<body>
<div id="menu">
<ul>
<li><a href="index.html">Overview</a></li>
<li><a href="pub/">Download</a></li>
<li><a href="cgi-bin/gitweb.cgi?p=genometools.git;a=summary">Browse source</a></li>
<li><a href="mailman/listinfo/gt-users">Mailing list</a></li>
<li><a href="http://genometools.lighthouseapp.com/">Issue tracker</a></li>
<li><a href="design.html">Design</a></li>
<li><a id="current" href="libgenometools.html">C API</a></li>
<li><a href="docs.html"><tt>gtscript</tt> docs</a></li>
<li><a href="annotationsketch.html"><tt>AnnotationSketch</tt></a></li>
<li><a href="license.html">License</a></li>
</ul>
</div>
<div id="main">
<h1><i>GenomeTools</i> C API</h1>
<p>
This document describes the <i>GenomeTools</i> C API (that is, all public interfaces which are part of <tt>libgenometools</tt>).
</p>
<p>
See the <a href="#Index">index</a> for an alphabetical list of all available
interfaces.
</p>
<h2>Classes</h2>
<ul>

  <li><a href="#GtAlphabet">GtAlphabet</a>

  <li><a href="#GtArray">GtArray</a>

  <li><a href="#GtBEDInStream">GtBEDInStream</a>

  <li><a href="#GtBittab">GtBittab</a>

  <li><a href="#GtBlock">GtBlock</a>

  <li><a href="#GtCanvas">GtCanvas</a>

  <li><a href="#GtCanvasCairoContext">GtCanvasCairoContext</a>

  <li><a href="#GtCanvasCairoFile">GtCanvasCairoFile</a>

  <li><a href="#GtCodonIterator">GtCodonIterator</a>

  <li><a href="#GtColor">GtColor</a>

  <li><a href="#GtCommentNode">GtCommentNode</a>

  <li><a href="#GtCstrTable">GtCstrTable</a>

  <li><a href="#GtCustomTrack">GtCustomTrack</a>

  <li><a href="#GtCustomTrackGcContent">GtCustomTrackGcContent</a>

  <li><a href="#GtCustomTrackScriptWrapper">GtCustomTrackScriptWrapper</a>

  <li><a href="#GtDiagram">GtDiagram</a>

  <li><a href="#GtDlist">GtDlist</a>

  <li><a href="#GtDlistelem">GtDlistelem</a>

  <li><a href="#GtEOFNode">GtEOFNode</a>

  <li><a href="#GtEncseq">GtEncseq</a>

  <li><a href="#GtEncseqBuilder">GtEncseqBuilder</a>

  <li><a href="#GtEncseqEncoder">GtEncseqEncoder</a>

  <li><a href="#GtEncseqLoader">GtEncseqLoader</a>

  <li><a href="#GtEncseqReader">GtEncseqReader</a>

  <li><a href="#GtError">GtError</a>

  <li><a href="#GtFeatureIndex">GtFeatureIndex</a>

  <li><a href="#GtFeatureIndexMemory">GtFeatureIndexMemory</a>

  <li><a href="#GtFeatureNode">GtFeatureNode</a>

  <li><a href="#GtFeatureNodeIterator">GtFeatureNodeIterator</a>

  <li><a href="#GtFile">GtFile</a>

  <li><a href="#GtGFF3InStream">GtGFF3InStream</a>

  <li><a href="#GtGFF3OutStream">GtGFF3OutStream</a>

  <li><a href="#GtGFF3Parser">GtGFF3Parser</a>

  <li><a href="#GtGTFInStream">GtGTFInStream</a>

  <li><a href="#GtGenomeNode">GtGenomeNode</a>

  <li><a href="#GtGraphics">GtGraphics</a>

  <li><a href="#GtHashmap">GtHashmap</a>

  <li><a href="#GtImageInfo">GtImageInfo</a>

  <li><a href="#GtIntervalTree">GtIntervalTree</a>

  <li><a href="#GtIntervalTreeNode">GtIntervalTreeNode</a>

  <li><a href="#GtLayout">GtLayout</a>

  <li><a href="#GtLogger">GtLogger</a>

  <li><a href="#GtMergeStream">GtMergeStream</a>

  <li><a href="#GtNodeStream">GtNodeStream</a>

  <li><a href="#GtNodeStreamClass">GtNodeStreamClass</a>

  <li><a href="#GtNodeVisitor">GtNodeVisitor</a>

  <li><a href="#GtPhase">GtPhase</a>

  <li><a href="#GtQueue">GtQueue</a>

  <li><a href="#GtRange">GtRange</a>

  <li><a href="#GtRecMap">GtRecMap</a>

  <li><a href="#GtRegionNode">GtRegionNode</a>

  <li><a href="#GtSequenceNode">GtSequenceNode</a>

  <li><a href="#GtSortStream">GtSortStream</a>

  <li><a href="#GtSplitter">GtSplitter</a>

  <li><a href="#GtStr">GtStr</a>

  <li><a href="#GtStrArray">GtStrArray</a>

  <li><a href="#GtStrand">GtStrand</a>

  <li><a href="#GtStyle">GtStyle</a>

  <li><a href="#GtTextWidthCalculator">GtTextWidthCalculator</a>

  <li><a href="#GtTextWidthCalculatorCairo">GtTextWidthCalculatorCairo</a>

  <li><a href="#GtTimer">GtTimer</a>

  <li><a href="#GtTransTable">GtTransTable</a>

  <li><a href="#GtTranslator">GtTranslator</a>

  <li><a href="#GtTypeChecker">GtTypeChecker</a>

  <li><a href="#GtTypeCheckerOBO">GtTypeCheckerOBO</a>

  <li><a href="#GtVisitorStream">GtVisitorStream</a>

</ul>
<h2>Modules</h2>
<ul>

  <li><a href="#Array2dim">Array2dim</a>

  <li><a href="#Assert">Assert</a>

  <li><a href="#Bsearch">Bsearch</a>

  <li><a href="#Countingsort">Countingsort</a>

  <li><a href="#Cstr">Cstr</a>

  <li><a href="#Endianess">Endianess</a>

  <li><a href="#Fileutils">Fileutils</a>

  <li><a href="#FunctionPointer">FunctionPointer</a>

  <li><a href="#Grep">Grep</a>

  <li><a href="#Init">Init</a>

  <li><a href="#Log">Log</a>

  <li><a href="#MemoryAllocation">MemoryAllocation</a>

  <li><a href="#Msort">Msort</a>

  <li><a href="#POSIX">POSIX</a>

  <li><a href="#Parseutils">Parseutils</a>

  <li><a href="#Qsort">Qsort</a>

  <li><a href="#Unused">Unused</a>

  <li><a href="#Version">Version</a>

  <li><a href="#Warning">Warning</a>

  <li><a href="#XANSI">XANSI</a>

</ul>
<h2>Sole functions</h2>
<a name="gt_readmode_show"></a>

<code>const char*  gt_readmode_show(GtReadmode readmode)</code>
<p>
Returns the descriptive string for the readmode <code>readmode</code>.
</p>
<hr>
<a name="gt_readmode_parse"></a>

<code>int          gt_readmode_parse(const char *string, GtError *err)</code>
<p>
Returns the <code>GtReadmode</code> for the description <code>string</code>, which must be one
   of "fwd","rev","cpl" or "rcl". If <code>string</code> does not equal any of them,
   -1 is returned and <code>err</code> is set accordingly.
</p>
<hr>
<a name="GtAlphabet"></a>
<h2>Class GtAlphabet</h2>

<p> The following type is for storing alphabets.</p>

<hr>
<a name="gt_alphabet_new"></a>

<code>GtAlphabet*     gt_alphabet_new(bool isdna,
                               bool isprotein,
                               const GtStr *smapfile,
                               const GtStrArray *filenametab,
                               GtError *err)</code>
<p>
Returns a new <code>GtAlphabet</code> object as described by the following parameters:
   A DNA alphabet (see <code>gt_alphabet_new_dna()</code>) is created if <code>isdna</code> is set.
   Analogously, an amino acid alphabet (see <code>gt_alphabet_new_protein()</code>) is
   created if <code>isprotein</code> is set to true. If both are false, the alphabet will
   be read from the file given in <code>smapfile</code>. If <code>smapfile</code> is empty, then the
   sequence files in <code>filenametab</code> will be scanned to determine whether they
   are DNA or protein sequences, and the appropriate alphabet will be used
   (see <code>gt_alphabet_guess()</code>).
   Returns NULL on error, see <code>err</code> for details.
</p>
<hr>
<a name="gt_alphabet_new_dna"></a>

<code>GtAlphabet*     gt_alphabet_new_dna(void)</code>
<p>
Return a <code>GtAlphabet</code> object which represents a DNA alphabet.
</p>
<hr>
<a name="gt_alphabet_new_protein"></a>

<code>GtAlphabet*     gt_alphabet_new_protein(void)</code>
<p>
Return a <code>GtAlphabet</code> object which represents a protein alphabet.
</p>
<hr>
<a name="gt_alphabet_new_empty"></a>

<code>GtAlphabet*     gt_alphabet_new_empty(void)</code>
<p>
Return an empty <code>GtAlphabet</code> object.
</p>
<hr>
<a name="gt_alphabet_new_from_file"></a>

<code>GtAlphabet*     gt_alphabet_new_from_file(const char *indexname, GtError *err)</code>
<p>
Return a <code>GtAlphabet</code> object, as read from an .al1 file specified by
   <code>indexname</code> (i.e. no al1 suffix necessary).
</p>
<hr>
<a name="gt_alphabet_guess"></a>

<code>GtAlphabet*     gt_alphabet_guess(const char *sequence, unsigned long seqlen)</code>
<p>
Try to guess which type the given <code>sequence</code> with <code>length</code> has (DNA or
   protein) and return an according <code>GtAlphabet*</code> object.
</p>
<hr>
<a name="gt_alphabet_clone"></a>

<code>GtAlphabet*     gt_alphabet_clone(const GtAlphabet *alphabet)</code>
<p>
Return a clone of <code>alphabet</code>.
</p>
<hr>
<a name="gt_alphabet_ref"></a>

<code>GtAlphabet*     gt_alphabet_ref(GtAlphabet *alphabet)</code>
<p>
Increase the reference count for <code>alphabet</code> and return it.
</p>
<hr>
<a name="gt_alphabet_delete"></a>

<code>void            gt_alphabet_delete(GtAlphabet *alphabet)</code>
<p>
Decrease the reference count for <code>alphabet</code> or delete it, if this was the
   last reference.
</p>
<hr>
<a name="gt_alphabet_add_mapping"></a>

<code>void            gt_alphabet_add_mapping(GtAlphabet *alphabet,
                                       const char *characters)</code>
<p>
Add the mapping of all given <code>characters</code> to the given <code>alphabet</code>. The first
   character is the result of subsequent <code>gt_alphabet_decode()</code> calls.
</p>
<hr>
<a name="gt_alphabet_add_wildcard"></a>

<code>void            gt_alphabet_add_wildcard(GtAlphabet *alphabet, char wildcard)</code>
<p>
Add <code>wildcard</code> to the <code>alphabet</code>.
</p>
<hr>
<a name="gt_alphabet_symbolmap"></a>

<code>const GtUchar*  gt_alphabet_symbolmap(const GtAlphabet *alphabet)</code>
<p>
Returns the array of symbols from <code>alphabet</code> such that the index of the
   character equals its encoding.
</p>
<hr>
<a name="gt_alphabet_num_of_chars"></a>

<code>unsigned int    gt_alphabet_num_of_chars(const GtAlphabet *alphabet)</code>
<p>
Returns number of characters in <code>alphabet</code> (excluding wildcards).
</p>
<hr>
<a name="gt_alphabet_size"></a>

<code>unsigned int    gt_alphabet_size(const GtAlphabet *alphabet)</code>
<p>
Returns number of characters in <code>alphabet</code> (including wildcards).
</p>
<hr>
<a name="gt_alphabet_characters"></a>

<code>const GtUchar*  gt_alphabet_characters(const GtAlphabet *alphabet)</code>
<p>
Returns an array of the characters in <code>alphabet</code>.
</p>
<hr>
<a name="gt_alphabet_wildcard_show"></a>

<code>GtUchar         gt_alphabet_wildcard_show(const GtAlphabet *alphabet)</code>
<p>
Returns the character used in <code>alphabet</code> to represent wildcards in output.
</p>
<hr>
<a name="gt_alphabet_bits_per_symbol"></a>

<code>unsigned int    gt_alphabet_bits_per_symbol(const GtAlphabet *alphabet)</code>
<p>
Returns the required number of bits required to represent a symbol
   in <code>alphabet</code>.
</p>
<hr>
<a name="gt_alphabet_output"></a>

<code>void            gt_alphabet_output(const GtAlphabet *alphabet, FILE *fpout)</code>
<p>
Writes a representation of <code>alphabet</code> to the file pointer <code>fpout</code>.
</p>
<hr>
<a name="gt_alphabet_to_file"></a>

<code>int             gt_alphabet_to_file(const GtAlphabet *alpha,
                                   const char *indexname,
                                   GtError *err)</code>
<p>
Writes a representation of <code>alphabet</code> to the .al1 output file as specified
   by <code>indexname</code> (i.e. without the .al1 suffix).
</p>
<hr>
<a name="gt_alphabet_pretty_symbol"></a>

<code>GtUchar         gt_alphabet_pretty_symbol(const GtAlphabet *alphabet,
                                         unsigned int currentchar)</code>
<p>
Returns the printable character specified in <code>alphabet</code> for <code>currentchar</code>.
</p>
<hr>
<a name="gt_alphabet_echo_pretty_symbol"></a>

<code>void            gt_alphabet_echo_pretty_symbol(const GtAlphabet *alphabet,
                                              FILE *fpout,
                                              GtUchar currentchar)</code>
<p>
Prints the printable character specified in <code>alphabet</code> for <code>currentchar</code> on
   <code>fpout</code>.
</p>
<hr>
<a name="gt_alphabet_is_protein"></a>

<code>bool            gt_alphabet_is_protein(const GtAlphabet *alphabet)</code>
<p>
The following method checks if the given <code>alphabet</code> is the protein
   alphabet with the aminoacids A, C, D, E, F, G, H, I, K, L, M, N, P, Q, R, S,
   T, V, W, Y written in lower or upper case and returns <code>true</code>, if this is the
   case (<code>false</code> otherwise).
</p>
<hr>
<a name="gt_alphabet_is_dna"></a>

<code>bool            gt_alphabet_is_dna(const GtAlphabet *alphabet)</code>
<p>
The following method checks if the given alphabet is the DNA alphabet with
   the bases A, C, G, T written in lower or upper case and returns <code>true</code>, if
   this is the case (<code>false</code> otherwise).
</p>
<hr>
<a name="gt_alphabet_valid_input"></a>

<code>bool            gt_alphabet_valid_input(const GtAlphabet *alphabet, char c)</code>
<p>
Returns true if the character <code>c</code> is defined in <code>alphabet</code>.
</p>
<hr>
<a name="gt_alphabet_encode"></a>

<code>GtUchar         gt_alphabet_encode(const GtAlphabet *alphabet, char c)</code>
<p>
Encode character <code>c</code> with given <code>alphabet</code>.
   Ensure that <code>c</code> is encodable with the given <code>alphabet</code>!
</p>
<hr>
<a name="gt_alphabet_decode"></a>

<code>char            gt_alphabet_decode(const GtAlphabet *alphabet, GtUchar c)</code>
<p>
Decode character <code>c</code> with given <code>alphabet</code>.
</p>
<hr>
<a name="gt_alphabet_encode_seq"></a>

<code>void            gt_alphabet_encode_seq(const GtAlphabet *alphabet, GtUchar *out,
                                      const char *in, unsigned long length)</code>
<p>
Encode sequence <code>in</code> of given <code>length</code> with <code>alphabet</code> and store the result
   in <code>out</code>. <code>in</code> has to be encodable with the given <code>alphabet</code>!
</p>
<hr>
<a name="gt_alphabet_decode_seq_to_fp"></a>

<code>void            gt_alphabet_decode_seq_to_fp(const GtAlphabet *alphabet,
                                            FILE *fpout,
                                            const GtUchar *src,
                                            unsigned long len)</code>
<p>
Suppose the string <code>src</code> of length <code>len</code> was transformed according to the
   <code>alphabet</code>. The following method shows each character in <code>src</code> as the
   printable character specified in the transformation. The output is written
   to the given file pointer <code>fpout</code>.
</p>
<hr>
<a name="gt_alphabet_decode_seq_to_cstr"></a>

<code>void            gt_alphabet_decode_seq_to_cstr(const GtAlphabet *alphabet,
                                              char *dest,
                                              const GtUchar *src,
                                              unsigned long len)</code>
<p>
Analog to <code>gt_alphabet_decode_seq_to_fp()</code> but writing the output to
   <code>dest</code>.
</p>
<hr>
<a name="gt_alphabet_decode_seq_to_str"></a>

<code>GtStr*          gt_alphabet_decode_seq_to_str(const GtAlphabet *alphabet,
                                             const GtUchar *src,
                                             unsigned long len)</code>
<p>
Analog to <code>gt_alphabet_decode_seq_to_fp()</code> writing the output to
   a new <code>GtStr</code>.
</p>
<hr>
<a name="GtArray"></a>
<h2>Class GtArray</h2>

<p> <code>GtArray</code> objects are generic arrays for elements of a certain size which
   grow on demand. </p>

<hr>
<a name="gt_array_new"></a>

<code>GtArray*       gt_array_new(size_t size_of_elem)</code>
<p>
Return a new <code>GtArray*</code> object whose elements have the size
   <code>size_of_elem</code>.
</p>
<hr>
<a name="gt_array_ref"></a>

<code>GtArray*       gt_array_ref(GtArray *array)</code>
<p>
Increase the reference count for <code>array</code> and return it.
   If <code>array</code> is <code>NULL</code>, <code>NULL</code> is returned without any side effects.
</p>
<hr>
<a name="gt_array_clone"></a>

<code>GtArray*       gt_array_clone(const GtArray *array)</code>
<p>
Return a clone of <code>array</code>.
</p>
<hr>
<a name="gt_array_get"></a>

<code>void*          gt_array_get(const GtArray *array, unsigned long index)</code>
<p>
Return pointer to element number <code>index</code> of <code>array</code>. <code>index</code> has to be
   smaller than <code>gt_array_size(array)</code>.
</p>
<hr>
<a name="gt_array_get_first"></a>

<code>void*          gt_array_get_first(const GtArray *array)</code>
<p>
Return pointer to first element of <code>array</code>.
</p>
<hr>
<a name="gt_array_get_last"></a>

<code>void*          gt_array_get_last(const GtArray *array)</code>
<p>
Return pointer to last element of <code>array</code>.
</p>
<hr>
<a name="gt_array_pop"></a>

<code>void*          gt_array_pop(GtArray *array)</code>
<p>
Return pointer to last element of <code>array</code> and remove it from <code>array</code>.
</p>
<hr>
<a name="gt_array_get_space"></a>

<code>void*          gt_array_get_space(const GtArray *array)</code>
<p>
Return pointer to the internal space of <code>array</code> where the elements are
   stored.
</p>
<hr>
<a name="gt_array_add"></a>

<code>#define gt_array_add(array, elem)</code>
<p>
Add element <code>elem</code> to <code>array</code>. The size of <code>elem</code> must equal the given
   element size when the <code>array</code> was created and is determined automatically
   with the <code>sizeof</code> operator.
</p>
<hr>
<a name="gt_array_add_elem"></a>

<code>void           gt_array_add_elem(GtArray *array, void *elem,
                                size_t size_of_elem)</code>
<p>
Add element <code>elem</code> with size <code>size_of_elem</code> to <code>array</code>. <code>size_of_elem</code> must
   equal the given element size when the <code>array</code> was created. Usually, this
   method is not used directly and the macro <code>gt_array_add()</code> is used
   instead.
</p>
<hr>
<a name="gt_array_add_array"></a>

<code>void           gt_array_add_array(GtArray *dest, const GtArray *src)</code>
<p>
Add all elements of array <code>src</code> to the array <code>dest</code>. The element sizes of
   both arrays must be equal.
</p>
<hr>
<a name="gt_array_rem"></a>

<code>void           gt_array_rem(GtArray *array, unsigned long index)</code>
<p>
Remove element with number <code>index</code> from <code>array</code> in O(<code>gt_array_size(array)</code>)
   time. <code>index</code> has to be smaller than <code>gt_array_size(array)</code>.
</p>
<hr>
<a name="gt_array_rem_span"></a>

<code>void           gt_array_rem_span(GtArray *array, unsigned long frompos,
                                unsigned long topos)</code>
<p>
Remove elements starting with number <code>frompos</code> up to (and including) <code>topos</code>
   from <code>array</code> in O(<code>gt_array_size(array)</code>) time. <code>frompos</code> has to be smaller
   or equal than <code>topos</code> and both have to be smaller than
   <code>gt_array_size(array)</code>.
</p>
<hr>
<a name="gt_array_reverse"></a>

<code>void           gt_array_reverse(GtArray *array)</code>
<p>
Reverse the order of the elements in <code>array</code>.
</p>
<hr>
<a name="gt_array_set_size"></a>

<code>void           gt_array_set_size(GtArray *array, unsigned long size)</code>
<p>
Set the size of <code>array</code> to <code>size</code>. <code>size</code> must be smaller or equal than
   <code>gt_array_size(array)</code>.
</p>
<hr>
<a name="gt_array_reset"></a>

<code>void           gt_array_reset(GtArray *array)</code>
<p>
Reset the <code>array</code>. That is, afterwards the array has size 0.
</p>
<hr>
<a name="gt_array_elem_size"></a>

<code>size_t         gt_array_elem_size(const GtArray *array)</code>
<p>
Return the size of the elements stored in <code>array</code>.
</p>
<hr>
<a name="gt_array_size"></a>

<code>unsigned long  gt_array_size(const GtArray *array)</code>
<p>
Return the number of elements in <code>array</code>. If <code>array</code> equals <code>NULL</code>, 0 is
   returned.
</p>
<hr>
<a name="gt_array_sort"></a>

<code>void           gt_array_sort(GtArray *array, GtCompare compar)</code>
<p>
Sort <code>array</code> with the given compare function <code>compar</code>.
</p>
<hr>
<a name="gt_array_sort_stable"></a>

<code>void           gt_array_sort_stable(GtArray *array, GtCompare compar)</code>
<p>
Sort <code>array</code> in a stable way with the given compare function <code>compar</code>.
</p>
<hr>
<a name="gt_array_sort_with_data"></a>

<code>void           gt_array_sort_with_data(GtArray *array,
                                      GtCompareWithData compar,
                                      void *data)</code>
<p>
Sort <code>array</code> with the given compare function <code>compar</code>. Passes a pointer to
   userdata at <code>data</code>.
</p>
<hr>
<a name="gt_array_sort_stable_with_data"></a>

<code>void           gt_array_sort_stable_with_data(GtArray *array,
                                             GtCompareWithData compar,
                                             void *data)</code>
<p>
Sort <code>array</code> in a stable way with the given compare function <code>compar</code>. Passes
   a pointer to userdata at <code>data</code>.
</p>
<hr>
<a name="gt_array_cmp"></a>

<code>int            gt_array_cmp(const GtArray *array_a, const GtArray *array_b)</code>
<p>
Compare the content of <code>array_a</code> with the content of <code>array_b</code>.
   <code>array_a</code> and <code>array_b</code> must have the same <code>gt_array_size()</code> and
   <code>gt_array_elem_size()</code>.
</p>
<hr>
<a name="gt_array_delete"></a>

<code>void           gt_array_delete(GtArray *array)</code>
<p>
Decrease the reference count for <code>array</code> or delete it, if this was the last
   reference.
</p>
<hr>
<a name="GtBEDInStream"></a>
<h2>Class GtBEDInStream</h2>

<p> Implements the <code>GtNodeStream</code> interface. </p>

<hr>
<a name="gt_bed_in_stream_new"></a>

<code>GtNodeStream*  gt_bed_in_stream_new(const char *filename)</code>
<p>
Create a <code>GtBEDInStream*</code> which subsequently reads the BED file with the
   given <code>filename</code>. If <code>filename</code> equals <code>NULL</code>, the BED data is read from
   <code>stdin</code>.
</p>
<hr>
<a name="gt_bed_in_stream_set_feature_type"></a>

<code>void           gt_bed_in_stream_set_feature_type(GtBEDInStream *bed_in_stream,
                                                const char *type)</code>
<p>
Create BED features parsed by <code>bed_in_stream</code> with given <code>type</code> (instead of
   the default "BED_feature").
</p>
<hr>
<a name="gt_bed_in_stream_set_thick_feature_type"></a>

<code>void           gt_bed_in_stream_set_thick_feature_type(GtBEDInStream
                                                      *bed_in_stream,
                                                      const char *type)</code>
<p>
Create thick BED features parsed by <code>bed_in_stream</code> with given <code>type</code>
   (instead of the default "BED_thick_feature").
</p>
<hr>
<a name="gt_bed_in_stream_set_block_type"></a>

<code>void           gt_bed_in_stream_set_block_type(GtBEDInStream *bed_in_stream,
                                              const char *type)</code>
<p>
Create BED blocks parsed by <code>bed_in_stream</code> with given <code>type</code> (instead of
   the default "BED_block").
</p>
<hr>
<a name="GtBittab"></a>
<h2>Class GtBittab</h2>

<p> Implements arbitrary-length bit arrays and various operations on them. </p>

<hr>
<a name="gt_bittab_new"></a>

<code>GtBittab*      gt_bittab_new(unsigned long num_of_bits)</code>
<p>
Creates a new <code>GtBittab</code> of length <code>num_of_bits</code>, initialised to 0
</p>
<hr>
<a name="gt_bittab_set_bit"></a>

<code>void           gt_bittab_set_bit(GtBittab *b, unsigned long i)</code>
<p>
Sets bit <code>i</code> in <code>b</code> to 1.
</p>
<hr>
<a name="gt_bittab_unset_bit"></a>

<code>void           gt_bittab_unset_bit(GtBittab *b, unsigned long i)</code>
<p>
Sets bit <code>i</code> in <code>b</code> to 0.
</p>
<hr>
<a name="gt_bittab_complement"></a>

<code>void           gt_bittab_complement(GtBittab *a, const GtBittab *b)</code>
<p>
Sets <code>a</code> to be the complement of <code>b</code>.
</p>
<hr>
<a name="gt_bittab_equal"></a>

<code>void           gt_bittab_equal(GtBittab *a, const GtBittab *b)</code>
<p>
Sets <code>a</code> to be equal to <code>b</code>.
</p>
<hr>
<a name="gt_bittab_and"></a>

<code>void           gt_bittab_and(GtBittab *a, const GtBittab *b, const GtBittab *c)</code>
<p>
Sets <code>a</code> to be the bitwise AND of <code>b</code> and <code>c</code>.
</p>
<hr>
<a name="gt_bittab_or"></a>

<code>void           gt_bittab_or(GtBittab *a, const GtBittab *b, const GtBittab *c)</code>
<p>
Sets <code>a</code> to be the bitwise OR of <code>b</code> and <code>c</code>.
</p>
<hr>
<a name="gt_bittab_nand"></a>

<code>void           gt_bittab_nand(GtBittab *a, const GtBittab *b, const GtBittab *c)</code>
<p>
Sets <code>a</code> to be <code>b</code> NAND <code>c</code>.
</p>
<hr>
<a name="gt_bittab_and_equal"></a>

<code>void           gt_bittab_and_equal(GtBittab *a, const GtBittab *b)</code>
<p>
Sets <code>a</code> to be the bitwise AND of <code>a</code> and <code>b</code>.
</p>
<hr>
<a name="gt_bittab_or_equal"></a>

<code>void           gt_bittab_or_equal(GtBittab *a, const GtBittab *b)</code>
<p>
Sets <code>a</code> to be the bitwise OR of <code>a</code> and <code>b</code>.
</p>
<hr>
<a name="gt_bittab_shift_left_equal"></a>

<code>void           gt_bittab_shift_left_equal(GtBittab *b)</code>
<p>
Shifts <code>b</code> by one position to the left.
</p>
<hr>
<a name="gt_bittab_shift_right_equal"></a>

<code>void           gt_bittab_shift_right_equal(GtBittab *b)</code>
<p>
Shifts <code>b</code> by one position to the right.
</p>
<hr>
<a name="gt_bittab_unset"></a>

<code>void           gt_bittab_unset(GtBittab *b)</code>
<p>
Sets all bits in <code>b</code> to 0.
</p>
<hr>
<a name="gt_bittab_show"></a>

<code>void           gt_bittab_show(const GtBittab *b, FILE *fp)</code>
<p>
Outputs a representation of <code>b</code> to <code>fp</code>.
</p>
<hr>
<a name="gt_bittab_get_all_bitnums"></a>

<code>void           gt_bittab_get_all_bitnums(const GtBittab *b, GtArray *a)</code>
<p>
Fills <code>a</code> with the indices of all set bits in <code>b</code>.
</p>
<hr>
<a name="gt_bittab_bit_is_set"></a>

<code>bool           gt_bittab_bit_is_set(const GtBittab *b, unsigned long i)</code>
<p>
Returns <code>true</code> if bit <code>i</code> is set in <code>b</code>.
</p>
<hr>
<a name="gt_bittab_cmp"></a>

<code>bool           gt_bittab_cmp(const GtBittab *a, const GtBittab *b)</code>
<p>
Returns <code>true</code> if bittabs <code>a</code> and <code>b</code> are identical.
</p>
<hr>
<a name="gt_bittab_get_first_bitnum"></a>

<code>unsigned long  gt_bittab_get_first_bitnum(const GtBittab *b)</code>
<p>
Returns the index of the first set bit in <code>b</code>.
</p>
<hr>
<a name="gt_bittab_get_last_bitnum"></a>

<code>unsigned long  gt_bittab_get_last_bitnum(const GtBittab *b)</code>
<p>
Returns the index of the last set bit in <code>b</code>.
</p>
<hr>
<a name="gt_bittab_get_next_bitnum"></a>

<code>unsigned long  gt_bittab_get_next_bitnum(const GtBittab *b, unsigned long i)</code>
<p>
Returns the index of the next set bit in <code>b</code> with an index greater
   than <code>i</code>.
</p>
<hr>
<a name="gt_bittab_count_set_bits"></a>

<code>unsigned long  gt_bittab_count_set_bits(const GtBittab *b)</code>
<p>
Returns the number of set bits in <code>b</code>.
</p>
<hr>
<a name="gt_bittab_size"></a>

<code>unsigned long  gt_bittab_size(GtBittab *b)</code>
<p>
Returns the total number of bits of <code>b</code>.
</p>
<hr>
<a name="gt_bittab_delete"></a>

<code>void           gt_bittab_delete(GtBittab *b)</code>
<p>
Deletes <code>b</code> and frees all allocated space.
</p>
<hr>
<a name="GtBlock"></a>
<h2>Class GtBlock</h2>

<p> The <code>GtBlock</code> class represents a portion of screen space which relates to
   a specific ``top-level'' feature (and maybe its collapsed child features).
   It is the smallest layoutable unit in AnnotationSketch and has a caption
   (which may be displayed above the block rendering). </p>

<hr>
<a name="gt_block_new"></a>

<code>GtBlock*               gt_block_new(void)</code>
<p>
Creates a new <code>GtBlock</code> object.
</p>
<hr>
<a name="gt_block_ref"></a>

<code>GtBlock*               gt_block_ref(GtBlock*)</code>
<p>
Increases the reference count.
</p>
<hr>
<a name="gt_block_new_from_node"></a>

<code>GtBlock*               gt_block_new_from_node(GtFeatureNode *node)</code>
<p>
Create a new GtBlock object, setting block parameters (such as strand,
   range) from a given <code>node</code> template.
</p>
<hr>
<a name="gt_block_get_range"></a>

<code>GtRange                gt_block_get_range(const GtBlock*)</code>
<p>
Returns the base range of the <code>GtBlock</code>'s top level element.
</p>
<hr>
<a name="gt_block_get_range_ptr"></a>

<code>GtRange*               gt_block_get_range_ptr(const GtBlock *block)</code>
<p>
Returns a pointer to the base range of the <code>GtBlock</code>'s top level element.
</p>
<hr>
<a name="gt_block_has_only_one_fullsize_element"></a>

<code>bool                   gt_block_has_only_one_fullsize_element(const GtBlock*)</code>
<p>
Checks whether a <code>GtBlock</code> is occupied completely by a single element.
</p>
<hr>
<a name="gt_block_merge"></a>

<code>void                   gt_block_merge(GtBlock*, GtBlock*)</code>
<p>
Merges the contents of two <code>GtBlock</code>s into the first one.
</p>
<hr>
<a name="gt_block_clone"></a>

<code>GtBlock*               gt_block_clone(GtBlock*)</code>
<p>
Returns an independent copy of a <code>GtBlock</code>.
</p>
<hr>
<a name="gt_block_set_caption_visibility"></a>

<code>void                   gt_block_set_caption_visibility(GtBlock*, bool)</code>
<p>
Set whether a block caption should be displayed or not.
</p>
<hr>
<a name="gt_block_caption_is_visible"></a>

<code>bool                   gt_block_caption_is_visible(const GtBlock*)</code>
<p>
Returns whether a block caption should be displayed or not.
</p>
<hr>
<a name="gt_block_set_caption"></a>

<code>void                   gt_block_set_caption(GtBlock*, GtStr *caption)</code>
<p>
Sets the <code>GtBlock</code>'s caption to <code>caption</code>.
</p>
<hr>
<a name="gt_block_get_caption"></a>

<code>GtStr*                 gt_block_get_caption(const GtBlock*)</code>
<p>
Returns the <code>GtBlock</code>'s caption.
</p>
<hr>
<a name="gt_block_set_strand"></a>

<code>void                   gt_block_set_strand(GtBlock*, GtStrand strand)</code>
<p>
Sets the <code>GtBlock</code>'s strand to <code>strand</code>.
</p>
<hr>
<a name="gt_block_get_strand"></a>

<code>GtStrand               gt_block_get_strand(const GtBlock*)</code>
<p>
Returns the <code>GtBlock</code>'s strand.
</p>
<hr>
<a name="gt_block_get_top_level_feature"></a>

<code>GtFeatureNode*         gt_block_get_top_level_feature(const GtBlock*)</code>
<p>
Returns the <code>GtBlock</code>'s top level feature as a <code>GtFeatureNode</code> object.
</p>
<hr>
<a name="gt_block_get_size"></a>

<code>unsigned long          gt_block_get_size(const GtBlock*)</code>
<p>
Returns the number of elements in the <code>GtBlock</code>.
</p>
<hr>
<a name="gt_block_delete"></a>

<code>void                   gt_block_delete(GtBlock*)</code>
<p>
Deletes a <code>GtBlock</code>.
</p>
<hr>
<a name="GtCanvas"></a>
<h2>Class GtCanvas</h2>

<p> This class is an abstraction of a stateful drawing surface. Constructors
   must be implemented in subclasses as different arguments are required for
   drawing to specific graphics back-ends.  </p>

<hr>
<a name="gt_canvas_get_height"></a>

<code>unsigned long  gt_canvas_get_height(GtCanvas *canvas)</code>
<p>
Returns the height of the given <code>canvas</code>.
</p>
<hr>
<a name="gt_canvas_delete"></a>

<code>void           gt_canvas_delete(GtCanvas *canvas)</code>
<p>
Delete the given <code>canvas</code>.
</p>
<hr>
<a name="GtCanvasCairoContext"></a>
<h2>Class GtCanvasCairoContext</h2>

<p> Implements the <code>GtCanvas</code> interface using a Cairo context (<code>cairo_t</code>)
   as input. This Canvas uses the GtGraphicsCairo class.</p><p>   Drawing to a <code>cairo_t</code> allows the use of the  <em>AnnotationSketch</em> engine
   in any Cairo-based graphical application. </p>

<hr>
<a name="gt_canvas_cairo_context_new"></a>

<code>GtCanvas*  gt_canvas_cairo_context_new(GtStyle *style, cairo_t *context,
                                      double offsetpos,
                                      unsigned long width,
                                      unsigned long height,
                                      GtImageInfo *image_info,
                                      GtError *err)</code>
<p>
Create a new Canvas object tied to the cairo_t <code>context</code>, <code>width</code> and
   <code>height</code> using the style given in <code>style</code>. The optional <code>image_info</code> is
   filled when the created Canvas object is used to render a Diagram object.
   <code>offsetpos</code> determines where to start drawing on the surface.
</p>
<hr>
<a name="GtCanvasCairoFile"></a>
<h2>Class GtCanvasCairoFile</h2>

<p> Implements the <code>GtCanvas</code> interface.
   This Canvas uses the <code>GtGraphicsCairo</code> class.  </p>

<hr>
<a name="gt_canvas_cairo_file_new"></a>

<code>GtCanvas*  gt_canvas_cairo_file_new(GtStyle *style,
                                   GtGraphicsOutType output_type,
                                   unsigned long width,
                                   unsigned long height,
                                   GtImageInfo *image_info,
                                   GtError *err)</code>
<p>
Create a new <code>GtCanvasCairoFile</code> object with given <code>output_type</code> and
   <code>width</code> using the configuration given in <code>style</code>. The optional <code>image_info</code>
   is filled when the created object is used to render a <code>GtDiagram</code> object.
   Possible <code>GtGraphicsOutType</code> values are <code>GRAPHICS_PNG</code>, <code>GRAPHICS_PS</code>,
   <code>GRAPHICS_PDF</code> and <code>GRAPHICS_SVG</code>. Dependent on the local Cairo installation,
   not all of them may be available.
</p>
<hr>
<a name="gt_canvas_cairo_file_to_file"></a>

<code>int      gt_canvas_cairo_file_to_file(GtCanvasCairoFile *canvas,
                                     const char *filename, GtError *err)</code>
<p>
Write rendered <code>canvas</code> to the file with name <code>filename</code>. If this
   method returns a value other than 0, check <code>err</code> for an error message.
</p>
<hr>
<a name="gt_canvas_cairo_file_to_stream"></a>

<code>int      gt_canvas_cairo_file_to_stream(GtCanvasCairoFile *canvas,
                                       GtStr *stream)</code>
<p>
Append rendered <code>canvas</code> image data to given <code>stream</code>.
</p>
<hr>
<a name="GtCodonIterator"></a>
<h2>Class GtCodonIterator</h2>

<p> the ``codon iterator'' interface </p>

<hr>
<a name="gt_codon_iterator_current_position"></a>

<code>unsigned long           gt_codon_iterator_current_position(GtCodonIterator *ci)</code>
<p>
Returns the current reading offset of <code>ci</code>, starting from the position
   in the sequence given at iterator instantiation time.
</p>
<hr>
<a name="gt_codon_iterator_length"></a>

<code>unsigned long           gt_codon_iterator_length(GtCodonIterator *ci)</code>
<p>
Returns the length of the substring to scan, given at instantiation time.
</p>
<hr>
<a name="gt_codon_iterator_rewind"></a>

<code>void                    gt_codon_iterator_rewind(GtCodonIterator *ci)</code>
<p>
Rewinds the iterator to point again to the  position in the sequence given
   at iterator instantiation time.
</p>
<hr>
<a name="gt_codon_iterator_next"></a>

<code>GtCodonIteratorStatus   gt_codon_iterator_next(GtCodonIterator *ci,
                                              char *n1, char *n2, char *n3,
                                              unsigned int *frame,
                                              GtError *err)</code>
<p>
Sets the values of <code>n1</code>, <code>n2</code> and <code>n3</code> to the codon beginning at the current
   reading position of <code>ci</code> and then advances the reading position by one. The
   current reading frame shift (0, 1 or 2) is for the current codon is written
   to the position pointed to by <code>frame</code>.
   This function returns one of three status codes:
   GT_CODON_ITERATOR_OK    : a codon was read successfully,
   GT_CODON_ITERATOR_END   : no codon was read because the end of the scan
                             region has been reached,
   GT_CODON_ITERATOR_ERROR : no codon was read because an error occurred during
                             sequence access. See <code>err</code> for details.
</p>
<hr>
<a name="gt_codon_iterator_delete"></a>

<code>void                    gt_codon_iterator_delete(GtCodonIterator *ci)</code>
<p>
Deletes <code>ci</code>.
</p>
<hr>
<a name="GtColor"></a>
<h2>Class GtColor</h2>

<p> The <code>GtColor</code> class holds a RGB color definition. </p>

<hr>
<a name="gt_color_new"></a>

<code>GtColor*  gt_color_new(double red, double green, double blue, double alpha)</code>
<p>
Create a new <code>GtColor</code> object with the color given by the <code>red</code>, <code>green</code>,
   and <code>blue</code> arguments. The value for each color channel must be between 0
   and 1.
</p>
<hr>
<a name="gt_color_set"></a>

<code>void       gt_color_set(GtColor *color, double red, double green, double blue,
                       double alpha)</code>
<p>
Change the color of the <code>color</code> object to the color given by the <code>red</code>,
   <code>green</code>, and <code>blue</code> arguments. The value for each color channel must be
   between 0 and 1.
</p>
<hr>
<a name="gt_color_equals"></a>

<code>bool       gt_color_equals(const GtColor *c1, const GtColor *c2)</code>
<p>
Returns <code>true</code> if the colors <code>c1</code> and <code>c2</code> are equal.
</p>
<hr>
<a name="gt_color_delete"></a>

<code>void       gt_color_delete(GtColor *color)</code>
<p>
Delete the <code>color</code> object.
</p>
<hr>
<a name="GtCommentNode"></a>
<h2>Class GtCommentNode</h2>

<p> Implements the <code>GtGenomeNode</code> interface. Comment nodes correspond to comment
   lines in GFF3 files (i.e., lines which start with a single <code>#</code>). </p>

<hr>
<a name="gt_comment_node_new"></a>

<code>GtGenomeNode*             gt_comment_node_new(const char *comment)</code>
<p>
Create a new <code>GtCommentNode*</code> representing a <code>comment</code>. Please note that the
   single leading <code>#</code> which denotes comment lines in GFF3 files should not be
   part of <code>comment</code>.
</p>
<hr>
<a name="gt_comment_node_get_comment"></a>

<code>const char*               gt_comment_node_get_comment(const GtCommentNode
                                                     *comment_node)</code>
<p>
Return the comment stored in <code>comment_node</code>.
</p>
<hr>
<a name="GtCstrTable"></a>
<h2>Class GtCstrTable</h2>

<p> Implements a table of C-strings. </p>

<hr>
<a name="gt_cstr_table_new"></a>

<code>GtCstrTable*   gt_cstr_table_new(void)</code>
<p>
Creates a new <code>GtCstrTable</code> object.
</p>
<hr>
<a name="gt_cstr_table_delete"></a>

<code>void           gt_cstr_table_delete(GtCstrTable *table)</code>
<p>
Deletes <code>table</code>.
</p>
<hr>
<a name="gt_cstr_table_add"></a>

<code>void           gt_cstr_table_add(GtCstrTable *table, const char *cstr)</code>
<p>
Add <code>cstr</code> to <code>table</code>. <code>table</code> must not already contain <code>cstr</code>!
</p>
<hr>
<a name="gt_cstr_table_get"></a>

<code>const char*    gt_cstr_table_get(const GtCstrTable *table, const char *cstr)</code>
<p>
If a C-string equal to <code>cstr</code> is contained in <code>table</code>, it is returned.
   Otherwise NULL is returned.
</p>
<hr>
<a name="gt_cstr_table_get_all"></a>

<code>GtStrArray*    gt_cstr_table_get_all(const GtCstrTable *table)</code>
<p>
Return a <code>GtStrArray*</code> which contains all <code>cstr</code>s added to <code>table</code> in
   alphabetical order. The caller is responsible to free it!
</p>
<hr>
<a name="GtCustomTrack"></a>
<h2>Class GtCustomTrack</h2>

<p> The <code>GtCustomTrack</code> interface allows the <code>GtCanvas</code> to call user-defined
   drawing functions on a <code>GtGraphics</code> object. Please refer to the specific
   implementations' documentation for more information on a particular
   custom track. </p>

<hr>
<a name="gt_custom_track_ref"></a>

<code>GtCustomTrack*  gt_custom_track_ref(GtCustomTrack *ctrack)</code>
<p>
Increase the reference count for <code>ctrack</code>.
</p>
<hr>
<a name="gt_custom_track_delete"></a>

<code>void            gt_custom_track_delete(GtCustomTrack *ctrack)</code>
<p>
Delete the given <code>ctrack</code>.
</p>
<hr>
<a name="GtCustomTrackGcContent"></a>
<h2>Class GtCustomTrackGcContent</h2>

<p> Implements the <code>GtCustomTrack</code> interface. This custom track draws a plot of
   the GC content of a given sequence in the displayed range. As a window
   size for GC content calculation, <code>windowsize</code> is used. </p>

<hr>
<a name="gt_custom_track_gc_content_new"></a>

<code>GtCustomTrack*  gt_custom_track_gc_content_new(const char *seq,
                                              unsigned long seqlen,
                                              unsigned long windowsize,
                                              unsigned long height,
                                              double avg,
                                              bool show_scale)</code>
<p>
Creates a new <code>GtCustomTrackGcContent</code> for sequence <code>seq</code> with length
   <code>seqlen</code> of height <code>height</code> with windowsize <code>windowsize</code>.
   A horizontal line is drawn for the percentage value <code>avg</code>,
   with <code>avg</code> between 0 and 1. If <code>show_scale</code> is set to true, then a vertical
   scale rule is drawn at the left end of the curve.
</p>
<hr>
<a name="GtCustomTrackScriptWrapper"></a>
<h2>Class GtCustomTrackScriptWrapper</h2>

<p> Implements the <code>GtCustomTrack</code> interface. This custom track is
   only used to store pointers to external callbacks, e.g. written in a
   scripting language. This class does not store any state, relying on the
   developer of the external custom track class to do so.  </p>

<hr>
<a name="gt_custom_track_script_wrapper_new"></a>

<code>GtCustomTrack*  gt_custom_track_script_wrapper_new(GtCtScriptRenderFunc
                                                             render_func,
                                                  GtCtScriptGetHeightFunc
                                                             get_height_func,
                                                  GtCtScriptGetTitleFunc
                                                             get_title_func,
                                                  GtCtScriptFreeFunc
                                                             free_func)</code>
<p>
Creates a new <code>GtCustomTrackScriptWrapper</code> object.
</p>
<hr>
<a name="GtDiagram"></a>
<h2>Class GtDiagram</h2>

<p> The <code>GtDiagram</code> class acts as a representation of a sequence annotation
   diagram independent of any output format. Besides annotation features as
   annotation graphs, it can contain one or more custom tracks. A individual
   graphical representation of the <code>GtDiagram</code> contents is created by creating a
   <code>GtLayout</code> object using the <code>GtDiagram</code> and then calling
   <code>gt_layout_sketch()</code> with an appropriate <code>GtCanvas</code> object. </p>

<hr>
<a name="gt_diagram_new"></a>

<code>GtDiagram*  gt_diagram_new(GtFeatureIndex *feature_index, const char *seqid,
                          const GtRange *range, GtStyle *style, GtError*)</code>
<p>
Create a new <code>GtDiagram</code> object representing the feature nodes in
   <code>feature_index</code> in region <code>seqid</code> overlapping with <code>range</code>. The <code>GtStyle</code>
   object <code>style</code> will be used to determine collapsing options during the
   layout process.
</p>
<hr>
<a name="gt_diagram_new_from_array"></a>

<code>GtDiagram*  gt_diagram_new_from_array(GtArray *features, const GtRange *range,
                                     GtStyle *style)</code>
<p>
Create a new <code>GtDiagram</code> object representing the feature nodes in
   <code>features</code>. The features must overlap with <code>range</code>. The <code>GtStyle</code>
   object <code>style</code> will be used to determine collapsing options during the
   layout process.
</p>
<hr>
<a name="gt_diagram_get_range"></a>

<code>GtRange     gt_diagram_get_range(const GtDiagram *diagram)</code>
<p>
Returns the sequence position range represented by the <code>diagram</code>.
</p>
<hr>
<a name="gt_diagram_set_track_selector_func"></a>

<code>void        gt_diagram_set_track_selector_func(GtDiagram*, GtTrackSelectorFunc,
                                              void*)</code>
<p>
Assigns a GtTrackSelectorFunc to use to assign blocks to tracks.
   If none is set, or set to NULL, then track types are used as track keys
   (default behaviour).
</p>
<hr>
<a name="gt_diagram_reset_track_selector_func"></a>

<code>void        gt_diagram_reset_track_selector_func(GtDiagram *diagram)</code>
<p>
Resets the track selection behaviour of this <code>GtDiagram</code> back to the
   default.
</p>
<hr>
<a name="gt_diagram_add_custom_track"></a>

<code>void        gt_diagram_add_custom_track(GtDiagram*, GtCustomTrack*)</code>
<p>
Registers a new custom track in the diagram.
</p>
<hr>
<a name="gt_diagram_delete"></a>

<code>void        gt_diagram_delete(GtDiagram*)</code>
<p>
Delete the <code>diagram</code> and all its components.
</p>
<hr>
<a name="GtDlist"></a>
<h2>Class GtDlist</h2>

<p> A double-linked list which is sorted according to a <code>GtCompare</code> compare
   function (<code>qsort(3)</code>-like, only if one was supplied to the constructor). </p>

<hr>
<a name="gt_dlist_new"></a>

<code>GtDlist*       gt_dlist_new(GtCompare)</code>
<p>
Creates a new <code>GtDlist</code> sorted according to the <code>GtCompare</code> function. If it
   is NULL, no sorting is enforced.
</p>
<hr>
<a name="gt_dlist_first"></a>

<code>GtDlistelem*   gt_dlist_first(const GtDlist*)</code>
<p>
Returns the first <code>GtDlistelem</code> in a <code>GtDlist</code>.
</p>
<hr>
<a name="gt_dlist_last"></a>

<code>GtDlistelem*   gt_dlist_last(const GtDlist*)</code>
<p>
Returns the last <code>GtDlistelem</code> in a <code>GtDlist</code>.
</p>
<hr>
<a name="gt_dlist_find"></a>

<code>GtDlistelem*   gt_dlist_find(const GtDlist*, void *data)</code>
<p>
Returns the first <code>GtDlistelem</code> in a <code>GtDlist</code> which contains data identical
   to <code>data</code>. Takes O(n) time.
</p>
<hr>
<a name="gt_dlist_size"></a>

<code>unsigned long  gt_dlist_size(const GtDlist*)</code>
<p>
Returns the number of <code>GtDlistelem</code>s in a <code>GtDlist</code>.
</p>
<hr>
<a name="gt_dlist_add"></a>

<code>void           gt_dlist_add(GtDlist*, void *data)</code>
<p>
Adds a new <code>GtDlistelem</code> containing <code>data</code> to a <code>GtDlist</code>. Usually O(n), but
   O(1) if data is added in sorted order.
</p>
<hr>
<a name="gt_dlist_remove"></a>

<code>void           gt_dlist_remove(GtDlist *dlist, GtDlistelem *dlistelem)</code>
<p>
Remove <code>dlistelem</code> from <code>dlist</code> and free it.
</p>
<hr>
<a name="gt_dlist_example"></a>

<code>int            gt_dlist_example(GtError*)</code>
<p>
Example for usage of the <code>GtDlist</code> class.
</p>
<hr>
<a name="gt_dlist_delete"></a>

<code>void           gt_dlist_delete(GtDlist*)</code>
<p>
Deletes a <code>GtDlist</code>.
</p>
<hr>
<a name="GtDlistelem"></a>
<h2>Class GtDlistelem</h2>
<a name="gt_dlistelem_next"></a>

<code>GtDlistelem*   gt_dlistelem_next(const GtDlistelem*)</code>
<p>
Returns the successor of a <code>GtDlistelem</code>, or NULL if the element is the last
   one in the <code>GtDlist</code>.
</p>
<hr>
<a name="gt_dlistelem_previous"></a>

<code>GtDlistelem*   gt_dlistelem_previous(const GtDlistelem*)</code>
<p>
Returns the predecessor of a <code>GtDlistelem</code>, or NULL if the element is the
   first one in the <code>GtDlist</code>.
</p>
<hr>
<a name="gt_dlistelem_get_data"></a>

<code>void*          gt_dlistelem_get_data(const GtDlistelem*)</code>
<p>
Returns the data pointer attached to a <code>GtDlistelem</code>.
</p>
<hr>
<a name="GtEOFNode"></a>
<h2>Class GtEOFNode</h2>

<p> Implements the <code>GtGenomeNode</code> interface. EOF nodes mark the barrier between
   separate input files in an GFF3 stream. </p>

<hr>
<a name="gt_eof_node_new"></a>

<code>GtGenomeNode*             gt_eof_node_new(void)</code>
<p>
Create a new <code>GtEOFNode*</code> representing an EOF marker.
</p>
<hr>
<a name="GtEncseq"></a>
<h2>Class GtEncseq</h2>

<p> The <code>GtEncseq</code> class represents a concatenated collection of sequences from
   one or more input files in a bit-compressed encoding. It is stored in a
   number of <code>mmap()</code>able files, depending on which features it is meant to
   support.
   The main compressed sequence information is stored in an <em>encoded sequence</em>
   table, with the file suffix '.esq'. This table is the minimum requirement
   for the <code>GtEncseq</code> structure and must always be present. In addition, if
   support for multiple sequences is desired, a <em>sequence separator position</em>
   table with the '.ssp' suffix is required. If support for sequence
   descriptions is required, two additional tables are needed: a <em>description</em>
   table with the suffix '.des' and a <em>description separator</em> table with the
   file suffix '.sds'. Creation and requirement of these tables can be switched
   on and off using API functions as outlined below.
   The <code>GtEncseq</code> represents the stored sequences as one concatenated string.
   It allows access to the sequences by providing start positions and lengths
   for each sequence, making it possible to extract encoded substrings into a
   given buffer, as well as accessing single characters both in a random and a
   sequential fashion. </p>

<hr>
<a name="gt_encseq_total_length"></a>

<code>unsigned long      gt_encseq_total_length(const GtEncseq *encseq)</code>
<p>
Returns the total number of characters in all sequences of <code>encseq</code>,
   including separators and wildcards.
</p>
<hr>
<a name="gt_encseq_num_of_sequences"></a>

<code>unsigned long      gt_encseq_num_of_sequences(const GtEncseq *encseq)</code>
<p>
Returns the total number of sequences contained in <code>encseq</code>.
</p>
<hr>
<a name="gt_encseq_get_encoded_char"></a>

<code>GtUchar            gt_encseq_get_encoded_char(const GtEncseq *encseq,
                                             unsigned long pos,
                                             GtReadmode readmode)</code>
<p>
Returns the encoded representation of the character at position <code>pos</code> of
   <code>encseq</code> read in the direction as indicated by <code>readmode</code>.
</p>
<hr>
<a name="gt_encseq_get_decoded_char"></a>

<code>char               gt_encseq_get_decoded_char(const GtEncseq *encseq,
                                             unsigned long pos,
                                             GtReadmode readmode)</code>
<p>
Returns the decoded representation of the character at position <code>pos</code> of
   <code>encseq</code> read in the direction as indicated by <code>readmode</code>.
</p>
<hr>
<a name="gt_encseq_ref"></a>

<code>GtEncseq*          gt_encseq_ref(GtEncseq *encseq)</code>
<p>
Increases the reference count of <code>encseq</code>.
</p>
<hr>
<a name="gt_encseq_create_reader_with_readmode"></a>

<code>GtEncseqReader*    gt_encseq_create_reader_with_readmode(const GtEncseq *encseq,
                                                        GtReadmode readmode,
                                                        unsigned long startpos)</code>
<p>
Returns a new <code>GtEncseqReader</code> for <code>encseq</code>, starting from position
   <code>startpos</code>. Also supports reading the sequence from the reverse and
   delivering (reverse) complement characters on DNA alphabets using the
   <code>readmode</code> option. Please make sure that the <code>GT_READMODE_COMPL</code> and
   <code>GT_READMODE_REVCOMPL</code> readmodes are only used on DNA alphabets.
</p>
<hr>
<a name="gt_encseq_extract_encoded"></a>

<code>void               gt_encseq_extract_encoded(const GtEncseq *encseq,
                                              GtUchar *buffer,
                                              unsigned long frompos,
                                              unsigned long topos)</code>
<p>
Returns the encoded representation of the substring from position <code>frompos</code>
   to position <code>topos</code> of <code>encseq</code>. The result is written to the location
   pointed to by <code>buffer</code>, which must be large enough to hold the result.
</p>
<hr>
<a name="gt_encseq_extract_decoded"></a>

<code>void               gt_encseq_extract_decoded(const GtEncseq *encseq,
                                            char *buffer,
                                            unsigned long frompos,
                                            unsigned long topos)</code>
<p>
Returns the decoded version of the substring from position <code>frompos</code>
   to position <code>topos</code> of <code>encseq</code>. The result is written to the location
   pointed to by <code>buffer</code>, which must be large enough to hold the result.
</p>
<hr>
<a name="gt_encseq_seqlength"></a>

<code>unsigned long      gt_encseq_seqlength(const GtEncseq *encseq,
                                      unsigned long seqnum)</code>
<p>
Returns the length of the <code>seqnum</code>-th sequence in the <code>encseq</code>.
   Requires multiple sequence support enabled in <code>encseq</code>.
</p>
<hr>
<a name="gt_encseq_has_multiseq_support"></a>

<code>bool               gt_encseq_has_multiseq_support(const GtEncseq *encseq)</code>
<p>
Returns TRUE if <code>encseq</code> has multiple sequence support.
</p>
<hr>
<a name="gt_encseq_has_description_support"></a>

<code>bool               gt_encseq_has_description_support(const GtEncseq *encseq)</code>
<p>
Returns TRUE if <code>encseq</code> has description support.
</p>
<hr>
<a name="gt_encseq_seqstartpos"></a>

<code>unsigned long      gt_encseq_seqstartpos(const GtEncseq *encseq,
                                        unsigned long seqnum)</code>
<p>
Returns the start position of the <code>seqnum</code>-th sequence in the <code>encseq</code>.
   Requires multiple sequence support enabled in <code>encseq</code>.
</p>
<hr>
<a name="gt_encseq_seqnum"></a>

<code>unsigned long      gt_encseq_seqnum(const GtEncseq *encseq,
                                   unsigned long position)</code>
<p>
Returns the sequence number from the given <code>position</code> for a given
   GtEncseq <code>encseq</code>.
</p>
<hr>
<a name="gt_encseq_description"></a>

<code>const char*        gt_encseq_description(const GtEncseq *encseq,
                                        unsigned long *desclen,
                                        unsigned long seqnum)</code>
<p>
Returns a pointer to the description of the <code>seqnum</code>-th sequence in the
   <code>encseq</code>. The length of the returned string is written to the
   location pointed at by <code>desclen</code>.
   The returned description pointer is not <code>\0</code>-terminated!
   Requires description support enabled in <code>encseq</code>.
</p>
<hr>
<a name="gt_encseq_filenames"></a>

<code>const GtStrArray*  gt_encseq_filenames(const GtEncseq *encseq)</code>
<p>
Returns a <code>GtStrArray</code> of the names of the original sequence files
   contained in <code>encseq</code>.
</p>
<hr>
<a name="gt_encseq_num_of_files"></a>

<code>unsigned long      gt_encseq_num_of_files(const GtEncseq *encseq)</code>
<p>
Returns the number of files contained in <code>encseq</code>.
</p>
<hr>
<a name="gt_encseq_effective_filelength"></a>

<code>uint64_t           gt_encseq_effective_filelength(const GtEncseq *encseq,
                                                 unsigned long filenum)</code>
<p>
Returns the effective length (sum of sequence lengths) of the <code>filenum</code>-th
   file contained in <code>encseq</code>.
</p>
<hr>
<a name="gt_encseq_filestartpos"></a>

<code>unsigned long      gt_encseq_filestartpos(const GtEncseq *encseq,
                                         unsigned long filenum)</code>
<p>
Returns the start position of the sequences of the  <code>filenum</code>-th file in the
 * <code>encseq</code>. Requires multiple file support enabled in <code>encseq</code>.
</p>
<hr>
<a name="gt_encseq_filenum"></a>

<code>unsigned long      gt_encseq_filenum(const GtEncseq *encseq,
                                    unsigned long position)</code>
<p>
Returns the file number from the given <code>position</code> for a given
   GtEncseq <code>encseq</code>.
</p>
<hr>
<a name="gt_encseq_alphabet"></a>

<code>GtAlphabet*        gt_encseq_alphabet(const GtEncseq *encseq)</code>
<p>
Returns the <code>GtAlphabet</code> associated with <code>encseq</code>.
</p>
<hr>
<a name="gt_encseq_mirror"></a>

<code>int               gt_encseq_mirror(GtEncseq *encseq, GtError *err)</code>
<p>
Extends <code>encseq</code>  by virtual reverse complement sequences.
   Returns 0 if mirroring has been successfully enabled, otherwise -1.
   <code>err</code> is set accordingly.
</p>
<hr>
<a name="gt_encseq_unmirror"></a>

<code>void               gt_encseq_unmirror(GtEncseq *encseq)</code>
<p>
Removes virtual reverse complement sequences added by
   <code>gt_encseq_mirror()</code>.
</p>
<hr>
<a name="gt_encseq_is_mirrored"></a>

<code>bool               gt_encseq_is_mirrored(const GtEncseq *encseq)</code>
<p>
Returns TRUE if <code>encseq</code> contains virtual reverse complement sequences as
   added by <code>gt_encseq_mirror()</code>.
</p>
<hr>
<a name="gt_encseq_delete"></a>

<code>void               gt_encseq_delete(GtEncseq *encseq)</code>
<p>
Deletes <code>encseq</code> and frees all associated space.
</p>
<hr>
<a name="GtEncseqBuilder"></a>
<h2>Class GtEncseqBuilder</h2>

<p> The <code>GtEncseqBuilder</code> class creates <code>GtEncseq</code> objects by constructing
   uncompressed, encoded string copies in memory. </p>

<hr>
<a name="gt_encseq_builder_new"></a>

<code>GtEncseqBuilder*  gt_encseq_builder_new(GtAlphabet *alpha)</code>
<p>
Creates a new <code>GtEncseqBuilder</code> using the alphabet <code>alpha</code> as a basis for
   on-the-fly encoding of sequences in memory.
</p>
<hr>
<a name="gt_encseq_builder_enable_description_support"></a>

<code>void              gt_encseq_builder_enable_description_support(
                                                           GtEncseqBuilder *eb)</code>
<p>
Enables support for retrieving descriptions from the encoded sequence
   to be built by <code>eb</code>. Requires additional memory to hold the descriptions and
   a position index.
   Activated by default.
</p>
<hr>
<a name="gt_encseq_builder_disable_description_support"></a>

<code>void              gt_encseq_builder_disable_description_support(
                                                           GtEncseqBuilder *eb)</code>
<p>
Disables support for retrieving descriptions from the encoded sequence
   to be built by <code>eb</code>. Disabling this support will result in an error when
   trying to call the method <code>gt_encseq_description()</code> on the
   <code>GtEncseq</code> object created by <code>eb</code>.
</p>
<hr>
<a name="gt_encseq_builder_enable_multiseq_support"></a>

<code>void              gt_encseq_builder_enable_multiseq_support(GtEncseqBuilder *eb)</code>
<p>
Enables support for random access to multiple sequences in the encoded
   sequence to be built by <code>eb</code>. Requires additional memory for an index of
   starting positions. Activated by default.
</p>
<hr>
<a name="gt_encseq_builder_disable_multiseq_support"></a>

<code>void              gt_encseq_builder_disable_multiseq_support(
                                                           GtEncseqBuilder *eb)</code>
<p>
Disables support for random access to multiple sequences in the encoded
   sequence to be built by <code>eb</code>. Disabling this support will result in an
   error when trying to call the method <code>gt_encseq_seqlength()</code> or
   <code>gt_encseq_seqstartpos()</code> on the <code>GtEncseq</code> object created by <code>eb</code>.
</p>
<hr>
<a name="gt_encseq_builder_create_esq_tab"></a>

<code>void              gt_encseq_builder_create_esq_tab(GtEncseqBuilder *eb)</code>
<p>
Enables creation of the .esq table containing the encoded sequence itself.
   Naturally, enabled by default.
</p>
<hr>
<a name="gt_encseq_builder_do_not_create_esq_tab"></a>

<code>void              gt_encseq_builder_do_not_create_esq_tab(GtEncseqBuilder *eb)</code>
<p>
Disables creation of the .esq table.
</p>
<hr>
<a name="gt_encseq_builder_create_des_tab"></a>

<code>void              gt_encseq_builder_create_des_tab(GtEncseqBuilder *eb)</code>
<p>
Enables creation of the .des table containing sequence descriptions.
</p>
<hr>
<a name="gt_encseq_builder_do_not_create_des_tab"></a>

<code>void              gt_encseq_builder_do_not_create_des_tab(GtEncseqBuilder *eb)</code>
<p>
Disables creation of the .des table.
</p>
<hr>
<a name="gt_encseq_builder_create_ssp_tab"></a>

<code>void              gt_encseq_builder_create_ssp_tab(GtEncseqBuilder *eb)</code>
<p>
Enables creation of the .ssp table containing indexes for multiple sequences.
</p>
<hr>
<a name="gt_encseq_builder_do_not_create_ssp_tab"></a>

<code>void              gt_encseq_builder_do_not_create_ssp_tab(GtEncseqBuilder *eb)</code>
<p>
Disables creation of the .ssp table.
</p>
<hr>
<a name="gt_encseq_builder_create_sds_tab"></a>

<code>void              gt_encseq_builder_create_sds_tab(GtEncseqBuilder *eb)</code>
<p>
Enables creation of the .sds table containing indexes for sequence
   descriptions.
</p>
<hr>
<a name="gt_encseq_builder_do_not_create_sds_tab"></a>

<code>void              gt_encseq_builder_do_not_create_sds_tab(GtEncseqBuilder *eb)</code>
<p>
Disables creation of the .sds table.
</p>
<hr>
<a name="gt_encseq_builder_add_cstr"></a>

<code>void              gt_encseq_builder_add_cstr(GtEncseqBuilder *eb,
                                            const char *str,
                                            unsigned long strlen,
                                            const char *desc)</code>
<p>
Adds a sequence given as a C string <code>str</code> of length <code>strlen</code> to the
   encoded sequence to be built by <code>eb</code>. Additionally, a description can be
   given (<code>desc</code>). If description support is enabled, this must not be NULL.
   A copy will be made during the addition process and the sequence will
   be encoded using the alphabet set at the construction time of <code>eb</code>. Thus it
   must only contain symbols compatible with the alphabet.
</p>
<hr>
<a name="gt_encseq_builder_add_str"></a>

<code>void              gt_encseq_builder_add_str(GtEncseqBuilder *eb, GtStr *str,
                                           const char *desc)</code>
<p>
Adds a sequence given as a GtStr <code>str</code> to the encoded sequence to be built
   by <code>eb</code>. Additionally, a description can be given. If description support
   is enabled, <code>desc</code> must not be NULL.
   A copy will be made during the addition process and the sequence will
   be encoded using the alphabet set at the construction time of <code>eb</code>. Thus it
   must only contain symbols compatible with the alphabet.
</p>
<hr>
<a name="gt_encseq_builder_add_encoded"></a>

<code>void              gt_encseq_builder_add_encoded(GtEncseqBuilder *eb,
                                               const GtUchar *str,
                                               unsigned long strlen,
                                               const char *desc)</code>
<p>
Adds a sequence given as a pre-encoded string  <code>str</code> of length <code>strlen</code> to
   the encoded sequence to be built by <code>eb</code>. <code>str</code> must be encoded using the
   alphabet set at the construction time of <code>eb</code>.
   Does not take ownership of <code>str</code>.
   Additionally, a description <code>desc</code> can be given. If description support
   is enabled, this must not be NULL.
</p>
<hr>
<a name="gt_encseq_builder_add_encoded_own"></a>

<code>void              gt_encseq_builder_add_encoded_own(GtEncseqBuilder *eb,
                                                   const GtUchar *str,
                                                   unsigned long strlen,
                                                   const char *desc)</code>
<p>
Adds a sequence given as a pre-encoded string  <code>str</code> of length <code>strlen</code> to
   the encoded sequence to be built by <code>eb</code>. <code>str</code> must be encoded using the
   alphabet set at the construction time of <code>eb</code>.
   Always creates a copy of <code>str</code>, so it can be used with memory that is to be
   freed immediately after adding.
   Additionally, a description <code>desc</code> can be given. If description support
   is enabled, this must not be NULL.
</p>
<hr>
<a name="gt_encseq_builder_set_logger"></a>

<code>void              gt_encseq_builder_set_logger(GtEncseqBuilder*, GtLogger *l)</code>
<p>
Sets the logger to use by <code>ee</code> during encoding to <code>l</code>. Default is NULL (no
   logging).
</p>
<hr>
<a name="gt_encseq_builder_build"></a>

<code>GtEncseq*         gt_encseq_builder_build(GtEncseqBuilder *eb, GtError *err)</code>
<p>
Creates a new <code>GtEncseq</code> from the sequences added to <code>eb</code>.
   Returns a <code>GtEncseq</code> instance on success, or NULL on error.
   If an error occurred, <code>err</code> is set accordingly.
   The state of <code>eb</code> is reset to empty after successful creation of a new
   <code>GtEncseq</code> (like having called <code>gt_encseq_builder_reset()</code>).
</p>
<hr>
<a name="gt_encseq_builder_reset"></a>

<code>void              gt_encseq_builder_reset(GtEncseqBuilder *eb)</code>
<p>
Clears all added sequences and descriptions, resetting <code>eb</code> to a state
   similar to the state immediately after its initial creation.
</p>
<hr>
<a name="gt_encseq_builder_delete"></a>

<code>void              gt_encseq_builder_delete(GtEncseqBuilder *eb)</code>
<p>
Deletes <code>eb</code>.
</p>
<hr>
<a name="GtEncseqEncoder"></a>
<h2>Class GtEncseqEncoder</h2>

<p> The <code>GtEncseqEncoder</code> class creates objects encapsulating a parameter
   set for conversion from sequence files into encoded sequence files on
   secondary storage. </p>

<hr>
<a name="gt_encseq_encoder_new"></a>

<code>GtEncseqEncoder*  gt_encseq_encoder_new(void)</code>
<p>
Creates a new <code>GtEncseqEncoder</code>.
</p>
<hr>
<a name="gt_encseq_encoder_set_timer"></a>

<code>void              gt_encseq_encoder_set_timer(GtEncseqEncoder *ee, GtTimer *t)</code>
<p>
Sets <code>t</code> to be the timer for <code>ee</code>. Default is NULL (no progress
reporting).
</p>
<hr>
<a name="gt_encseq_encoder_get_timer"></a>

<code>GtTimer*          gt_encseq_encoder_get_timer(const GtEncseqEncoder *ee)</code>
<p>
Returns the timer set for <code>ee</code>.
</p>
<hr>
<a name="gt_encseq_encoder_use_representation"></a>

<code>int               gt_encseq_encoder_use_representation(GtEncseqEncoder *ee,
                                                      const char *sat,
                                                      GtError *err)</code>
<p>
Sets the representation of <code>ee</code> to <code>sat</code> which must be one of 'direct',
   'bytecompress', 'bit', 'uchar', 'ushort' or 'uint32'. Returns 0 on success,
   and a negative value on error (<code>err</code> is set accordingly).
</p>
<hr>
<a name="gt_encseq_encoder_representation"></a>

<code>GtStr*            gt_encseq_encoder_representation(const GtEncseqEncoder *ee)</code>
<p>
Returns the representation requested for <code>ee</code>.
</p>
<hr>
<a name="gt_encseq_encoder_use_symbolmap_file"></a>

<code>int               gt_encseq_encoder_use_symbolmap_file(GtEncseqEncoder *ee,
                                                      const char *smap,
                                                      GtError *err)</code>
<p>
Sets the symbol map file to use in <code>ee</code> to <code>smap</code> which must a valid
   alphabet description file. Returns 0 on success, and a negative value on
   error (<code>err</code> is set accordingly). Default is NULL (no alphabet
   transformation).
</p>
<hr>
<a name="gt_encseq_encoder_symbolmap_file"></a>

<code>const char*       gt_encseq_encoder_symbolmap_file(const GtEncseqEncoder *ee)</code>
<p>
Returns the symbol map file requested for <code>ee</code>.
</p>
<hr>
<a name="gt_encseq_encoder_set_logger"></a>

<code>void              gt_encseq_encoder_set_logger(GtEncseqEncoder *ee,
                                              GtLogger *l)</code>
<p>
Sets the logger to use by <code>ee</code> during encoding to <code>l</code>. Default is NULL (no
   logging).
</p>
<hr>
<a name="gt_encseq_encoder_enable_description_support"></a>

<code>void              gt_encseq_encoder_enable_description_support(
                                                           GtEncseqEncoder *ee)</code>
<p>
Enables support for retrieving descriptions from the encoded sequence
   encoded by <code>ee</code>. That is, the .des and .sds tables are created.
   This is a prerequisite for being able to activate description support in
   <code>gt_encseq_loader_require_description_support()</code>. Activated by default.
</p>
<hr>
<a name="gt_encseq_encoder_disable_description_support"></a>

<code>void              gt_encseq_encoder_disable_description_support(
                                                           GtEncseqEncoder *ee)</code>
<p>
Disables support for retrieving descriptions from the encoded sequence
   encoded by <code>ee</code>. That is, the .des and .sds tables are not created.
   Encoded sequences created without this support will not be able to be
   loaded via a <code>GtEncseqLoader</code> with
   <code>gt_encseq_loader_require_description_support()</code> enabled.
</p>
<hr>
<a name="gt_encseq_encoder_enable_multiseq_support"></a>

<code>void              gt_encseq_encoder_enable_multiseq_support(GtEncseqEncoder *ee)</code>
<p>
Enables support for random access to multiple sequences in the encoded
   sequence encoded by <code>ee</code>. That is, the .ssp table is created.
   This is a prerequisite for being able to activate description support in
   <code>gt_encseq_loader_require_multiseq_support()</code>. Activated by default.
</p>
<hr>
<a name="gt_encseq_encoder_disable_multiseq_support"></a>

<code>void              gt_encseq_encoder_disable_multiseq_support(
                                                           GtEncseqEncoder *ee)</code>
<p>
Disables support for random access to multiple sequences in the encoded
   sequence encoded by <code>ee</code>. That is, the .ssp table is not created.
   Encoded sequences created without this support will not be able to be
   loaded via a <code>GtEncseqLoader</code> with
   <code>gt_encseq_loader_require_multiseq_support()</code> enabled.
</p>
<hr>
<a name="gt_encseq_encoder_enable_lossless_support"></a>

<code>void              gt_encseq_encoder_enable_lossless_support(GtEncseqEncoder *ee)</code>
<p>
Enables support for lossless reproduction of the original sequence,
   regardless of alphabet transformations that may apply. Deactivated by
   default.
</p>
<hr>
<a name="gt_encseq_encoder_disable_lossless_support"></a>

<code>void              gt_encseq_encoder_disable_lossless_support(GtEncseqEncoder
                                                                           *ee)</code>
<p>
Enables support for lossless reproduction of the original sequence,
   regardless of alphabet transformations that may apply. Encoded sequences
   created without this support will not be able to be loaded via a
   <code>GtEncseqLoader</code> with <code>gt_encseq_loader_require_lossless_support()</code>
   enabled.
</p>
<hr>
<a name="gt_encseq_encoder_create_des_tab"></a>

<code>void              gt_encseq_encoder_create_des_tab(GtEncseqEncoder *ee)</code>
<p>
Enables creation of the .des table containing sequence descriptions.
   Enabled by default.
</p>
<hr>
<a name="gt_encseq_encoder_do_not_create_des_tab"></a>

<code>void              gt_encseq_encoder_do_not_create_des_tab(GtEncseqEncoder *ee)</code>
<p>
Disables creation of the .des table.
</p>
<hr>
<a name="gt_encseq_encoder_des_tab_requested"></a>

<code>bool              gt_encseq_encoder_des_tab_requested(const GtEncseqEncoder *ee)</code>
<p>
Returns TRUE if the creation of the .des table has been requested,
   FALSE otherwise.
</p>
<hr>
<a name="gt_encseq_encoder_create_ssp_tab"></a>

<code>void              gt_encseq_encoder_create_ssp_tab(GtEncseqEncoder *ee)</code>
<p>
Enables creation of the .ssp table containing indexes for multiple sequences.
   Enabled by default.
</p>
<hr>
<a name="gt_encseq_encoder_do_not_create_ssp_tab"></a>

<code>void              gt_encseq_encoder_do_not_create_ssp_tab(GtEncseqEncoder *ee)</code>
<p>
Disables creation of the .ssp table.
</p>
<hr>
<a name="gt_encseq_encoder_ssp_tab_requested"></a>

<code>bool              gt_encseq_encoder_ssp_tab_requested(const GtEncseqEncoder *ee)</code>
<p>
Returns TRUE if the creation of the .ssp table has been requested,
   FALSE otherwise.
</p>
<hr>
<a name="gt_encseq_encoder_create_sds_tab"></a>

<code>void              gt_encseq_encoder_create_sds_tab(GtEncseqEncoder *ee)</code>
<p>
Enables creation of the .sds table containing indexes for sequence
   descriptions. Enabled by default.
</p>
<hr>
<a name="gt_encseq_encoder_do_not_create_sds_tab"></a>

<code>void              gt_encseq_encoder_do_not_create_sds_tab(GtEncseqEncoder *ee)</code>
<p>
Disables creation of the .sds table.
</p>
<hr>
<a name="gt_encseq_encoder_sds_tab_requested"></a>

<code>bool              gt_encseq_encoder_sds_tab_requested(const GtEncseqEncoder *ee)</code>
<p>
Returns TRUE if the creation of the .sds table has been requested,
   FALSE otherwise.
</p>
<hr>
<a name="gt_encseq_encoder_set_input_dna"></a>

<code>void              gt_encseq_encoder_set_input_dna(GtEncseqEncoder *ee)</code>
<p>
Sets the sequence input type for <code>ee</code> to DNA.
</p>
<hr>
<a name="gt_encseq_encoder_is_input_dna"></a>

<code>bool              gt_encseq_encoder_is_input_dna(GtEncseqEncoder *ee)</code>
<p>
Returns TRUE if the input sequence has been defined as being DNA.
</p>
<hr>
<a name="gt_encseq_encoder_set_input_protein"></a>

<code>void              gt_encseq_encoder_set_input_protein(GtEncseqEncoder *ee)</code>
<p>
Sets the sequence input type for <code>ee</code> to protein/amino acids.
</p>
<hr>
<a name="gt_encseq_encoder_is_input_protein"></a>

<code>bool              gt_encseq_encoder_is_input_protein(GtEncseqEncoder *ee)</code>
<p>
Returns TRUE if the input sequence has been defined as being protein.
</p>
<hr>
<a name="gt_encseq_encoder_encode"></a>

<code>int               gt_encseq_encoder_encode(GtEncseqEncoder *ee,
                                          GtStrArray *seqfiles,
                                          const char *indexname,
                                          GtError *err)</code>
<p>
Encodes the sequence files given in <code>seqfiles</code> using the settings in <code>ee</code>
   and <code>indexname</code> as the prefix for the index tables. Returns 0 on success, or
   a negative value on error (<code>err</code> is set accordingly).
</p>
<hr>
<a name="gt_encseq_encoder_delete"></a>

<code>void              gt_encseq_encoder_delete(GtEncseqEncoder *ee)</code>
<p>
Deletes <code>ee</code>.
</p>
<hr>
<a name="GtEncseqLoader"></a>
<h2>Class GtEncseqLoader</h2>

<p> The <code>GtEncseqLoader</code> class creates <code>GtEncseq</code> objects by mapping index files
   from secondary storage into memory. </p>

<hr>
<a name="gt_encseq_loader_new"></a>

<code>GtEncseqLoader*   gt_encseq_loader_new(void)</code>
<p>
Creates a new <code>GtEncseqLoader</code>.
</p>
<hr>
<a name="gt_encseq_loader_enable_autosupport"></a>

<code>void              gt_encseq_loader_enable_autosupport(GtEncseqLoader *el)</code>
<p>
Enables auto-discovery of supported features when loading an encoded
   sequence. That is, if a file with <code>indexname</code>.<code>suffix</code> exists which
   is named like a table file, it is loaded automatically.
   Use <code>gt_encseq_has_multiseq_support()</code> etc. to query for these capabilities.
</p>
<hr>
<a name="gt_encseq_loader_disable_autosupport"></a>

<code>void              gt_encseq_loader_disable_autosupport(GtEncseqLoader *el)</code>
<p>
Disables auto-discovery of supported features.
</p>
<hr>
<a name="gt_encseq_loader_require_description_support"></a>

<code>void              gt_encseq_loader_require_description_support(
                                                            GtEncseqLoader *el)</code>
<p>
Enables support for retrieving descriptions from the encoded sequence
   to be loaded by <code>el</code>. That is, the .des and .sds tables must be present.
   For example, these tables are created by having enabled the
   <code>gt_encseq_encoder_enable_description_support()</code> option when encoding.
   Activated by default.
</p>
<hr>
<a name="gt_encseq_loader_drop_description_support"></a>

<code>void              gt_encseq_loader_drop_description_support(GtEncseqLoader *el)</code>
<p>
Disables support for retrieving descriptions from the encoded sequence
   to be loaded by <code>el</code>. That is, the .des and .sds tables need not be present.
   However, disabling this support will result in an error when trying to call
   the method <code>gt_encseq_description()</code> on the <code>GtEncseq</code>
   object created by <code>el</code>.
</p>
<hr>
<a name="gt_encseq_loader_require_multiseq_support"></a>

<code>void              gt_encseq_loader_require_multiseq_support(GtEncseqLoader *el)</code>
<p>
Enables support for random access to multiple sequences in the encoded
   sequence to be loaded by <code>el</code>. That is, the .ssp table must be present.
   For example, this table is created by having enabled the
   <code>gt_encseq_encoder_enable_multiseq_support()</code> option when encoding.
   Activated by default.
</p>
<hr>
<a name="gt_encseq_loader_drop_multiseq_support"></a>

<code>void              gt_encseq_loader_drop_multiseq_support(GtEncseqLoader *el)</code>
<p>
Disables support for random access to multiple sequences in the encoded
   sequence to be loaded by <code>el</code>. That is, the .ssp table needs not be present.
   However, disabling this support will result in an error when trying to call
   the method <code>gt_encseq_seqlength()</code> and <code>gt_encseq_seqstartpos()</code> on
   the <code>GtEncseq</code> object created by <code>el</code>.
</p>
<hr>
<a name="gt_encseq_loader_require_lossless_support"></a>

<code>void              gt_encseq_loader_require_lossless_support(GtEncseqLoader *el)</code>
<p>
Enables support for lossless reproduction of the original sequence
   in the encoded sequence to be loaded by <code>el</code>. That is, the .ois table
   must be present.
   For example, this table is created by having enabled the
   <code>gt_encseq_encoder_enable_lossless_support()</code> option when encoding.
   Deactivated by default.
</p>
<hr>
<a name="gt_encseq_loader_drop_lossless_support"></a>

<code>void              gt_encseq_loader_drop_lossless_support(GtEncseqLoader *el)</code>
<p>
Disables support for lossless reproduction of the original sequence
   in the encoded sequence to be loaded by <code>el</code>. That is, the .ois table
   needs not be present.
   However, disabling this support may result in a reduced alphabet
   representation when accessing decoded characters.
</p>
<hr>
<a name="gt_encseq_loader_require_des_tab"></a>

<code>void              gt_encseq_loader_require_des_tab(GtEncseqLoader *el)</code>
<p>
Requires presence of the .des table containing sequence descriptions.
   Enabled by default.
</p>
<hr>
<a name="gt_encseq_loader_do_not_require_des_tab"></a>

<code>void              gt_encseq_loader_do_not_require_des_tab(GtEncseqLoader *el)</code>
<p>
Disables requirement of the .des table for loading a <code>GtEncseq</code>
   using <code>el</code>.
</p>
<hr>
<a name="gt_encseq_loader_des_tab_required"></a>

<code>bool              gt_encseq_loader_des_tab_required(const GtEncseqLoader *el)</code>
<p>
Returns TRUE if a .des table must be present for loading to succeed.
</p>
<hr>
<a name="gt_encseq_loader_require_ssp_tab"></a>

<code>void              gt_encseq_loader_require_ssp_tab(GtEncseqLoader *el)</code>
<p>
Requires presence of the .ssp table containing indexes for multiple
   sequences. Enabled by default.
</p>
<hr>
<a name="gt_encseq_loader_do_not_require_ssp_tab"></a>

<code>void              gt_encseq_loader_do_not_require_ssp_tab(GtEncseqLoader *el)</code>
<p>
Disables requirement of the .ssp table for loading a <code>GtEncseq</code>
   using <code>el</code>.
</p>
<hr>
<a name="gt_encseq_loader_ssp_tab_required"></a>

<code>bool              gt_encseq_loader_ssp_tab_required(const GtEncseqLoader *el)</code>
<p>
Returns TRUE if a .ssp table must be present for loading to succeed.
</p>
<hr>
<a name="gt_encseq_loader_require_sds_tab"></a>

<code>void              gt_encseq_loader_require_sds_tab(GtEncseqLoader *el)</code>
<p>
Requires presence of the .sds table containing indexes for sequence
   descriptions. Enabled by default.
</p>
<hr>
<a name="gt_encseq_loader_do_not_require_sds_tab"></a>

<code>void              gt_encseq_loader_do_not_require_sds_tab(GtEncseqLoader *el)</code>
<p>
Disables requirement of the .sds table for loading a <code>GtEncseq</code>
   using <code>el</code>.
</p>
<hr>
<a name="gt_encseq_loader_sds_tab_required"></a>

<code>bool              gt_encseq_loader_sds_tab_required(const GtEncseqLoader *el)</code>
<p>
Returns TRUE if a .sds table must be present for loading to succeed.
</p>
<hr>
<a name="gt_encseq_loader_set_logger"></a>

<code>void              gt_encseq_loader_set_logger(GtEncseqLoader *el, GtLogger *l)</code>
<p>
Sets the logger to use by <code>ee</code> during encoding to <code>l</code>. Default is NULL (no
   logging).
</p>
<hr>
<a name="gt_encseq_loader_mirror"></a>

<code>void              gt_encseq_loader_mirror(GtEncseqLoader *el)</code>
<p>
Enables loading of a sequence using <code>el</code> with mirroring enabled from the
   start. Identical to invoking <code>gt_encseq_mirror()</code> directly after loading.
</p>
<hr>
<a name="gt_encseq_loader_do_not_mirror"></a>

<code>void              gt_encseq_loader_do_not_mirror(GtEncseqLoader *el)</code>
<p>
Disables loading of a sequence using <code>el</code> with mirroring enabled right from
   the start.
</p>
<hr>
<a name="gt_encseq_loader_load"></a>

<code>GtEncseq*         gt_encseq_loader_load(GtEncseqLoader *el,
                                       const char *indexname,
                                       GtError *err)</code>
<p>
Attempts to map the index files as specified by <code>indexname</code> using the options
   set in <code>el</code> using this interface. Returns a <code>GtEncseq</code> instance
   on success, or NULL on error. If an error occurred, <code>err</code> is set
   accordingly.
</p>
<hr>
<a name="gt_encseq_loader_delete"></a>

<code>void              gt_encseq_loader_delete(GtEncseqLoader *el)</code>
<p>
Deletes <code>el</code>.
</p>
<hr>
<a name="GtEncseqReader"></a>
<h2>Class GtEncseqReader</h2>

<p> The <code>GtEncseqReader</code> class represents the current state of a
   sequential scan of a <code>GtEncseq</code> region as an iterator. </p>

<hr>
<a name="gt_encseq_reader_reinit_with_readmode"></a>

<code>void             gt_encseq_reader_reinit_with_readmode(GtEncseqReader *esr,
                                                      const GtEncseq *encseq,
                                                      GtReadmode readmode,
                                                      unsigned long startpos)</code>
<p>
Reinitializes the given <code>esr</code> with the values as described in
   <code>gt_encseq_create_reader_with_readmode()</code>.
</p>
<hr>
<a name="gt_encseq_reader_next_encoded_char"></a>

<code>GtUchar          gt_encseq_reader_next_encoded_char(GtEncseqReader *esr)</code>
<p>
Returns the next encoded character from current position of <code>esr</code>, advancing
   the iterator by one position.
</p>
<hr>
<a name="gt_encseq_reader_next_decoded_char"></a>

<code>char             gt_encseq_reader_next_decoded_char(GtEncseqReader *esr)</code>
<p>
Returns the next decoded character from current position of <code>esr</code>, advancing
   the iterator by one position.
</p>
<hr>
<a name="gt_encseq_reader_delete"></a>

<code>void             gt_encseq_reader_delete(GtEncseqReader *esr)</code>
<p>
Deletes <code>esr</code>, freeing all associated space.
</p>
<hr>
<a name="GtError"></a>
<h2>Class GtError</h2>

<p>
   This class is used for the handling of <strong>user errors</strong> in <em>GenomeTools</em>.
   Thereby, the actual <code>GtError*</code> object is used to store the <em>error message</em>
   while it is signaled by the return value of the called function, if an error
   occured.</p><p>   By convention in <em>GenomeTools</em>, the <code>GtError*</code> object is always passed
   into a function as the last parameter and -1 (or <code>NULL</code> for constructors) is
   used as return value to indicate that an error occurred.
   Success is usually indicated by 0 as return value or via a non-<code>NULL</code> object
   pointer for constructors.</p><p>   It is possible to use <code>NULL</code> as an <code>GtError*</code> object, if one is not
   interested in the actual error message.</p><p>   Functions which do not get an <code>GtError*</code> object cannot fail due to a user
   error and it is not necessary to check their return code for an error
   condition.
</p>

<hr>
<a name="gt_error_new"></a>

<code>GtError*    gt_error_new(void)</code>
<p>
Return a new <code>GtError*</code> object
</p>
<hr>
<a name="gt_error_check"></a>

<code>#define gt_error_check(err)</code>
<p>
Insert an assertion to check that the error <code>err</code> is not set or is <code>NULL</code>.
   This macro should be used at the beginning of every routine which has an
   <code>GtError*</code> argument to make sure the error propagation has been coded
   correctly.
</p>
<hr>
<a name="gt_error_set"></a>

<code>void         gt_error_set(GtError *err, const char *format, ...)</code>
<p>
Set the error message stored in <code>err</code> according to <code>format</code> (as in
   <code>printf(3)</code>).
</p>
<hr>
<a name="gt_error_vset"></a>

<code>void         gt_error_vset(GtError *err, const char *format, va_list ap)</code>
<p>
Set the error message stored in <code>err</code> according to <code>format</code> (as in
   <code>vprintf(3)</code>).
</p>
<hr>
<a name="gt_error_set_nonvariadic"></a>

<code>void         gt_error_set_nonvariadic(GtError *err, const char *msg)</code>
<p>
Set the error message stored in <code>err</code> to <code>msg</code>.
</p>
<hr>
<a name="gt_error_is_set"></a>

<code>bool         gt_error_is_set(const GtError *err)</code>
<p>
Return <code>true</code> if the error <code>err</code> is set, <code>false</code> otherwise.
</p>
<hr>
<a name="gt_error_unset"></a>

<code>void         gt_error_unset(GtError *err)</code>
<p>
Unset the error <code>err</code>.
</p>
<hr>
<a name="gt_error_get"></a>

<code>const char*  gt_error_get(const GtError *err)</code>
<p>
Return the error string stored in <code>err</code> (the error must be set).
</p>
<hr>
<a name="gt_error_delete"></a>

<code>void         gt_error_delete(GtError *err)</code>
<p>
Delete the error object <code>err</code>.
</p>
<hr>
<a name="GtFeatureIndex"></a>
<h2>Class GtFeatureIndex</h2>

<p> This interface represents a searchable container for <code>FeatureNode</code> objects,
   typically root nodes of larger structures. How storage and searching takes
   place is left to the discretion of the implementing class.</p><p>   Output from a <code>gt_feature_index_get_features_*()</code> method should always
   be sorted by feature start position. </p>

<hr>
<a name="gt_feature_index_add_region_node"></a>

<code>void         gt_feature_index_add_region_node(GtFeatureIndex *feature_index,
                                             GtRegionNode *region_node)</code>
<p>
Add <code>region_node</code> to <code>feature_index</code>.
</p>
<hr>
<a name="gt_feature_index_add_feature_node"></a>

<code>void         gt_feature_index_add_feature_node(GtFeatureIndex *feature_index,
                                              GtFeatureNode *feature_node)</code>
<p>
Add <code>feature_node</code> to <code>feature_index</code>, associating it with a sequence
   region denoted by its identifier string.
</p>
<hr>
<a name="gt_feature_index_add_gff3file"></a>

<code>int          gt_feature_index_add_gff3file(GtFeatureIndex *feature_index,
                                          const char *gff3file, GtError *err)</code>
<p>
Add all features contained in <code>gff3file</code> to <code>feature_index</code>, if <code>gff3file</code> is
   valid. Otherwise, <code>feature_index</code> is not changed and <code>err</code> is set.
</p>
<hr>
<a name="gt_feature_index_get_features_for_seqid"></a>

<code>GtArray*     gt_feature_index_get_features_for_seqid(GtFeatureIndex*,
                                                    const char *seqid)</code>
<p>
Returns an array of <code>GtFeatureNodes</code> associated with a given sequence region
   identifier <code>seqid</code>.
</p>
<hr>
<a name="gt_feature_index_get_features_for_range"></a>

<code>int          gt_feature_index_get_features_for_range(GtFeatureIndex
                                                    *feature_index,
                                                    GtArray *results,
                                                    const char *seqid,
                                                    const GtRange *range,
                                                    GtError*)</code>
<p>
Look up genome features in <code>feature_index</code> for sequence region <code>seqid</code> in
   <code>range</code> and store them in <code>results</code>.
</p>
<hr>
<a name="gt_feature_index_get_first_seqid"></a>

<code>const char*  gt_feature_index_get_first_seqid(const GtFeatureIndex
                                             *feature_index)</code>
<p>
Returns the first sequence region identifier added to <code>feature_index</code>.
</p>
<hr>
<a name="gt_feature_index_get_seqids"></a>

<code>GtStrArray*  gt_feature_index_get_seqids(const GtFeatureIndex *feature_index)</code>
<p>
Returns a <code>GtStrArray</code> of all sequence region identifiers contained in
   <code>feature_index</code> (in alphabetical order).
</p>
<hr>
<a name="gt_feature_index_get_range_for_seqid"></a>

<code>void         gt_feature_index_get_range_for_seqid(GtFeatureIndex *feature_index,
                                                 GtRange *range,
                                                 const char *seqid)</code>
<p>
Writes the range of all features contained in the <code>feature_index</code> for
   region identifier <code>seqid</code> to the <code>GtRange</code> pointer <code>range</code>.
</p>
<hr>
<a name="gt_feature_index_has_seqid"></a>

<code>bool         gt_feature_index_has_seqid(const GtFeatureIndex *feature_index,
                                       const char *seqid)</code>
<p>
Returns <code>true</code> if the sequence region identified by <code>seqid</code> has been
  registered in the <code>feature_index</code>.
</p>
<hr>
<a name="gt_feature_index_delete"></a>

<code>void         gt_feature_index_delete(GtFeatureIndex*)</code>
<p>
Deletes the <code>feature_index</code> and all its referenced features.
</p>
<hr>
<a name="GtFeatureIndexMemory"></a>
<h2>Class GtFeatureIndexMemory</h2>

<p> The <code>GtFeatureIndexMemory</code> class implements a <code>GtFeatureIndex</code> in memory.
   Features are organised by region node. Each region node collects its
   feature nodes in an interval tree structure, which allows for efficient
   range queries. </p>

<hr>
<a name="gt_feature_index_memory_new"></a>

<code>GtFeatureIndex*  gt_feature_index_memory_new(void)</code>
<p>
Creates a new <code>GtFeatureIndexMemory</code> object.
</p>
<hr>
<a name="GtFeatureNode"></a>
<h2>Class GtFeatureNode</h2>

<p> Implements the <code>GtGenomeNode</code> interface. A single feature node corresponds
   to a regular GFF3 line (i.e., a line which does not start with <code>#</code>).
   Part-of relationships (which are realised in GFF3 with the <code>Parent</code> and <code>ID</code>
   attributes) are realised in the C API with the
   <code>gt_feature_node_add_child()</code> method. </p>

<hr>
<a name="gt_feature_node_new"></a>

<code>GtGenomeNode*  gt_feature_node_new(GtStr *seqid, const char *type,
                                  unsigned long start, unsigned long end,
                                  GtStrand strand)</code>
<p>
Create an new <code>GtFeatureNode*</code> on sequence with ID <code>seqid</code> and type <code>type</code>
   which lies from <code>start</code> to <code>end</code> on strand <code>strand</code>.
   The <code>GtFeatureNode*</code> stores a new reference to <code>seqid</code>, so make sure you do
   not modify the original <code>seqid</code> afterwards!
   <code>start</code> and <code>end</code> always refer to the forward strand, therefore <code>start</code> has
   to be smaller or equal than <code>end</code>.
</p>
<hr>
<a name="gt_feature_node_new_standard_gene"></a>

<code>GtGenomeNode*  gt_feature_node_new_standard_gene(void)</code>
<p>
Return the ``standard gene'' (mainly for testing purposes).
</p>
<hr>
<a name="gt_feature_node_add_child"></a>

<code>void           gt_feature_node_add_child(GtFeatureNode *parent,
                                        GtFeatureNode *child)</code>
<p>
Add <code>child</code> node to <code>parent</code> node. <code>parent</code> takes ownership of <code>child</code>.
</p>
<hr>
<a name="gt_feature_node_get_source"></a>

<code>const char*    gt_feature_node_get_source(const GtFeatureNode *feature_node)</code>
<p>
Return the source of <code>feature_node</code>. If no source has been set, "." is
   returned. Corresponds to column 2 of regular GFF3 lines.
</p>
<hr>
<a name="gt_feature_node_set_source"></a>

<code>void           gt_feature_node_set_source(GtFeatureNode *feature_node,
                                         GtStr *source)</code>
<p>
Set the <code>source</code> of <code>feature_node</code>. Stores a new reference to <code>source</code>.
   Corresponds to column 2 of regular GFF3 lines.
</p>
<hr>
<a name="gt_feature_node_has_source"></a>

<code>bool           gt_feature_node_has_source(const GtFeatureNode *feature_node)</code>
<p>
Return <code>true</code> if <code>feature_node</code> has a defined source (i.e., on different
   from "."). <code>false</code> otherwise.
</p>
<hr>
<a name="gt_feature_node_get_type"></a>

<code>const char*    gt_feature_node_get_type(const GtFeatureNode *feature_node)</code>
<p>
Return the type of <code>feature_node</code>.
   Corresponds to column 3 of regular GFF3 lines.
</p>
<hr>
<a name="gt_feature_node_set_type"></a>

<code>void           gt_feature_node_set_type(GtFeatureNode *feature_node,
                                       const char *type)</code>
<p>
Set the type of <code>feature_node</code> to <code>type</code>.
</p>
<hr>
<a name="gt_feature_node_has_type"></a>

<code>bool           gt_feature_node_has_type(GtFeatureNode *feature_node,
                                       const char *type)</code>
<p>
Return <code>true</code> if <code>feature_node</code> has given <code>type</code>, <code>false</code> otherwise.
</p>
<hr>
<a name="gt_feature_node_score_is_defined"></a>

<code>bool           gt_feature_node_score_is_defined(const GtFeatureNode
                                               *feature_node)</code>
<p>
Return <code>true</code> if the score of <code>feature_node</code> is defined, <code>false</code>
   otherwise.
</p>
<hr>
<a name="gt_feature_node_get_score"></a>

<code>float          gt_feature_node_get_score(const GtFeatureNode *feature_node)</code>
<p>
Return the score of <code>feature_node</code>. The score has to be defined.
   Corresponds to column 6 of regular GFF3 lines.
</p>
<hr>
<a name="gt_feature_node_set_score"></a>

<code>void           gt_feature_node_set_score(GtFeatureNode *feature_node,
                                        float score)</code>
<p>
Set the score of <code>feature_node</code> to <code>score</code>.
</p>
<hr>
<a name="gt_feature_node_unset_score"></a>

<code>void           gt_feature_node_unset_score(GtFeatureNode *feature_node)</code>
<p>
Unset the score of <code>feature_node</code>.
</p>
<hr>
<a name="gt_feature_node_get_strand"></a>

<code>GtStrand       gt_feature_node_get_strand(const GtFeatureNode *feature_node)</code>
<p>
Return the strand of <code>feature_node</code>.
   Corresponds to column 7 of regular GFF3 lines.
</p>
<hr>
<a name="gt_feature_node_set_strand"></a>

<code>void           gt_feature_node_set_strand(GtFeatureNode *feature_node,
                                         GtStrand strand)</code>
<p>
Set the strand of <code>feature_node</code> to <code>strand</code>.
</p>
<hr>
<a name="gt_feature_node_get_phase"></a>

<code>GtPhase        gt_feature_node_get_phase(const GtFeatureNode *feature_node)</code>
<p>
Return the phase of <code>feature_node</code>.
   Corresponds to column 8 of regular GFF3 lines.
</p>
<hr>
<a name="gt_feature_node_set_phase"></a>

<code>void           gt_feature_node_set_phase(GtFeatureNode *feature_node,
                                        GtPhase phase)</code>
<p>
Set the phase of <code>feature_node</code> to <code>phase</code>.
</p>
<hr>
<a name="gt_feature_node_get_attribute"></a>

<code>const char*    gt_feature_node_get_attribute(const GtFeatureNode *feature_node,
                                            const char *name)</code>
<p>
Return the attribute of <code>feature_node</code> with the given <code>name</code>.
   If no such attribute has been added, <code>NULL</code> is returned.
   The attributes are stored in column 9 of regular GFF3 lines.
</p>
<hr>
<a name="gt_feature_node_get_attribute_list"></a>

<code>GtStrArray*    gt_feature_node_get_attribute_list(const GtFeatureNode
                                                 *feature_node)</code>
<p>
Return a string array containing the used attribute names of <code>feature_node</code>.
   The caller is responsible to free the returned <code>GtStrArray*</code>.
</p>
<hr>
<a name="gt_feature_node_add_attribute"></a>

<code>void           gt_feature_node_add_attribute(GtFeatureNode *feature_node,
                                            const char *tag, const char *value)</code>
<p>
Add attribute <code>tag</code>=<code>value</code> to <code>feature_node</code>. <code>tag</code> and <code>value</code> must at
   least have length 1. <code>feature_node</code> must not contain an attribute with the
   given <code>tag</code> already. You should not add Parent and ID attributes, use
   <code>gt_feature_node_add_child()</code> to denote part-of relationships.
</p>
<hr>
<a name="gt_feature_node_set_attribute"></a>

<code>void           gt_feature_node_set_attribute(GtFeatureNode* feature_node,
                                            const char *tag, const char *value)</code>
<p>
Set attribute <code>tag</code> to new <code>value</code> in <code>feature_node</code>, if it exists already.
   Otherwise the attribute <code>tag</code>=<code>value</code> is added to <code>feature_node</code>.
   <code>tag</code> and <code>value</code> must at least have length 1.
   You should not set Parent and ID attributes, use
   <code>gt_feature_node_add_child()</code> to denote part-of relationships.
</p>
<hr>
<a name="GtFeatureNodeIterator"></a>
<h2>Class GtFeatureNodeIterator</h2>
<a name="gt_feature_node_iterator_new"></a>

<code>GtFeatureNodeIterator*  gt_feature_node_iterator_new(const GtFeatureNode
                                                    *feature_node)</code>
<p>
Return a new <code>GtFeatureNodeIterator*</code> which performs a depth-first
   traversal of <code>feature_node</code> (including <code>feature_node</code> itself).
</p>
<hr>
<a name="gt_feature_node_iterator_new_direct"></a>

<code>GtFeatureNodeIterator*  gt_feature_node_iterator_new_direct(const GtFeatureNode
                                                           *feature_node)</code>
<p>
Return a new <code>GtFeatureNodeIterator*</code> which iterates over all direct
   children of <code>feature_node</code> (without <code>feature_node</code> itself).
</p>
<hr>
<a name="gt_feature_node_iterator_next"></a>

<code>GtFeatureNode*          gt_feature_node_iterator_next(GtFeatureNodeIterator
                                                     *feature_node_iterator)</code>
<p>
Return the next <code>GtFeatureNode*</code> in <code>feature_node_iterator</code> or <code>NULL</code> if none
   exists.
</p>
<hr>
<a name="gt_feature_node_iterator_delete"></a>

<code>void                    gt_feature_node_iterator_delete(GtFeatureNodeIterator
                                                       *feature_node_iterator)</code>
<p>
Delete <code>feature_node_iterator</code>.
</p>
<hr>
<a name="GtFile"></a>
<h2>Class GtFile</h2>

<p> This class defines (generic) files in <em>GenomeTools</em>. A generic file is is a
   file which either uncompressed or compressed (with gzip or bzip2).
   A <code>NULL</code>-pointer as generic file implies stdout. </p>

<hr>
<a name="gt_file_new"></a>

<code>GtFile*  gt_file_new(const char *path, const char *mode, GtError *err)</code>
<p>
Create a new GtFile object and open the underlying file handle with given
   <code>mode</code>. Returns NULL and sets <code>err</code> accordingly, if the file <code>path</code> could not
   be opened. The compression mode is determined by the ending of <code>path</code> (gzip
   compression if it ends with '.gz', bzip2 compression if it ends with '.bz2',
   and uncompressed otherwise).
</p>
<hr>
<a name="gt_file_delete"></a>

<code>void     gt_file_delete(GtFile *file)</code>
<p>
Close the underlying file handle and destroy the <code>file</code> object.
</p>
<hr>
<a name="gt_file_xfputs"></a>

<code>void     gt_file_xfputs(const char *cstr, GtFile *file)</code>
<p>
Write <code>\0</code>-terminated string <code>cstr</code> to <code>file</code>. Similar to <code>fputs(3)</code>, but
   terminates on error.
</p>
<hr>
<a name="GtGFF3InStream"></a>
<h2>Class GtGFF3InStream</h2>

<p> Implements the <code>GtNodeStream</code> interface. </p>

<hr>
<a name="gt_gff3_in_stream_new_unsorted"></a>

<code>GtNodeStream*             gt_gff3_in_stream_new_unsorted(int num_of_files,
                                                        const char **filenames)</code>
<p>
Create a <code>GtGFF3InStream*</code> which subsequently reads the <code>num_of_files</code> many
   GFF3 files denoted in <code>filenames</code>. The GFF3 files do not have to be sorted.
   If <code>num_of_files</code> is 0 or a file name is "-", it is read from <code>stdin</code>.
   The memory footprint is O(file size) in the worst-case.
</p>
<hr>
<a name="gt_gff3_in_stream_new_sorted"></a>

<code>GtNodeStream*             gt_gff3_in_stream_new_sorted(const char *filename)</code>
<p>
Create a <code>GtGFF3InStream*</code> which reads the sorted GFF3 file denoted by
   <code>filename</code>. If filename is <code>NULL</code>, it is read from <code>stdin</code>.
   The memory footprint is O(1) on average.
</p>
<hr>
<a name="gt_gff3_in_stream_check_id_attributes"></a>

<code>void                      gt_gff3_in_stream_check_id_attributes(GtGFF3InStream
                                                               *gff3_in_stream)</code>
<p>
Make sure all ID attributes which are parsed by <code>gff3_in_stream</code> are correct.
   Increases the memory footprint to O(file size).
</p>
<hr>
<a name="gt_gff3_in_stream_enable_tidy_mode"></a>

<code>void                      gt_gff3_in_stream_enable_tidy_mode(GtGFF3InStream
                                                            *gff3_in_stream)</code>
<p>
Enable tidy mode for <code>gff3_in_stream</code>. That is, the GFF3 parser tries to tidy
   up features which would normally lead to an error.
</p>
<hr>
<a name="gt_gff3_in_stream_show_progress_bar"></a>

<code>void                      gt_gff3_in_stream_show_progress_bar(GtGFF3InStream
                                                             *gff3_in_stream)</code>
<p>
Show progress bar on <code>stdout</code> to convey the progress of parsing the GFF3
   files underlying <code>gff3_in_stream</code>.
</p>
<hr>
<a name="GtGFF3OutStream"></a>
<h2>Class GtGFF3OutStream</h2>

<p> Implements the <code>GtNodeStream</code> interface. </p>

<hr>
<a name="gt_gff3_out_stream_new"></a>

<code>GtNodeStream*  gt_gff3_out_stream_new(GtNodeStream *in_stream, GtFile *outfp)</code>
<p>
Create a <code>GtGFF3OutStream*</code> which uses <code>in_stream</code> as input.
   It shows the nodes passed through it as GFF3 on <code>outfp</code>.
</p>
<hr>
<a name="gt_gff3_out_stream_set_fasta_width"></a>

<code>void           gt_gff3_out_stream_set_fasta_width(GtGFF3OutStream
                                                 *gff3_out_stream,
                                                 unsigned long fasta_width)</code>
<p>
Set the width with which the FASTA sequences of <code>GtSequenceNode</code>s passed
   through <code>gff3_out_stream</code> are shown to <code>fasta_width</code>.
   Per default, each FASTA entry is shown on a single line.
</p>
<hr>
<a name="gt_gff3_out_stream_retain_id_attributes"></a>

<code>void           gt_gff3_out_stream_retain_id_attributes(GtGFF3OutStream
                                                      *gff3_out_stream)</code>
<p>
If this method is called upon <code>gff3_out_stream</code>, use the original ID
   attributes provided in the input (instead of creating new ones, which
   is the default). Memory consumption for <code>gff3_out_stream</code> is raised from O(1)
   to O(<code>input_size</code>), because bookkeeping of used IDs becomes necessary to
   avoid ID collisions.
</p>
<hr>
<a name="GtGFF3Parser"></a>
<h2>Class GtGFF3Parser</h2>

<p> A <code>GtGFF3Parser</code> can be used to parse GFF3 files and convert them into
   <code>GtGenomeNode</code>s. This is a low-level class and is usually not used directly.
   Normally, a <code>GtGFF3InStream</code> is used to parse GFF3 files. </p>

<hr>
<a name="gt_gff3_parser_new"></a>

<code>GtGFF3Parser*  gt_gff3_parser_new(GtTypeChecker *type_checker)</code>
<p>
Create a new <code>GtGFF3Parser*</code> with optional <code>type_checker</code>. If a
   <code>type_checker</code> was given, the <code>GtGFF3Parser*</code> stores a new reference to it
   internally and uses the <code>type_checker</code> to check types during parsing.
</p>
<hr>
<a name="gt_gff3_parser_check_id_attributes"></a>

<code>void           gt_gff3_parser_check_id_attributes(GtGFF3Parser *gff3_parser)</code>
<p>
Enable ID attribute checking in <code>gff3_parser</code>. Thereby, the memory
   consumption of the <code>gff3_parser</code> becomes proportional to the input file
   size(s).
</p>
<hr>
<a name="gt_gff3_parser_set_offset"></a>

<code>void           gt_gff3_parser_set_offset(GtGFF3Parser *gff3_parser, long offset)</code>
<p>
Transform all features parsed by <code>gff3_parser</code> by the given <code>offset</code>.
</p>
<hr>
<a name="gt_gff3_parser_enable_tidy_mode"></a>

<code>void           gt_gff3_parser_enable_tidy_mode(GtGFF3Parser *gff3_parser)</code>
<p>
Enable the tidy mode in <code>gff3_parser</code>. In tidy mode the <code>gff3_parser</code> parser
   tries to tidy up features which would normally lead to a parse error.
</p>
<hr>
<a name="gt_gff3_parser_parse_genome_nodes"></a>

<code>int            gt_gff3_parser_parse_genome_nodes(GtGFF3Parser *gff3_parser,
                                                int *status_code,
                                                GtQueue *genome_nodes,
                                                GtCstrTable *used_types,
                                                GtStr *filenamestr,
                                                unsigned long long *line_number,
                                                GtFile *fpin,
                                                GtError *err)</code>
<p>
Use <code>gff3_parser</code> to parse genome nodes from file pointer <code>fpin</code>.
   <code>status_code</code> is set to 0 if at least one genome node was created (and stored
   in <code>genome_nodes</code>) and to <code>EOF</code> if no further genome nodes could be parsed
   from <code>fpin</code>. Every encountered (genome feature) type is recorded in the
   C-string table <code>used_types</code>. The parser uses the given <code>filenamestr</code> to
   store the file name of <code>fpin</code> in the created genome nodes or to give the
   correct filename in error messages, if necessary.
   <code>line_number</code> is increased accordingly during parsing and has to be set to 0
   before parsing a new <code>fpin</code>.
   If an error occurs during parsing this method returns -1 and sets <code>err</code>
   accordingly.
</p>
<hr>
<a name="gt_gff3_parser_reset"></a>

<code>void           gt_gff3_parser_reset(GtGFF3Parser *gff3_parser)</code>
<p>
Reset the <code>gff3_parser</code> (necessary if the input file is switched).
</p>
<hr>
<a name="gt_gff3_parser_delete"></a>

<code>void           gt_gff3_parser_delete(GtGFF3Parser *gff3_parser)</code>
<p>
Delete the <code>gff3_parser</code> and free all allocated space.
</p>
<hr>
<a name="GtGTFInStream"></a>
<h2>Class GtGTFInStream</h2>

<p> Implements the <code>GtNodeStream</code> interface. </p>

<hr>
<a name="gt_gtf_in_stream_new"></a>

<code>GtNodeStream*  gt_gtf_in_stream_new(const char *filename)</code>
<p>
Create a <code>GtGTFInStream*</code> which subsequently reads the GTF file with the
   given <code>filename</code>. If <code>filename</code> equals <code>NULL</code>, the GTF data is read from
   <code>stdin</code>.
</p>
<hr>
<a name="GtGenomeNode"></a>
<h2>Class GtGenomeNode</h2>

<p> The <code>GtGenomeNode</code> interface. </p>

<hr>
<a name="gt_genome_node_ref"></a>

<code>GtGenomeNode*  gt_genome_node_ref(GtGenomeNode *genome_node)</code>
<p>
Increase the reference count for <code>genome_node</code> and return it.
   <code>genome_node</code> cannot be <code>NULL</code>.
</p>
<hr>
<a name="gt_genome_node_delete"></a>

<code>void           gt_genome_node_delete(GtGenomeNode *genome_node)</code>
<p>
Decrease the reference count for <code>genome_node</code> or delete it, if this was the
   last reference.
</p>
<hr>
<a name="gt_genome_node_get_seqid"></a>

<code>GtStr*         gt_genome_node_get_seqid(GtGenomeNode *genome_node)</code>
<p>
Return the sequence ID of <code>genome_node</code>.
   Corresponds to column 1 of regular GFF3 lines.
</p>
<hr>
<a name="gt_genome_node_get_range"></a>

<code>GtRange        gt_genome_node_get_range(GtGenomeNode *genome_node)</code>
<p>
Return the genomic range of of <code>genome_node</code>.
   Corresponds to columns 4 and 5 of regular GFF3 lines.
</p>
<hr>
<a name="gt_genome_node_get_start"></a>

<code>unsigned long  gt_genome_node_get_start(GtGenomeNode *genome_node)</code>
<p>
Return the start of <code>genome_node</code>.
   Corresponds to column 4 of regular GFF3 lines.
</p>
<hr>
<a name="gt_genome_node_get_end"></a>

<code>unsigned long  gt_genome_node_get_end(GtGenomeNode *genome_node)</code>
<p>
Return the end of <code>genome_node</code>.
   Corresponds to column 5 of regular GFF3 lines.
</p>
<hr>
<a name="gt_genome_node_get_length"></a>

<code>unsigned long  gt_genome_node_get_length(GtGenomeNode *genome_node)</code>
<p>
Return the length of <code>genome_node</code>.
   Computed from column 4 and 5 of regular GFF3 lines.
</p>
<hr>
<a name="gt_genome_node_get_filename"></a>

<code>const char*    gt_genome_node_get_filename(const GtGenomeNode* genome_node)</code>
<p>
Return the filename the <code>genome_node</code> was read from.
   If the node did not originate from a file, an appropriate string is
   returned.
</p>
<hr>
<a name="gt_genome_node_get_line_number"></a>

<code>unsigned int   gt_genome_node_get_line_number(const GtGenomeNode*)</code>
<p>
Return the line of the source file the <code>genome_node</code> was encountered on
   (if the node was read from a file)
</p>
<hr>
<a name="gt_genome_node_set_range"></a>

<code>void           gt_genome_node_set_range(GtGenomeNode *genome_node,
                                       const GtRange *range)</code>
<p>
Set the genomic range of <code>genome_node</code> to given <code>range</code>.
</p>
<hr>
<a name="gt_genome_node_add_user_data"></a>

<code>void           gt_genome_node_add_user_data(GtGenomeNode *node,
                                           const char *key,
                                           void *data,
                                           GtFree free_func)</code>
<p>
Attaches a pointer to <code>data</code> to the <code>node</code> using a given string as <code>key</code>.
</p>
<hr>
<a name="gt_genome_node_get_user_data"></a>

<code>void*          gt_genome_node_get_user_data(const GtGenomeNode*,
                                           const char *key)</code>
<p>
Returns the pointer attached to the node for a given <code>key</code>.
</p>
<hr>
<a name="gt_genome_node_release_user_data"></a>

<code>void           gt_genome_node_release_user_data(GtGenomeNode*, const char *key)</code>
<p>
Calls the destructor function associated with the user data attached under
   the <code>key</code> on the attached data.
</p>
<hr>
<a name="GtGraphics"></a>
<h2>Class GtGraphics</h2>

<p> The <code>GtGraphics</code> interface acts as a low-level abstraction of a drawing
   surface. It is used as a common drawing object in <code>GtCanvas</code> and
   <code>GtCustomTrack</code> implementations and supports a variety of drawing operations
   for both text and basic primitive shapes. </p>

<hr>
<a name="gt_graphics_draw_text"></a>

<code>void    gt_graphics_draw_text(GtGraphics*, double x, double y, const char*)</code>
<p>
Draws text in black to the right of (<code>x</code>,<code>y</code>). The coordinate <code>y</code> is used as
   a baseline.
</p>
<hr>
<a name="gt_graphics_draw_text_clip"></a>

<code>void    gt_graphics_draw_text_clip(GtGraphics*, double x, double y, const char*)</code>
<p>
Draws text in black to the right of (<code>x</code>,<code>y</code>). The coordinate <code>y</code> is used as
   a baseline. If the text exceeds the margins, it is clipped.
</p>
<hr>
<a name="gt_graphics_draw_text_left"></a>

<code>#define gt_graphics_draw_text_left(g,x,y,t)</code>
<p>
Synonym to <code>gt_graphics_draw_text()</code>
</p>
<hr>
<a name="gt_graphics_draw_text_centered"></a>

<code>void    gt_graphics_draw_text_centered(GtGraphics*, double x, double y,
                                      const char*)</code>
<p>
Draws text in black centered at (<code>x</code>,<code>y</code>). The coordinate <code>y</code> is used as a
   baseline.
</p>
<hr>
<a name="gt_graphics_draw_text_right"></a>

<code>void    gt_graphics_draw_text_right(GtGraphics*, double x, double y,
                                   const char*)</code>
<p>
Draws text in black to the left of (<code>x</code>,<code>y</code>). The coordinate <code>y</code> is used as a
   baseline.
</p>
<hr>
<a name="gt_graphics_draw_colored_text"></a>

<code>void    gt_graphics_draw_colored_text(GtGraphics*, double x, double y,
                                     GtColor, const char*)</code>
<p>
Draws text in a given <code>GtColor</code> to the right of (<code>x</code>,<code>y</code>). The coordinate <code>y</code>
   is used as a baseline.
</p>
<hr>
<a name="gt_graphics_get_text_height"></a>

<code>double  gt_graphics_get_text_height(GtGraphics*)</code>
<p>
Returns the height of a capital letter in pixels/points.
</p>
<hr>
<a name="gt_graphics_set_background_color"></a>

<code>int  gt_graphics_set_background_color(GtGraphics*, GtColor)</code>
<p>
Sets the background color of the <code>GtGraphics</code> to a specific color.
   Note that this may only be supported for bitmap output formats.
</p>
<hr>
<a name="gt_graphics_get_text_width"></a>

<code>double  gt_graphics_get_text_width(GtGraphics*, const char *text)</code>
<p>
Returns the width of the given string in pixels/points.
</p>
<hr>
<a name="gt_graphics_set_font"></a>

<code>void    gt_graphics_set_font(GtGraphics *g, const char *family,
                            FontSlant slant, FontWeight weight, double size)</code>
<p>
Sets basic font family, slant and weight options. Font families are
   implementation-specific, e.g. in Cairo there is no operation to list
   available family names on the system, but the standard CSS2 generic family
   names, ("serif", "sans-serif", "cursive", "fantasy", "monospace"), are
   likely to work as expected.
</p>
<hr>
<a name="gt_graphics_get_image_width"></a>

<code>double  gt_graphics_get_image_width(GtGraphics*)</code>
<p>
Returns the width of the image in pixels/points.
</p>
<hr>
<a name="gt_graphics_get_image_height"></a>

<code>double  gt_graphics_get_image_height(GtGraphics*)</code>
<p>
Returns the height of the image in pixels/points.
</p>
<hr>
<a name="gt_graphics_set_margins"></a>

<code>void    gt_graphics_set_margins(GtGraphics*, double margin_x,
                                  double margin_y)</code>
<p>
Set margins (space to the image boundaries that are clear of elements)
   in the graphics.
   <code>margin_x</code> denotes the Margin to the left and right, in pixels.
   <code>margin_y</code> denotes the Margin to the top and bottom, in pixels.
</p>
<hr>
<a name="gt_graphics_get_xmargins"></a>

<code>double  gt_graphics_get_xmargins(GtGraphics*)</code>
<p>
Returns the horizontal margins in pixels/points.
</p>
<hr>
<a name="gt_graphics_get_ymargins"></a>

<code>double  gt_graphics_get_ymargins(GtGraphics*)</code>
<p>
Returns the vertical margins in pixels/points.
</p>
<hr>
<a name="gt_graphics_draw_horizontal_line"></a>

<code>void    gt_graphics_draw_horizontal_line(GtGraphics *g, double x, double y,
                                        GtColor color, double width,
                                        double stroke_width)</code>
<p>
Draws a horizontal line of length <code>width</code> beginning at the given coordinates
   to the right in the color <code>color</code> with stroke width <code>stroke_width</code>.
</p>
<hr>
<a name="gt_graphics_draw_vertical_line"></a>

<code>void    gt_graphics_draw_vertical_line(GtGraphics *g, double x, double y,
                                      GtColor color, double length,
                                      double stroke_width)</code>
<p>
Draws a vertical line of length <code>length</code> beginning at the given coordinates
   downwards in the color <code>color</code> with stroke width <code>stroke_width</code>.
</p>
<hr>
<a name="gt_graphics_draw_line"></a>

<code>void    gt_graphics_draw_line(GtGraphics *g, double x, double y,
                             double xto, double yto, GtColor color,
                             double stroke_width)</code>
<p>
Draws a line beginning at (<code>x</code>,<code>y</code>) to (<code>xto</code>,<code>yto</code>) in the color <code>color</code>
   with stroke width <code>stroke_width</code>.
</p>
<hr>
<a name="gt_graphics_draw_box"></a>

<code>void    gt_graphics_draw_box(GtGraphics*, double x, double y, double width,
                            double height, GtColor fill_color,
                            ArrowStatus arrow_status, double arrow_width,
                            double stroke_width, GtColor stroke_color,
                            bool dashed)</code>
<p>
Draws a arrow-like box glyph at (<code>x</code>,<code>y</code>) where these are the top left
   coordinates. The box extends <code>width</code> pixels (incl. arrowhead) into the x
   direction and <code>height</code> pixels into the y direction. It will be filled with
   <code>fill_color</code> and stroked with width <code>stroke_width</code> and color <code>stroke_color</code>.
   The width of the arrowhead is given by the <code>arrow_width</code> parameter.
   The <code>arrow_status</code> parameter determines whether an arrowhead will be drawn
   at the left or right end, both ends, or none.
   If <code>dashed</code> is set to true, then the outline will be dashed instead of
   solid.
</p>
<hr>
<a name="gt_graphics_draw_dashes"></a>

<code>void    gt_graphics_draw_dashes(GtGraphics*, double x, double y,
                                  double width, double height,
                                  ArrowStatus arrow_status, double arrow_width,
                                  double stroke_width, GtColor stroke_color)</code>
<p>
Draws a transparent box with a dashed line at the center at (<code>x</code>,<code>y</code>)
   (where these are the top left coordinates). The box extends <code>width</code> pixels
   (incl. arrowhead) into the x direction and <code>height</code> pixels into the y
   direction. It will be stroked with width <code>stroke_width</code> and color
   <code>stroke_color</code>. The width of the arrowhead is given by the <code>arrow_width</code>
   parameter. The <code>arrow_status</code> parameter determines whether an arrowhead will
   be drawn at the left or right end, both ends, or none.
</p>
<hr>
<a name="gt_graphics_draw_caret"></a>

<code>void    gt_graphics_draw_caret(GtGraphics*, double x, double y, double width,
                              double height, ArrowStatus arrow_status,
                              double arrow_width,  double stroke_width,
                              GtColor stroke_color)</code>
<p>
Draws a caret (``hat'') style glyph at (<code>x</code>,<code>y</code>) (where these are the top
   left coordinates). The box extends <code>width</code> pixels (incl. arrowhead) into the
   x direction and <code>height</code> pixels into the y direction. It will be stroked
   with width <code>stroke_width</code> and color <code>stroke_color</code>. The width of the
   arrowhead is given by the <code>arrow_width</code> parameter. The <code>arrow_status</code>
   parameter determines whether an arrowhead will be drawn at the left or right
   end, both ends, or none.
</p>
<hr>
<a name="gt_graphics_draw_rectangle"></a>

<code>void    gt_graphics_draw_rectangle(GtGraphics*, double x, double y,
                                  bool filled, GtColor fill_color,
                                  bool stroked, GtColor stroke_color,
                                  double stroke_width, double width,
                                  double height)</code>
<p>
Draws a rectangle at (<code>x</code>,<code>y</code>) where these are the top left coordinates.
   The rectangle extends <code>width</code> pixels (incl. arrowhead) into the x
   direction and <code>height</code> pixels into the y direction. It will be filled with
   <code>fill_color</code> if <code>filled</code> is set to true and stroked with width <code>stroke_width</code>
   and color <code>stroke_color</code> if <code>stroked</code> is set to true.
</p>
<hr>
<a name="gt_graphics_draw_arrowhead"></a>

<code>void    gt_graphics_draw_arrowhead(GtGraphics*, double x, double y, GtColor,
                                  ArrowStatus arrow_status)</code>
<p>
Draws an arrowhead at (<code>x</code>,<code>y</code>) where these are the top left coordinates.
   The direction ais determined by the <code>arrow_status</code> parameter.
</p>
<hr>
<a name="gt_graphics_draw_curve_data"></a>

<code>void    gt_graphics_draw_curve_data(GtGraphics *g, double x, double y,
                                   GtColor color,
                                   double data[], unsigned long ndata,
                                   GtRange valrange, unsigned long height)</code>
<p>
Draws a curve over the full visible image width (without margins) at
   (<code>x</code>,<code>y</code>) where these are the top left coordinates. As input, the array of
   double values <code>data</code> with <code>ndata</code> data points is used. The <code>valrange</code> gives
   the minimum and maximum value of the displayed data. If a value outside the
   data range is encountered, the drawing will be stopped at this data point.
</p>
<hr>
<a name="gt_graphics_save_to_file"></a>

<code>int     gt_graphics_save_to_file(const GtGraphics*, const char *filename,
                                GtError*)</code>
<p>
Write out the <code>GtGraphics</code> object to the given file with <code>filename</code>.
</p>
<hr>
<a name="gt_graphics_save_to_stream"></a>

<code>void    gt_graphics_save_to_stream(const GtGraphics*, GtStr *stream)</code>
<p>
Write out the <code>GtGraphics</code> object to the given <code>stream</code>.
</p>
<hr>
<a name="gt_graphics_delete"></a>

<code>void    gt_graphics_delete(GtGraphics*)</code>
<p>
Deletes the the <code>GtGraphics</code> object.
</p>
<hr>
<a name="GtHashmap"></a>
<h2>Class GtHashmap</h2>

<p> A hashmap allowing to index any kind of pointer (as a value). As keys,
   strings or any other pointer can be used. </p>

<hr>
<a name="gt_hashmap_new"></a>

<code>GtHashmap*  gt_hashmap_new(GtHashType keyhashtype, GtFree keyfree,
                          GtFree valuefree)</code>
<p>
Creates a new <code>GtHashmap</code> of type <code>keyhashtype</code>. If <code>keyfree</code> and/or
   <code>valuefree</code> are given, they will be used to free the hashmap members
   when the <code>GtHashmap</code> is deleted. <code>keyhashtype</code> defines how to hash the
   keys given when using the <code>GtHashmap</code>.
   GT_HASH_DIRECT uses the key pointer as a basis for the hash function.
   Equal pointers will refer to the same value. If GT_HASH_STRING is used, the
   keys will be  evaluated as strings and keys will be considered equal if the
   strings are identical, regardless of their address in memory
</p>
<hr>
<a name="gt_hashmap_get"></a>

<code>void*       gt_hashmap_get(GtHashmap *hm, const void *key)</code>
<p>
Returns the value stored in <code>hm</code> for <code>key</code> or NULL if no such key exists.
</p>
<hr>
<a name="gt_hashmap_add"></a>

<code>void        gt_hashmap_add(GtHashmap *hm, void *key, void *value)</code>
<p>
Sets the value stored in <code>hm</code> for <code>key</code> to <code>value</code>, overwriting the prior
   value for that key if present.
</p>
<hr>
<a name="gt_hashmap_remove"></a>

<code>void        gt_hashmap_remove(GtHashmap *hm, const void *key)</code>
<p>
Removes the member with key <code>key</code> from <code>hm</code>.
</p>
<hr>
<a name="gt_hashmap_foreach_ordered"></a>

<code>int         gt_hashmap_foreach_ordered(GtHashmap *hm, GtHashmapVisitFunc func,
                                      void *data, GtCompare cmp, GtError*)</code>
<p>
Iterate over <code>hm</code> in order given by compare function <code>cmp</code>.
   For each member, <code>func</code> is called (see interface).
</p>
<hr>
<a name="gt_hashmap_foreach"></a>

<code>int         gt_hashmap_foreach(GtHashmap *hm, GtHashmapVisitFunc func,
                              void *data, GtError*)</code>
<p>
Iterate over <code>hm</code> in arbitrary order given by compare function <code>cmp</code>.
   For each member, <code>func</code> is called (see interface).
</p>
<hr>
<a name="gt_hashmap_foreach_in_key_order"></a>

<code>int         gt_hashmap_foreach_in_key_order(GtHashmap *hm,
                                           GtHashmapVisitFunc func,
                                           void *data, GtError*)</code>
<p>
Iterate over <code>hm</code> in either alphabetical order (if GtHashType was specified
   as GT_HASH_STRING) or numerical order (if GtHashType was specified as
   GT_HASH_DIRECT).
</p>
<hr>
<a name="gt_hashmap_reset"></a>

<code>void        gt_hashmap_reset(GtHashmap *hm)</code>
<p>
Resets <code>hm</code> by unsetting values for all keys, calling the free function if
   necessary.
</p>
<hr>
<a name="gt_hashmap_delete"></a>

<code>void        gt_hashmap_delete(GtHashmap *hm)</code>
<p>
Deletes <code>hm</code>, calling the free function if necessary.
</p>
<hr>
<a name="GtImageInfo"></a>
<h2>Class GtImageInfo</h2>

<p> The <code>GtImageInfo</code> class is a container for 2D coordinate to <code>GtFeatureNode</code>
   mappings which could, for example, be used to associate sections of a
   rendered image with GUI widgets or HTML imagemap areas. This information is
   given in the form of <code>GtRecMap</code> objects. They are created during the
   image rendering process and stored inside a <code>GtImageInfo</code> object for later
   retrieval. Additionally, the rendered width of an image can be obtained via
   a <code>GtImageInfo</code> method. </p>

<hr>
<a name="gt_image_info_new"></a>

<code>GtImageInfo*      gt_image_info_new(void)</code>
<p>
Creates a new <code>GtImageInfo</code> object.
</p>
<hr>
<a name="gt_image_info_get_height"></a>

<code>unsigned int      gt_image_info_get_height(GtImageInfo *image_info)</code>
<p>
Returns the height of the rendered image (in pixels or points).
</p>
<hr>
<a name="gt_image_info_num_of_rec_maps"></a>

<code>unsigned long     gt_image_info_num_of_rec_maps(GtImageInfo *image_info)</code>
<p>
Returns the total number of mappings in <code>image_info</code>.
</p>
<hr>
<a name="gt_image_info_get_rec_map"></a>

<code>const GtRecMap*   gt_image_info_get_rec_map(GtImageInfo *image_info,
                                           unsigned long i)</code>
<p>
Returns the <code>i</code>-th <code>GtRecMap</code> mapping in <code>image_info</code>.
</p>
<hr>
<a name="gt_image_info_delete"></a>

<code>void              gt_image_info_delete(GtImageInfo *image_info)</code>
<p>
Deletes <code>image_info</code> and all the <code>GtRecMap</code> objects created by it.
</p>
<hr>
<a name="GtIntervalTree"></a>
<h2>Class GtIntervalTree</h2>

<p> This is an interval tree data structure, implemented according to
   Cormen et al., Introduction to Algorithms, 2nd edition, MIT Press,
   Cambridge, MA, USA, 2001 </p>

<hr>
<a name="gt_interval_tree_new"></a>

<code>GtIntervalTree*      gt_interval_tree_new(GtFree)</code>
<p>
Creates a new <code>GtIntervalTree</code>. If a <code>GtFree</code> function is given as an
   argument, it is applied on the data pointers in all inserted nodes when the
   <code>GtIntervalTree</code> is deleted.
</p>
<hr>
<a name="gt_interval_tree_size"></a>

<code>unsigned long        gt_interval_tree_size(GtIntervalTree*)</code>
<p>
Returns the number of elements in the <code>GtIntervalTree</code>.
</p>
<hr>
<a name="gt_interval_tree_find_first_overlapping"></a>

<code>GtIntervalTreeNode*  gt_interval_tree_find_first_overlapping(GtIntervalTree*,
                                                            unsigned long start,
                                                            unsigned long end)</code>
<p>
Returns the first node in the <code>GtIntervalTree</code> which overlaps the given
   range (from <code>start</code> to <code>end</code>).
</p>
<hr>
<a name="gt_interval_tree_insert"></a>

<code>void                 gt_interval_tree_insert(GtIntervalTree *tree,
                                            GtIntervalTreeNode *node)</code>
<p>
Inserts node <code>node</code> into <code>tree</code>.
</p>
<hr>
<a name="gt_interval_tree_find_all_overlapping"></a>

<code>void                 gt_interval_tree_find_all_overlapping(GtIntervalTree*,
                                                          unsigned long start,
                                                          unsigned long end,
                                                          GtArray*)</code>
<p>
Collects data pointers of all <code>GtIntervalTreeNode</code>s in the tree which
   overlapp with the query range (from <code>start</code> to <code>end</code>) in a <code>GtArray</code>.
</p>
<hr>
<a name="gt_interval_tree_traverse"></a>

<code>int                  gt_interval_tree_traverse(GtIntervalTree*,
                                              GtIntervalTreeIteratorFunc func,
                                              void *data)</code>
<p>
Traverses the <code>GtIntervalTree</code> in a depth-first fashion, applying <code>func</code> to
   each node encountered. The <code>data</code> pointer can be used to reference arbitrary
   data needed in the <code>GtIntervalTreeIteratorFunc</code>.
</p>
<hr>
<a name="gt_interval_tree_delete"></a>

<code>void                 gt_interval_tree_delete(GtIntervalTree*)</code>
<p>
Deletes a <code>GtIntervalTree</code>. If a <code>GtFree</code> function was set in the tree
   constructor, data pointers specified in the nodes are freed using the given
   <code>GtFree</code> function.
</p>
<hr>
<a name="GtIntervalTreeNode"></a>
<h2>Class GtIntervalTreeNode</h2>
<a name="gt_interval_tree_node_new"></a>

<code>GtIntervalTreeNode*  gt_interval_tree_node_new(void *data,
                                              unsigned long low,
                                              unsigned long high)</code>
<p>
Creates a new <code>GtIntervalTreeNode</code>. Transfers ownership of <code>data</code> to interval
   tree if inserted into a <code>GtIntervalTree</code> in which a
   <code>GtIntervalTreeDataFreeFunc</code> is set.
</p>
<hr>
<a name="gt_interval_tree_node_get_data"></a>

<code>void*                gt_interval_tree_node_get_data(GtIntervalTreeNode* node)</code>
<p>
Returns a pointer to the data associated with node <code>node</code>.
</p>
<hr>
<a name="GtLayout"></a>
<h2>Class GtLayout</h2>

<p> The <code>GtLayout</code> class represents contents (tracks) of a <code>GtDiagram</code> broken up
   into lines such that a given horizontal space allotment given in pixels
   or points is used up most efficiently. This is done using the <code>GtLineBreaker</code>
   and <code>GtTextWidthCalculator</code> classes. As defaults, Cairo-based instances of
   these classes are used but can be specified separately.</p><p>   A <code>GtLayout</code> can be queried for the height of the laid out representation and
   finally be rendered to a <code>GtCanvas</code>. </p>

<hr>
<a name="gt_layout_new"></a>

<code>GtLayout*      gt_layout_new(GtDiagram *diagram, unsigned int width, GtStyle*,
                            GtError*)</code>
<p>
Creates a new <code>GtLayout</code> object for the contents of <code>diagram</code>.
   The layout is done for a target image width of <code>width</code> and using the rules in
   <code>GtStyle</code> object <code>style</code>.
</p>
<hr>
<a name="gt_layout_new_with_twc"></a>

<code>GtLayout*      gt_layout_new_with_twc(GtDiagram*,
                                     unsigned int width,
                                     GtStyle*,
                                     GtTextWidthCalculator*,
                                     GtError*)</code>
<p>
Like <code>gt_layout_new()</code>, but allows use of a different <code>GtTextWidthCalculator</code>
   implementation.
</p>
<hr>
<a name="gt_layout_set_track_ordering_func"></a>

<code>void           gt_layout_set_track_ordering_func(GtLayout *layout,
                                                GtTrackOrderingFunc func,
                                                void *data)</code>
<p>
Sets the <code>GtTrackOrderingFunc</code> comparator function <code>func</code> which defines an
   order on the tracks contained in <code>layout</code>. This determines the order in
   which the tracks are drawn vertically.
   Additional data necessary in the comparator function can be given in <code>data</code>,
   the caller is responsible to free it.
</p>
<hr>
<a name="gt_layout_get_height"></a>

<code>int            gt_layout_get_height(const GtLayout *layout,
                                   unsigned long *result,
                                   GtError *err)</code>
<p>
Calculates the height of <code>layout</code> in pixels. The height value is written to
   the location pointed to by <code>result</code>. If an error occurs during the
   calculation, this function returns -1 and <code>err</code> is set accordingly.
   Returns 0 on success.
</p>
<hr>
<a name="gt_layout_sketch"></a>

<code>int            gt_layout_sketch(GtLayout *layout, GtCanvas *target_canvas,
                               GtError*)</code>
<p>
Renders <code>layout</code> on the <code>target_canvas</code>.
</p>
<hr>
<a name="gt_layout_delete"></a>

<code>void           gt_layout_delete(GtLayout*)</code>
<p>
Destroys a layout.
</p>
<hr>
<a name="GtLogger"></a>
<h2>Class GtLogger</h2>
<a name="gt_logger_new"></a>

<code>GtLogger*  gt_logger_new(bool enabled, const char *prefix, FILE *target)</code>
<p>
Creates a new <code>GtLogger</code>, with logging <code>enabled</code> or not,
   and prefixing all log entries with <code>prefix</code> (e.g. "debug").
   The log output is terminated by a newline. All log output will
   be written to <code>target</code>.
</p>
<hr>
<a name="gt_logger_enable"></a>

<code>void       gt_logger_enable(GtLogger *logger)</code>
<p>
Enable logging on <code>logger</code>.
</p>
<hr>
<a name="gt_logger_disable"></a>

<code>void       gt_logger_disable(GtLogger *logger)</code>
<p>
Disable logging on <code>logger</code>.
</p>
<hr>
<a name="gt_logger_enabled"></a>

<code>bool       gt_logger_enabled(GtLogger *logger)</code>
<p>
Returns true if logging is enabled on <code>logger</code>, false otherwise.
</p>
<hr>
<a name="gt_logger_target"></a>

<code>FILE*      gt_logger_target(GtLogger *logger)</code>
<p>
Returns logging target of <code>logger</code>.
</p>
<hr>
<a name="gt_logger_set_target"></a>

<code>void       gt_logger_set_target(GtLogger *logger, FILE *fp)</code>
<p>
Set logging target of <code>logger</code> to <code>fp</code>.
</p>
<hr>
<a name="gt_logger_log_force"></a>

<code>void       gt_logger_log_force(GtLogger *logger, const char *format, ...)</code>
<p>
Log to target regardless of logging status.
</p>
<hr>
<a name="gt_logger_log"></a>

<code>void       gt_logger_log(GtLogger *logger, const char *format, ...)</code>
<p>
Log to target depending on logging status.
</p>
<hr>
<a name="gt_logger_log_va_force"></a>

<code>void       gt_logger_log_va_force(GtLogger *logger, const char *format, va_list)</code>
<p>
Log to target regardless of logging status, using a va_list argument.
</p>
<hr>
<a name="gt_logger_log_va"></a>

<code>void       gt_logger_log_va(GtLogger *logger, const char *format, va_list)</code>
<p>
Log to target depending on logging status, using a va_list argument.
</p>
<hr>
<a name="GtMergeStream"></a>
<h2>Class GtMergeStream</h2>

<p> Implements the <code>GtNodeStream</code> interface. </p>

<hr>
<a name="gt_merge_stream_new"></a>

<code>GtNodeStream*  gt_merge_stream_new(const GtArray *node_streams)</code>
<p>
Create a <code>GtMergeStream*</code> which merges the given (sorted) <code>node_streams</code> in a
   sorted fashion.
</p>
<hr>
<a name="GtNodeStream"></a>
<h2>Class GtNodeStream</h2>

<p> The <code>GtNodeStream</code> interface. </p>

<hr>
<a name="gt_node_stream_ref"></a>

<code>GtNodeStream*  gt_node_stream_ref(GtNodeStream *node_stream)</code>
<p>
Increase the reference count for <code>node_stream</code> and return it.
</p>
<hr>
<a name="gt_node_stream_next"></a>

<code>int            gt_node_stream_next(GtNodeStream *node_stream,
                                  GtGenomeNode **genome_node,
                                  GtError *err)</code>
<p>
Try to get the the next <code>GtGenomeNode</code> from <code>node_stream</code> and store it in
   <code>genome_node</code> (transfers ownership to <code>genome_node</code>).
   If no error occurs, 0 is returned and <code>genome_node</code> contains either the next
   <code>GtGenomeNode</code> or <code>NULL</code>, if the <code>node_stream</code> is exhausted.
   If an error occurs, -1 is returned and <code>err</code> is set accordingly (the status
   of <code>genome_node</code> is undefined, but no ownership transfer occured).
</p>
<hr>
<a name="gt_node_stream_pull"></a>

<code>int            gt_node_stream_pull(GtNodeStream *node_stream, GtError *err)</code>
<p>
Calls <code>gt_node_stream_next()</code> on <code>node_stream</code> repeatedly until the
   <code>node_stream</code> is exhausted (0 is returned) or an error occurs (-1 is returned
   and <code>err</code> is set). All retrieved <code>GtGenomeNode</code>s are deleted automatically
   with calls to <code>gt_genome_node_delete()</code>.
   This method is basically a convenience method which simplifies calls to
   <code>gt_node_stream_next()</code> in a loop where retrieved <code>GtGenomeNode</code>s are not
   processed any further.
</p>
<hr>
<a name="gt_node_stream_is_sorted"></a>

<code>bool           gt_node_stream_is_sorted(GtNodeStream *node_stream)</code>
<p>
Return <code>true</code> if <code>node_stream</code> is a sorted stream, <code>false</code> otherwise.
</p>
<hr>
<a name="gt_node_stream_delete"></a>

<code>void           gt_node_stream_delete(GtNodeStream *node_stream)</code>
<p>
Decrease the reference count for <code>node_stream</code> or delete it, if this was the
   last reference.
</p>
<hr>
<a name="gt_node_stream_create"></a>

<code>GtNodeStream*       gt_node_stream_create(const GtNodeStreamClass
                                         *node_stream_class,
                                         bool ensure_sorting)</code>
<p>
Create a new object of the given <code>node_stream_class</code>. If <code>ensure_sorting</code> is
   <code>true</code>, it is enforced that all genome node objects pulled from this class
   are sorted. That is, for consecutive nodes <code>a</code> and <code>b</code> obtained from the
   given <code>node_stream_class</code> the return code of <code>gt_genome_node_compare(a, b)</code>
   has to be smaller or equal than 0. If this condition is not met, an assertion
   fails.
</p>
<hr>
<a name="gt_node_stream_cast"></a>

<code>void*               gt_node_stream_cast(const GtNodeStreamClass
                                       *node_stream_class,
                                       GtNodeStream *node_stream)</code>
<p>
Cast <code>node_stream</code> to the given <code>node_stream_class</code>.
   That is, if <code>node_stream</code> is not from the given <code>node_stream_class</code>, an
   assertion will fail.
</p>
<hr>
<a name="GtNodeStreamClass"></a>
<h2>Class GtNodeStreamClass</h2>
<a name="gt_node_stream_class_new"></a>

<code>const
GtNodeStreamClass*  gt_node_stream_class_new(size_t size,
                                            GtNodeStreamFreeFunc free,
                                            GtNodeStreamNextFunc next)</code>
<p>
Create a new node stream class (that is, a class which implements the node
   stream interface). <code>size</code> denotes the size of objects of the new node stream
   class. The optional <code>free</code> method is called once, if an object of the new
   class is deleted. The mandatory <code>next</code> method has to implement the
   <code>gt_node_stream_next()</code> semantic for the new class.
</p>
<hr>
<a name="GtNodeVisitor"></a>
<h2>Class GtNodeVisitor</h2>

<p> The <code>GtNodeVisitor</code> interface, a visitor for <code>GtGenomeNode</code>s. </p>

<hr>
<a name="gt_node_visitor_visit_comment_node"></a>

<code>int    gt_node_visitor_visit_comment_node(GtNodeVisitor *node_visitor,
                                         GtCommentNode *comment_node,
                                         GtError *err)</code>
<p>
Visit <code>comment_node</code> with <code>node_visitor</code>.
</p>
<hr>
<a name="gt_node_visitor_visit_feature_node"></a>

<code>int    gt_node_visitor_visit_feature_node(GtNodeVisitor *node_visitor,
                                         GtFeatureNode *feature_node,
                                         GtError *err)</code>
<p>
Visit <code>feature_node</code> with <code>node_visitor</code>.
</p>
<hr>
<a name="gt_node_visitor_visit_region_node"></a>

<code>int    gt_node_visitor_visit_region_node(GtNodeVisitor *node_visitor,
                                        GtRegionNode *region_node,
                                        GtError *err)</code>
<p>
Visit <code>region_node</code> with <code>node_visitor</code>.
</p>
<hr>
<a name="gt_node_visitor_visit_sequence_node"></a>

<code>int    gt_node_visitor_visit_sequence_node(GtNodeVisitor *node_visitor,
                                          GtSequenceNode *sequence_node,
                                          GtError *err)</code>
<p>
Visit <code>sequence_node</code> with <code>node_visitor</code>.
</p>
<hr>
<a name="gt_node_visitor_delete"></a>

<code>void   gt_node_visitor_delete(GtNodeVisitor *node_visitor)</code>
<p>
Delete <code>node_visitor</code> and free all allocated space.
</p>
<hr>
<a name="GtPhase"></a>
<h2>Class GtPhase</h2>

<p> This enum type defines the possible phases, namely <code>GT_PHASE_ZERO</code>,
   <code>GT_PHASE_ONE</code>, <code>GT_PHASE_TWO</code>, and <code>GT_PHASE_UNDEFINED</code>. </p>

<hr>
<a name="GT_PHASE_CHARS"></a>

<code>#define GT_PHASE_CHARS</code>
<p>
Use this string to map phase enum types to their corresponding character.
</p>
<hr>
<a name="gt_phase_get"></a>

<code>GtPhase  gt_phase_get(char phase_char)</code>
<p>
Map <code>phase_char</code> to the corresponding phase enum type.
   An assertion will fail if <code>phase_char</code> is not a valid one.
</p>
<hr>
<a name="GtQueue"></a>
<h2>Class GtQueue</h2>

<p> <code>GtQueue</code> objects are generic queues which can be used to process objects of
   any type in an First-In-First-Out (FIFO) fashion. </p>

<hr>
<a name="gt_queue_new"></a>

<code>GtQueue*       gt_queue_new(void)</code>
<p>
Return a new <code>GtQueue*</code> object.
</p>
<hr>
<a name="gt_queue_delete"></a>

<code>void           gt_queue_delete(GtQueue *queue)</code>
<p>
Delete <code>queue</code> and free all allocated space. Elements contained in <code>queue</code>
   are not freed!
</p>
<hr>
<a name="gt_queue_add"></a>

<code>void           gt_queue_add(GtQueue *queue, void *elem)</code>
<p>
Add <code>elem</code> to <code>queue</code> (<em>enqueue</em> in computer science lingo).
</p>
<hr>
<a name="gt_queue_get"></a>

<code>void*          gt_queue_get(GtQueue *queue)</code>
<p>
Remove the first element from non-empty <code>queue</code> and return it (<em>dequeue</em> in
   computer science lingo).
</p>
<hr>
<a name="gt_queue_head"></a>

<code>void*          gt_queue_head(GtQueue *queue)</code>
<p>
Return the first element in non-empty <code>queue</code> without removing it.
</p>
<hr>
<a name="gt_queue_remove"></a>

<code>void           gt_queue_remove(GtQueue *queue, void *elem)</code>
<p>
Remove <code>elem</code> from <code>queue</code> (<code>elem</code> has to be in <code>queue</code>).
   Thereby <code>queue</code> is traversed in reverse order, leading to
   O(<code>gt_queue_size(queue)</code>) worst-case running time.
</p>
<hr>
<a name="gt_queue_size"></a>

<code>unsigned long  gt_queue_size(const GtQueue *queue)</code>
<p>
Return the number of elements in <code>queue</code>.
</p>
<hr>
<a name="GtRange"></a>
<h2>Class GtRange</h2>

<p> The <code>GtRange</code> class is used to represent genomic ranges in <em>GenomeTools</em>.
   Thereby, the <code>start</code> must <strong>always</strong> be smaller or equal than the <code>end</code>. </p>

<hr>
<a name="gt_range_compare"></a>

<code>int            gt_range_compare(const GtRange *range_a, const GtRange *range_b)</code>
<p>
Compare <code>range_a</code> and <code>range_b</code>. Returns 0 if <code>range_a</code> equals <code>range_b</code>, -1
   if <code>range_a</code> starts before <code>range_b</code> or (for equal starts) <code>range_a</code> ends
   before <code>range_b</code>, and 1 else.
</p>
<hr>
<a name="gt_range_compare_with_delta"></a>

<code>int            gt_range_compare_with_delta(const GtRange *range_a,
                                          const GtRange *range_b,
                                          unsigned long delta)</code>
<p>
Compare <code>range_a</code> and <code>range_b</code> with given <code>delta</code>.
   Returns 0 if <code>range_a</code> equals <code>range_b</code> modulo <code>delta</code> (i.e., the start and
   end points of <code>range_a</code> and <code>range_b</code> are at most <code>delta</code> bases apart), -1
   if <code>range_a</code> starts before <code>range_b</code> or (for equal starts) <code>range_a</code> ends
   before <code>range_b</code>, and 1 else.
</p>
<hr>
<a name="gt_range_overlap"></a>

<code>bool           gt_range_overlap(const GtRange *range_a, const GtRange *range_b)</code>
<p>
Returns <code>true</code> if <code>range_a</code> and <code>range_b</code> overlap, <code>false</code> otherwise.
</p>
<hr>
<a name="gt_range_overlap_delta"></a>

<code>bool           gt_range_overlap_delta(const GtRange *range_a,
                                     const GtRange *range_b,
                                     unsigned long delta)</code>
<p>
Returns <code>true</code> if <code>range_a</code> and <code>range_b</code> overlap <strong>at least</strong> <code>delta</code> many
   positions, <code>false</code> otherwise.
</p>
<hr>
<a name="gt_range_contains"></a>

<code>bool           gt_range_contains(const GtRange *range_a, const GtRange *range_b)</code>
<p>
Returns <code>true</code> if <code>range_b</code> is contained in <code>range_a</code>, <code>false</code> otherwise.
</p>
<hr>
<a name="gt_range_within"></a>

<code>bool           gt_range_within(const GtRange *range, unsigned long point)</code>
<p>
Returns <code>true</code> if <code>point</code> lies within <code>range</code>, <code>false</code> otherwise.
</p>
<hr>
<a name="gt_range_join"></a>

<code>GtRange        gt_range_join(const GtRange *range_a, const GtRange *range_b)</code>
<p>
Join <code>range_a</code> and <code>range_b</code> and return the result.
</p>
<hr>
<a name="gt_range_offset"></a>

<code>GtRange        gt_range_offset(const GtRange *range, long offset)</code>
<p>
Transform start and end of <code>range</code> by <code>offset</code> and return the result.
</p>
<hr>
<a name="gt_range_length"></a>

<code>unsigned long  gt_range_length(const GtRange *range)</code>
<p>
Returns the length of the given <code>range</code>.
</p>
<hr>
<a name="GtRecMap"></a>
<h2>Class GtRecMap</h2>

<p> A <code>GtRecMap</code> object contains a mapping from a 2D coordinate pair
   which identifies a rectangle in a rendered image to the <code>GtFeatureNode</code> it
  represents. The rectangle is defined by the coordinates of its upper left
  (``northwest'') and lower right (``southeast'') points.</p><p>  <code>GtRecMap</code> objects are created by an <code>GtImageInfo</code> object which is filled
  during the generation of an image by <em>AnnotationSketch</em>. </p>

<hr>
<a name="gt_rec_map_get_northwest_x"></a>

<code>double                   gt_rec_map_get_northwest_x(const GtRecMap*)</code>
<p>
Retrieve <em>x</em> value of the the upper left point of the rectangle.
</p>
<hr>
<a name="gt_rec_map_get_northwest_y"></a>

<code>double                   gt_rec_map_get_northwest_y(const GtRecMap*)</code>
<p>
Retrieve <em>y</em> value of the the upper left point of the rectangle.
</p>
<hr>
<a name="gt_rec_map_get_southeast_x"></a>

<code>double                   gt_rec_map_get_southeast_x(const GtRecMap*)</code>
<p>
Retrieve <em>x</em> value of the the lower right point of the rectangle.
</p>
<hr>
<a name="gt_rec_map_get_southeast_y"></a>

<code>double                   gt_rec_map_get_southeast_y(const GtRecMap*)</code>
<p>
Retrieve <em>y</em> value of the the lower right point of the rectangle.
</p>
<hr>
<a name="gt_rec_map_get_genome_feature"></a>

<code>const GtFeatureNode*     gt_rec_map_get_genome_feature(const GtRecMap*)</code>
<p>
Retrieve <code>GtFeatureNode</code> associated with this rectangle.
</p>
<hr>
<a name="gt_rec_map_has_omitted_children"></a>

<code>bool                     gt_rec_map_has_omitted_children(const GtRecMap*)</code>
<p>
Returns <code>true</code> if the rectangle represents a block root whose elements
   have not been drawn due to size restrictions.
</p>
<hr>
<a name="GtRegionNode"></a>
<h2>Class GtRegionNode</h2>

<p> Implements the <code>GtGenomeNode</code> interface. Region nodes correspond to the
   <code>##sequence-region</code> lines in GFF3 files.</p>

<hr>
<a name="gt_region_node_new"></a>

<code>GtGenomeNode*  gt_region_node_new(GtStr *seqid, unsigned long start,
                                               unsigned long end)</code>
<p>
Create a new <code>GtRegionNode*</code> representing sequence with ID <code>seqid</code> from
   base position <code>start</code> to base position <code>end</code> (1-based).
   <code>start</code> has to be smaller or equal than <code>end</code>.
   The <code>GtRegionNode*</code> stores a new reference to <code>seqid</code>, so make sure you do
   not modify the original <code>seqid</code> afterwards!
</p>
<hr>
<a name="GtSequenceNode"></a>
<h2>Class GtSequenceNode</h2>

<p> Implements the <code>GtGenomeNode</code> interface. Sequence nodes correspond to
   embedded FASTA sequences in GFF3 files. </p>

<hr>
<a name="gt_sequence_node_new"></a>

<code>GtGenomeNode*             gt_sequence_node_new(const char *description,
                                              GtStr *sequence)</code>
<p>
Create a new <code>GtSequenceNode*</code> representing a FASTA entry with the given
   <code>description</code> and <code>sequence</code>. Takes ownership of <code>sequence</code>.
</p>
<hr>
<a name="gt_sequence_node_get_description"></a>

<code>const char*               gt_sequence_node_get_description(const
                                                          GtSequenceNode
                                                          *sequence_node)</code>
<p>
Return the description of <code>sequence_node</code>.
</p>
<hr>
<a name="gt_sequence_node_get_sequence"></a>

<code>const char*               gt_sequence_node_get_sequence(const GtSequenceNode
                                                       *sequence_node)</code>
<p>
Return the sequence of <code>sequence_node</code>.
</p>
<hr>
<a name="gt_sequence_node_get_sequence_length"></a>

<code>unsigned long             gt_sequence_node_get_sequence_length(const
                                                              GtSequenceNode
                                                              *sequence_node)</code>
<p>
Return the sequence length of <code>sequence_node</code>.
</p>
<hr>
<a name="GtSortStream"></a>
<h2>Class GtSortStream</h2>

<p> Implements the <code>GtNodeStream</code> interface. </p>

<hr>
<a name="gt_sort_stream_new"></a>

<code>GtNodeStream*  gt_sort_stream_new(GtNodeStream *in_stream)</code>
<p>
Create a <code>GtSortStream*</code> which sorts the genome nodes it retrieves from
   <code>in_stream</code> and returns them unmodified, but in sorted order.
</p>
<hr>
<a name="GtSplitter"></a>
<h2>Class GtSplitter</h2>

<p> The <code>GtSplitter</code> class defines objects which can split given strings into
   tokens delimited by a given character, allowing for convenient access to
   each token. </p>

<hr>
<a name="gt_splitter_new"></a>

<code>GtSplitter*    gt_splitter_new(void)</code>
<p>
Create a new <code>GtSplitter</code> object.
</p>
<hr>
<a name="gt_splitter_split"></a>

<code>void           gt_splitter_split(GtSplitter*, char *string, unsigned long length,
                                char delimiter)</code>
<p>
Split <code>string</code> of given <code>length</code> into tokens delimited by 'delimiter'.
   Note that <code>string</code> is modified in the splitting process!
</p>
<hr>
<a name="gt_splitter_get_tokens"></a>

<code>char**         gt_splitter_get_tokens(GtSplitter*)</code>
<p>
Get all tokens in an array.
</p>
<hr>
<a name="gt_splitter_get_token"></a>

<code>char*          gt_splitter_get_token(GtSplitter*, unsigned long token_num)</code>
<p>
Get token with number <code>token_num</code>.
</p>
<hr>
<a name="gt_splitter_reset"></a>

<code>void           gt_splitter_reset(GtSplitter*)</code>
<p>
Reset the splitter.
</p>
<hr>
<a name="gt_splitter_size"></a>

<code>unsigned long  gt_splitter_size(GtSplitter*)</code>
<p>
Returns the number of tokens.
</p>
<hr>
<a name="gt_splitter_delete"></a>

<code>void           gt_splitter_delete(GtSplitter*)</code>
<p>
Delete the <code>GtSplitter</code> object.
</p>
<hr>
<a name="GtStr"></a>
<h2>Class GtStr</h2>

<p> Objects of the <code>GtStr</code> class are strings which grow on demand. </p>

<hr>
<a name="gt_str_new"></a>

<code>GtStr*         gt_str_new(void)</code>
<p>
Return an empty <code>GtStr*</code> object.
</p>
<hr>
<a name="gt_str_new_cstr"></a>

<code>GtStr*         gt_str_new_cstr(const char *cstr)</code>
<p>
Return a new <code>GtStr*</code> object whose content is set to <code>cstr</code>.
</p>
<hr>
<a name="gt_str_clone"></a>

<code>GtStr*         gt_str_clone(const GtStr *str)</code>
<p>
Return a clone of <code>str</code>.
</p>
<hr>
<a name="gt_str_ref"></a>

<code>GtStr*         gt_str_ref(GtStr *str)</code>
<p>
Increase the reference count for <code>str</code> and return it.
   If <code>str</code> is <code>NULL</code>, <code>NULL</code> is returned without any side effects.
</p>
<hr>
<a name="gt_str_get"></a>

<code>char*          gt_str_get(const GtStr *str)</code>
<p>
Return the content of <code>str</code>.  Never returns NULL, and the content is always
   <code>\0</code>-terminated
</p>
<hr>
<a name="gt_str_set"></a>

<code>void           gt_str_set(GtStr *str, const char *cstr)</code>
<p>
Set the content of <code>str</code> to <code>cstr</code>.
</p>
<hr>
<a name="gt_str_append_str"></a>

<code>void           gt_str_append_str(GtStr *dest, const GtStr *src)</code>
<p>
Append the string <code>src</code> to <code>dest</code>.
</p>
<hr>
<a name="gt_str_append_cstr"></a>

<code>void           gt_str_append_cstr(GtStr *str, const char *cstr)</code>
<p>
Append the <code>\0</code>-terminated <code>cstr</code> to <code>str</code>.
</p>
<hr>
<a name="gt_str_append_cstr_nt"></a>

<code>void           gt_str_append_cstr_nt(GtStr *str,
                                    const char *cstr, unsigned long length)</code>
<p>
Append the (not necessarily <code>\0</code>-terminated) <code>cstr</code> with given <code>length</code> to
   <code>str</code>.
</p>
<hr>
<a name="gt_str_append_char"></a>

<code>void           gt_str_append_char(GtStr *str, char c)</code>
<p>
Append character <code>c</code> to <code>str</code>.
</p>
<hr>
<a name="gt_str_append_double"></a>

<code>void           gt_str_append_double(GtStr *str, double d, int precision)</code>
<p>
Append double <code>d</code> to <code>str</code> with given <code>precision</code>.
</p>
<hr>
<a name="gt_str_append_ulong"></a>

<code>void           gt_str_append_ulong(GtStr *str, unsigned long ulong)</code>
<p>
Append <code>ulong</code> to <code>str</code>.
</p>
<hr>
<a name="gt_str_append_int"></a>

<code>void           gt_str_append_int(GtStr *str, int intval)</code>
<p>
Append <code>intval</code> to <code>str</code>.
</p>
<hr>
<a name="gt_str_append_uint"></a>

<code>void           gt_str_append_uint(GtStr *str, unsigned int uint)</code>
<p>
Append <code>uint</code> to <code>str</code>.
</p>
<hr>
<a name="gt_str_set_length"></a>

<code>void           gt_str_set_length(GtStr *str, unsigned long length)</code>
<p>
Set length of <code>str</code> to <code>length</code>. <code>length</code> must be smaller or equal than
   <code>gt_str_length(str)</code>.
</p>
<hr>
<a name="gt_str_reset"></a>

<code>void           gt_str_reset(GtStr *str)</code>
<p>
Reset <code>str</code> to length 0.
</p>
<hr>
<a name="gt_str_cmp"></a>

<code>int            gt_str_cmp(const GtStr *str1, const GtStr *str2)</code>
<p>
Compare <code>str1</code> and <code>str2</code> and return the result (similar to <code>strcmp(3)</code>).
</p>
<hr>
<a name="gt_str_length"></a>

<code>unsigned long  gt_str_length(const GtStr *str)</code>
<p>
Return the length of <code>str</code>. If <code>str</code> is <code>NULL</code>, 0 is returned.
</p>
<hr>
<a name="gt_str_delete"></a>

<code>void           gt_str_delete(GtStr *str)</code>
<p>
Decrease the reference count for <code>str</code> or delete it, if this was the last
   reference.
</p>
<hr>
<a name="GtStrArray"></a>
<h2>Class GtStrArray</h2>

<p> <code>GtStrArray*</code> objects are arrays of string which grow on demand. </p>

<hr>
<a name="gt_str_array_new"></a>

<code>GtStrArray*    gt_str_array_new(void)</code>
<p>
Return a new <code>GtStrArray*</code> object.
</p>
<hr>
<a name="gt_str_array_ref"></a>

<code>GtStrArray*    gt_str_array_ref(GtStrArray*)</code>
<p>
Increases the reference to a GtStrArray.
</p>
<hr>
<a name="gt_str_array_add_cstr"></a>

<code>void           gt_str_array_add_cstr(GtStrArray *str_array, const char *cstr)</code>
<p>
Add <code>cstr</code> to <code>str_array</code>. Thereby, an internal copy of <code>cstr</code> is created.
</p>
<hr>
<a name="gt_str_array_add_cstr_nt"></a>

<code>void           gt_str_array_add_cstr_nt(GtStrArray *str_array, const char *cstr,
                                       unsigned long length)</code>
<p>
Add the non <code>\0</code>-terminated <code>cstr</code> with given <code>length</code> to <code>str_array</code>.
   Thereby, an internal copy of <code>cstr</code> is created.
</p>
<hr>
<a name="gt_str_array_add"></a>

<code>void           gt_str_array_add(GtStrArray *str_array, const GtStr *str)</code>
<p>
Add <code>str</code> to <code>str_array</code>. Thereby, an internal copy of <code>str</code> is created.
</p>
<hr>
<a name="gt_str_array_get"></a>

<code>const char*    gt_str_array_get(const GtStrArray *str_array,
                               unsigned long strnum)</code>
<p>
Return pointer to internal string with number <code>strnum</code> of <code>str_array</code>.
   <code>strnum</code> must be smaller than <code>gt_str_array_size(str_array)</code>.
</p>
<hr>
<a name="gt_str_array_set_cstr"></a>

<code>void           gt_str_array_set_cstr(GtStrArray *str_array, unsigned long strnum,
                                    const char *cstr)</code>
<p>
Set the string with number <code>strnum</code> in <code>str_array</code> to <code>cstr</code>.
</p>
<hr>
<a name="gt_str_array_set"></a>

<code>void           gt_str_array_set(GtStrArray *str_array, unsigned long strnum,
                               const GtStr *str)</code>
<p>
Set the string with number <code>strnum</code> in <code>str_array</code> to <code>str</code>.
</p>
<hr>
<a name="gt_str_array_set_size"></a>

<code>void           gt_str_array_set_size(GtStrArray *str_array, unsigned long size)</code>
<p>
Set the size of <code>str_array</code> to <code>size</code>. <code>size</code> must be smaller or equal than
   <code>gt_str_array_size(str_array)</code>.
</p>
<hr>
<a name="gt_str_array_size"></a>

<code>unsigned long  gt_str_array_size(const GtStrArray *str_array)</code>
<p>
Return the number of strings stored in <code>str_array</code>.
</p>
<hr>
<a name="gt_str_array_delete"></a>

<code>void           gt_str_array_delete(GtStrArray *str_array)</code>
<p>
Delete <code>str_array</code>.
</p>
<hr>
<a name="GtStrand"></a>
<h2>Class GtStrand</h2>

<p> This enum type defines the possible strands, namely <code>GT_STRAND_FORWARD</code>,
   <code>GT_STRAND_REVERSE</code>, <code>GT_STRAND_BOTH</code>, and <code>GT_STRAND_UNKNOWN</code>. </p>

<hr>
<a name="GT_STRAND_CHARS"></a>

<code>#define GT_STRAND_CHARS</code>
<p>
Use this string to map strand enum types to their corresponding character.
</p>
<hr>
<a name="gt_strand_get"></a>

<code>GtStrand  gt_strand_get(char strand_char)</code>
<p>
Map <code>strand_char</code> to the corresponding strand enum type.
   Returns <code>GT_NUM_OF_STRAND_TYPES</code> if <code>strand_char</code> is not a valid one.
</p>
<hr>
<a name="GtStyle"></a>
<h2>Class GtStyle</h2>

<p> Objects of the <code>GtStyle</code> class hold <em>AnnotationSketch</em> style information
   like colors, margins, collapsing options, and others. The class provides
   methods to set values of various types. Each value is organised into
   a <em>section</em> and is identified by a <em>key</em>. That is, a <em>section</em>, <em>key</em>
   pair must uniquely identify a value. </p>

<hr>
<a name="gt_style_new"></a>

<code>GtStyle*  gt_style_new(GtError*)</code>
<p>
Creates a new <code>GtStyle</code> object.
</p>
<hr>
<a name="gt_style_ref"></a>

<code>GtStyle*  gt_style_ref(GtStyle*)</code>
<p>
Increments the reference count of the given <code>GtStyle</code>.
</p>
<hr>
<a name="gt_style_unsafe_mode"></a>

<code>void      gt_style_unsafe_mode(GtStyle*)</code>
<p>
Enables unsafe mode (``io'' and ``os'' libraries loaded).
</p>
<hr>
<a name="gt_style_safe_mode"></a>

<code>void      gt_style_safe_mode(GtStyle*)</code>
<p>
Enables safe mode (``io'' and ``os'' libraries not accessible).
</p>
<hr>
<a name="gt_style_is_unsafe"></a>

<code>bool      gt_style_is_unsafe(GtStyle *sty)</code>
<p>
Returns true if <code>sty</code> is in unsafe mode.
</p>
<hr>
<a name="gt_style_clone"></a>

<code>GtStyle*  gt_style_clone(const GtStyle*, GtError*)</code>
<p>
Creates a independent (``deep'') copy of the given <code>GtStyle</code> object.
</p>
<hr>
<a name="gt_style_load_file"></a>

<code>int       gt_style_load_file(GtStyle*, const char *filename, GtError*)</code>
<p>
Loads and executes Lua style file with given <code>filename</code>.
   This file must define a global table called <em>style</em>.
</p>
<hr>
<a name="gt_style_load_str"></a>

<code>int       gt_style_load_str(GtStyle*, GtStr *instr, GtError*)</code>
<p>
Loads and executes Lua style code from the given <code>GtStr</code> <code>instr</code>.
   This code must define a global table called <em>style</em>.
</p>
<hr>
<a name="gt_style_to_str"></a>

<code>int       gt_style_to_str(const GtStyle*, GtStr *outstr, GtError*)</code>
<p>
Generates Lua code which represents the given <code>GtStyle</code> object and
   writes it into the <code>GtStr</code> object <code>outstr</code>.
</p>
<hr>
<a name="gt_style_reload"></a>

<code>void      gt_style_reload(GtStyle*)</code>
<p>
Reloads the Lua style file.
</p>
<hr>
<a name="gt_style_set_color"></a>

<code>void      gt_style_set_color(GtStyle*, const char *section, const char *key,
                            const GtColor *color)</code>
<p>
Sets a color value in the <code>GtStyle</code> for section <code>section</code> and <code>key</code> to a
   certain <code>color</code>.
</p>
<hr>
<a name="gt_style_set_str"></a>

<code>void      gt_style_set_str(GtStyle*, const char *section, const char *key,
                          GtStr *value)</code>
<p>
Set string with key <code>key</code> in <code>section</code> to <code>value</code>.
</p>
<hr>
<a name="gt_style_set_num"></a>

<code>void      gt_style_set_num(GtStyle*, const char *section, const char *key,
                          double number)</code>
<p>
Set numeric value of key <code>key</code> in <code>section</code> to <code>number</code>.
</p>
<hr>
<a name="gt_style_set_bool"></a>

<code>void      gt_style_set_bool(GtStyle*, const char *section, const char *key,
                           bool val)</code>
<p>
Set boolean value of key <code>key</code> in <code>section</code> to <code>val</code>.
</p>
<hr>
<a name="gt_style_unset"></a>

<code>void      gt_style_unset(GtStyle*, const char *section, const char *key)</code>
<p>
Unset value of key <code>key</code> in <code>section</code>.
</p>
<hr>
<a name="gt_style_delete"></a>

<code>void      gt_style_delete(GtStyle *style)</code>
<p>
Deletes this <code>style</code>.
</p>
<hr>
<a name="GtTextWidthCalculator"></a>
<h2>Class GtTextWidthCalculator</h2>

<p> The GtTextWidthCalculator interface answers queries w.r.t.
   text width in a specific drawing backend. This interface is needed to do
   proper line breaking in a <code>GtLayout</code> even if there is no <code>GtCanvas</code> or
   <code>GtGraphics</code> created yet. </p>

<hr>
<a name="gt_text_width_calculator_ref"></a>

<code>GtTextWidthCalculator*  gt_text_width_calculator_ref(GtTextWidthCalculator*)</code>
<p>
Increases the reference count of the <code>GtTextWidthCalculator</code>.
</p>
<hr>
<a name="gt_text_width_calculator_get_text_width"></a>

<code>double                  gt_text_width_calculator_get_text_width(
                                                    GtTextWidthCalculator*,
                                                    const char *text,
                                                    GtError *err)</code>
<p>
Requests the width of <code>text</code> from the <code>GtTextWidthCalculator</code>.
   If the returned value is negative, an error occurred. Otherwise,
   a positive double value is returned.
</p>
<hr>
<a name="gt_text_width_calculator_delete"></a>

<code>void                    gt_text_width_calculator_delete(GtTextWidthCalculator*)</code>
<p>
Deletes a <code>GtTextWidthCalculator</code> instance.
</p>
<hr>
<a name="GtTextWidthCalculatorCairo"></a>
<h2>Class GtTextWidthCalculatorCairo</h2>

<p> Implements the GtTextWidthCalculator interface with Cairo as the drawing
   backend. If text width is to be calculated with regard to a specific
   transformation etc. which is in effect in a <code>cairo_t</code> and which should be
   used later via a <code>GtCanvasCairoContext</code>, create a
   <code>GtTextWidthCalculatorCairo</code> object and pass it to the <code>GtLayout</code> via
   <code>gt_layout_new_with_twc()</code>. </p>

<hr>
<a name="gt_text_width_calculator_cairo_new"></a>

<code>GtTextWidthCalculator*  gt_text_width_calculator_cairo_new(cairo_t*, GtStyle*)</code>
<p>
Creates a new <code>GtTextWidthCalculatorCairo</code> object for the given context
   using the text size options given in the <code>GtStyle</code>. If the <code>GtStyle</code> is NULL,
   the current font settings in the <code>cairo_t</code> will be used for all text
   width calculations.
</p>
<hr>
<a name="GtTimer"></a>
<h2>Class GtTimer</h2>

<p> The <code>GtTimer</code> class encapsulates a timer which can be used for run-time
   measurements. </p>

<hr>
<a name="gt_timer_new"></a>

<code>GtTimer*  gt_timer_new(void)</code>
<p>
Creates a new <code>GtTimer</code> object.
</p>
<hr>
<a name="gt_timer_new_with_progress_description"></a>

<code>GtTimer*  gt_timer_new_with_progress_description(const char* desc)</code>
<p>
Creates a new <code>GtTimer</code> object and stores the first description.
</p>
<hr>
<a name="gt_timer_start"></a>

<code>void      gt_timer_start(GtTimer *t)</code>
<p>
Starts the time measurement on <code>t</code>.
</p>
<hr>
<a name="gt_timer_stop"></a>

<code>void      gt_timer_stop(GtTimer *t)</code>
<p>
Stops the time measurement on <code>t</code>.
</p>
<hr>
<a name="gt_timer_show"></a>

<code>void      gt_timer_show(GtTimer *t, FILE *fp)</code>
<p>
Outputs the current state of <code>t</code> in the format
   "%ld.%06lds real %lds user %lds system" to file
   pointer <code>fp</code> (see <code>gt_timer_show_formatted</code>).
   The timer is then stopped.
</p>
<hr>
<a name="gt_timer_show_formatted"></a>

<code>void      gt_timer_show_formatted(GtTimer *t, const char *fmt, FILE *fp)</code>
<p>
Outputs the current state of <code>t</code> in a user-defined format given by <code>fmt</code>.
   <code>fmt</code> must be a format string for four %ld numbers, which are filled with:
   elapsed seconds, elapsed microseconds, used usertime in seconds,
   system time in seconds. The output is written to <code>fp</code>.
</p>
<hr>
<a name="gt_timer_show_progress"></a>

<code>void      gt_timer_show_progress(GtTimer *t, const char *desc, FILE *fp)</code>
<p>
Outputs the current state of <code>t</code> on <code>fp</code> since the last call of
   <code>gt_timer_show_progress()</code> or the last start of <code>t</code>, along with the current
   description. The timer is not stopped, but updated with <code>desc</code> to be the
   next description.
</p>
<hr>
<a name="gt_timer_show_progress_final"></a>

<code>void      gt_timer_show_progress_final(GtTimer *t, FILE *fp)</code>
<p>
Outputs the overall time measured with <code>t</code> from start to now on <code>fp</code>.
</p>
<hr>
<a name="gt_timer_show_cpu_time_by_progress"></a>

<code>void      gt_timer_show_cpu_time_by_progress(GtTimer *t)</code>
<p>
Show also user and sys time in output of gt_timer_show_progress[_final]
</p>
<hr>
<a name="gt_timer_omit_last_stage"></a>

<code>void      gt_timer_omit_last_stage(GtTimer *t)</code>
<p>
Hide output of last stage time in gt_timer_show_progress_final
</p>
<hr>
<a name="gt_timer_delete"></a>

<code>void      gt_timer_delete(GtTimer *t)</code>
<p>
Deletes <code>t</code>.
</p>
<hr>
<a name="GtTransTable"></a>
<h2>Class GtTransTable</h2>
<a name="gt_trans_table_get_scheme_descriptions"></a>

<code>GtStrArray*    gt_trans_table_get_scheme_descriptions(void)</code>
<p>
Returns a <code>GtStrArray</code> of translation scheme descriptions, each of the
   format "%d: %s" where the number is the translation scheme number (usable in
   <code>gt_translator_set_translation_scheme()</code> and the string is the scheme
   name.
</p>
<hr>
<a name="gt_trans_table_new"></a>

<code>GtTransTable*  gt_trans_table_new(unsigned int scheme, GtError *err)</code>
<p>
Returns a translation table as given by <code>scheme</code> which refers to the numbers
   as reported by <code>gt_translator_get_translation_table_descriptions()</code> or the
   list given at the NCBI web site
   <em>http://www.ncbi.nlm.nih.gov/Taxonomy/Utils/wprintgc.cgi</em>.
   Returns NULL if an error occurred, see <code>err</code> for details.
</p>
<hr>
<a name="gt_trans_table_new_standard"></a>

<code>GtTransTable*  gt_trans_table_new_standard(GtError *err)</code>
<p>
Returns the standard translation table.
</p>
<hr>
<a name="gt_trans_table_description"></a>

<code>const char*    gt_trans_table_description(const GtTransTable *tt)</code>
<p>
Returns the description of <code>tt</code>.
</p>
<hr>
<a name="gt_trans_table_translate_codon"></a>

<code>int            gt_trans_table_translate_codon(const GtTransTable *tt,
                                             char c1, char c2, char c3,
                                             char *amino, GtError *err)</code>
<p>
Writes the translation for the codon <code>c1</code>,<code>c2</code>,<code>c3</code> to the position pointed
   to by <code>amino</code>. The current translation scheme set in <code>translator</code> is used.
   Returns a negative value if an error occurred, see <code>err</code> for details.
   Otherwise, 0 is returned.
</p>
<hr>
<a name="gt_trans_table_delete"></a>

<code>void           gt_trans_table_delete(GtTransTable *tt)</code>
<p>
Deletes <code>tt</code>.
</p>
<hr>
<a name="GtTranslator"></a>
<h2>Class GtTranslator</h2>

<p> The <code>GtTranslator</code> can be used to  produce 3-frame translations of DNA
   sequences via an iterator interface. </p>

<hr>
<a name="gt_translator_new_with_table"></a>

<code>GtTranslator*       gt_translator_new_with_table(GtTransTable *tt,
                                                GtCodonIterator *ci)</code>
<p>
Creates a new <code>GtTranslator</code>, starting its translation at the current
   position of <code>ci</code>. The current reading frame is also taken from the state of
   <code>ci</code>. The translation table <code>tt</code> is used.
</p>
<hr>
<a name="gt_translator_new"></a>

<code>GtTranslator*       gt_translator_new(GtCodonIterator *ci)</code>
<p>
Creates a new <code>GtTranslator</code>, starting its translation at the current
   position of <code>ci</code>. The current reading frame is also taken from the state of
   <code>ci</code>. The standard translation table is used.
</p>
<hr>
<a name="gt_translator_set_codon_iterator"></a>

<code>void                gt_translator_set_codon_iterator(GtTranslator *translator,
                                                    GtCodonIterator *ci)</code>
<p>
Reinitializes <code>translator</code> with the position and frame status as given in
   <code>ci</code>.
</p>
<hr>
<a name="gt_translator_set_translation_table"></a>

<code>void                gt_translator_set_translation_table(GtTranslator *translator,
                                                       GtTransTable *tt)</code>
<p>
Selects the translation scheme in <code>translator</code> to the one identified by
   translation table <code>tt</code>.
</p>
<hr>
<a name="gt_translator_next"></a>

<code>GtTranslatorStatus  gt_translator_next(GtTranslator *translator,
                                      char *translated,
                                      unsigned int *frame,
                                      GtError *err)</code>
<p>
Returns the translation of the next codon. The currently translated
   character is put in <code>translated</code> while the current reading frame is put in
   <code>frame</code>.
   Returns GT_TRANSLATOR_ERROR if an error occurred, see <code>err</code> for details.
   If the end of the sequence region to translate has been reached,
   GT_TRANSLATOR_END is returned.
   Otherwise, GT_TRANSLATOR_OK (equal to 0) is returned.
</p>
<hr>
<a name="gt_translator_find_startcodon"></a>

<code>GtTranslatorStatus  gt_translator_find_startcodon(GtTranslator *translator,
                                                 unsigned long *pos,
                                                 GtError *err)</code>
<p>
Moves the <code>translator</code> to the beginning of the first codon in <code>dnaseq</code> (of
   length <code>dnalen</code>) which is a start codon according to the selected translation
   scheme in <code>translator</code>.
   The offset is written to the location pointed to by <code>pos</code>.
   Returns GT_TRANSLATOR_ERROR if an error occurred, see <code>err</code> for details.
   If the end of the sequence region to scan has been reached without finding a
   start codon, GT_TRANSLATOR_END is returned.
   Otherwise, GT_TRANSLATOR_OK (equal to 0) is returned.
</p>
<hr>
<a name="gt_translator_find_stopcodon"></a>

<code>GtTranslatorStatus  gt_translator_find_stopcodon(GtTranslator *translator,
                                                unsigned long *pos,
                                                GtError *err)</code>
<p>
Moves the <code>translator</code> to the beginning of the first codon in <code>dnaseq</code> (of
   length <code>dnalen</code>) which is a stop codon according to the selected translation
   scheme in <code>translator</code>.
   The offset is written to the location pointed to by <code>pos</code>.
   Returns GT_TRANSLATOR_ERROR if an error occurred, see <code>err</code> for details.
   If the end of the sequence region to scan has been reached without finding a
   stop codon, GT_TRANSLATOR_END is returned.
   Otherwise, GT_TRANSLATOR_OK (equal to 0) is returned.
</p>
<hr>
<a name="gt_translator_find_codon"></a>

<code>GtTranslatorStatus  gt_translator_find_codon(GtTranslator *translator,
                                            GtStrArray *codons,
                                            unsigned long *pos,
                                            GtError *err)</code>
<p>
Moves the <code>translator</code> to the beginning of the first codon in <code>dnaseq</code> (of
   length <code>dnalen</code>) which belongs to the set of codons specified in <code>codons</code>.
   The offset is written to the location pointed to by <code>pos</code>.
   Returns GT_TRANSLATOR_ERROR if an error occurred, see <code>err</code> for details.
   If the end of the sequence region to scan has been reached without finding
   one of the codons, GT_TRANSLATOR_END is returned.
   Otherwise, GT_TRANSLATOR_OK (equal to 0) is returned.
</p>
<hr>
<a name="gt_translator_delete"></a>

<code>void                gt_translator_delete(GtTranslator *translator)</code>
<p>
Deletes <code>translator</code> and frees all associated memory.
</p>
<hr>
<a name="GtTypeChecker"></a>
<h2>Class GtTypeChecker</h2>

<p> The <code>GtTypeChecker</code> interface, allows to check the validity of (genome
   feature) types. </p>

<hr>
<a name="gt_type_checker_ref"></a>

<code>GtTypeChecker*  gt_type_checker_ref(GtTypeChecker *type_checker)</code>
<p>
Increase the reference count for <code>type_checker</code> and return it.
</p>
<hr>
<a name="gt_type_checker_is_valid"></a>

<code>bool            gt_type_checker_is_valid(GtTypeChecker *type_checker,
                                        const char *type)</code>
<p>
Return <code>true</code> if <code>type</code> is a valid type for the given <code>type_checker</code>, <code>false</code>
   otherwise.
</p>
<hr>
<a name="gt_type_checker_delete"></a>

<code>void            gt_type_checker_delete(GtTypeChecker *type_checker)</code>
<p>
Decrease the reference count for <code>type_checker</code> or delete it, if this was the
   last reference.
</p>
<hr>
<a name="GtTypeCheckerOBO"></a>
<h2>Class GtTypeCheckerOBO</h2>

<p> Implements the <code>GtTypeChecker</code> interface with types from an OBO file. </p>

<hr>
<a name="gt_type_checker_obo_new"></a>

<code>GtTypeChecker*  gt_type_checker_obo_new(const char *obo_file_path, GtError *err)</code>
<p>
Create a new <code>GtTypeChecker*</code> for OBO file with given <code>obo_file_path</code>.
   If the OBO file cannot be parsed correctly, <code>NULL</code> is returned and <code>err</code> is
   set correspondingly.
</p>
<hr>
<a name="GtVisitorStream"></a>
<h2>Class GtVisitorStream</h2>

<p> Implements the <code>GtNodeStream</code> interface. </p>

<hr>
<a name="gt_visitor_stream_new"></a>

<code>GtNodeStream*  gt_visitor_stream_new(GtNodeStream *in_stream,
                                    GtNodeVisitor *node_visitor)</code>
<p>
Create a new <code>GtVisitorStream*</code>, takes ownership of <code>node_visitor</code>.
   This stream applies <code>node_visitor</code> to each node which passes through it.
   Can be used to implement all streams with such a functionality.
</p>
<hr>
<a name="Array2dim"></a>
<h2>Module Array2dim</h2>
<a name="gt_array2dim_malloc"></a>

<code>#define gt_array2dim_malloc(ARRAY2DIM, ROWS, COLUMNS)</code>
<p>
Allocates a new 2-dimensional array with dimensions <code>ROWS</code> x <code>COLUMNS</code> and
   assigns a pointer to the newly allocated space to <code>ARRAY2DIM</code>.
   The size of each element is determined automatically from the type of the
   <code>ARRAY2DIM</code> pointer.
</p>
<hr>
<a name="gt_array2dim_calloc"></a>

<code>#define gt_array2dim_calloc(ARRAY2DIM, ROWS, COLUMNS)</code>
<p>
Allocates a new 2-dimensional array with dimensions <code>ROWS</code> x <code>COLUMNS</code> and
   assigns a pointer to the newly allocated space to <code>ARRAY2DIM</code>.
   The allocated space is initialized to be filled with zeroes.
   The size of each element is determined automatically from the type of the
   <code>ARRAY2DIM</code> pointer.
</p>
<hr>
<a name="gt_array2dim_example"></a>

<code>int      gt_array2dim_example(GtError*)</code>
<p>
An example for usage of the <code>Array2dim</code> module.
</p>
<hr>
<a name="gt_array2dim_delete"></a>

<code>#define gt_array2dim_delete(ARRAY2DIM)</code>
<p>
Frees the space allocated for the 2-dimensional array pointed to by
   <code>ARRAY2DIM</code>.
</p>
<hr>
<a name="Assert"></a>
<h2>Module Assert</h2>
<a name="gt_assert"></a>

<code>#define gt_assert(expression)</code>
<p>
The <code>gt_assert()</code> macro tests the given <code>expression</code> and if it is false, the
   calling process is terminated. A diagnostic message is written to <code>stderr</code>
   and the <code>exit(3)</code> function is called (with error code 2 as argument),
   effectively terminating the program.
   If <code>expression</code> is true, the <code>gt_assert()</code> macro does nothing.
</p>
<hr>
<a name="Bsearch"></a>
<h2>Module Bsearch</h2>
<a name="gt_bsearch_data"></a>

<code>void*  gt_bsearch_data(const void *key, const void *base, size_t nmemb,
                      size_t size, GtCompareWithData, void *data)</code>
<p>
Similar interface to <code>bsearch(3)</code>, except that the <code>GtCompareWithData</code>
   function gets an additional <code>data</code> pointer.
</p>
<hr>
<a name="gt_bsearch_all"></a>

<code>void   gt_bsearch_all(GtArray *members, const void *key, const void *base,
                     size_t nmemb, size_t size, GtCompareWithData, void *data)</code>
<p>
Similar interface to <code>gt_bsearch_data()</code>, except that all members which
   compare as equal are stored in the <code>members</code> array. The order in which the
   elements are added is undefined.
</p>
<hr>
<a name="gt_bsearch_all_mark"></a>

<code>void   gt_bsearch_all_mark(GtArray *members, const void *key, const void *base,
                          size_t nmemb, size_t size, GtCompareWithData,
                          void *data, GtBittab*)</code>
<p>
Similar interface to <code>gt_bsearch_all()</code>. Additionally, if a bittab is given
   (which must be of size <code>nmemb</code>), the bits corresponding to the found
   elements are marked (i.e., set).
</p>
<hr>
<a name="Countingsort"></a>
<h2>Module Countingsort</h2>
<a name="gt_countingsort"></a>

<code>void           gt_countingsort(void *out, const void *in, size_t elem_size,
                              unsigned long size, unsigned long max_elemvalue,
                              void *data, GtGetElemvalue get_elemvalue)</code>
<p>
Sort the array of elements pointed to by <code>in</code> containing <code>size</code> many elements
   of size <code>elem_size</code> and store the result in the array <code>out</code> of the same size.
   <code>max_elemvalue</code> denotes the maximum value an element can have.
   <code>get_elemvalue</code> should return an integer value for the given element <code>elem</code>.

   Implements the counting sort algorithm. For a description
   see example page 175 to page 177 of the book:

   T.H. Cormen, C.E. Leiserson and R.L. Rivest. <em>Introduction to Algorithms</em>.
   MIT Press: Cambridge, MA, 1990.
</p>
<hr>
<a name="gt_countingsort_get_max"></a>

<code>unsigned long  gt_countingsort_get_max(const void *in, size_t elem_size,
                                      unsigned long size, void *data,
                                      GtGetElemvalue get_elemvalue)</code>
<p>
If <code>max_elemvalue</code> is not known, it can be determined with this function.
</p>
<hr>
<a name="Cstr"></a>
<h2>Module Cstr</h2>
<a name="gt_cstr_dup"></a>

<code>char*          gt_cstr_dup(const char *cstr)</code>
<p>
Creates a duplicate of string <code>cstr</code> using the GenomeTools memory
   allocator.
</p>
<hr>
<a name="gt_cstr_dup_nt"></a>

<code>char*          gt_cstr_dup_nt(const char *cstr, unsigned long length)</code>
<p>
Creates a duplicate of string <code>cstr</code> using the GenomeTools memory allocator.
   The string needs not be \0-terminated, instead its <code>length</code> must be given.
</p>
<hr>
<a name="gt_cstr_rep"></a>

<code>void           gt_cstr_rep(char *cstr, char f, char t)</code>
<p>
Replace each occurence of <code>f</code> in <code>cstr</code> to <code>t</code>.
</p>
<hr>
<a name="gt_cstr_show"></a>

<code>void           gt_cstr_show(const char *cstr, unsigned long length, FILE *outfp)</code>
<p>
Outputs the first <code>length</code> characters of the string <code>cstr</code> to file pointer
   <code>outfp</code>.
</p>
<hr>
<a name="gt_cstr_length_up_to_char"></a>

<code>unsigned long  gt_cstr_length_up_to_char(const char *cstr, char c)</code>
<p>
Returns the length of the prefix of <code>cstr</code> ending just before <code>c</code>, if <code>cstr</code>
   does not contain <code>c</code>, strlen(cstr) is returned.
</p>
<hr>
<a name="gt_cstr_rtrim"></a>

<code>char*          gt_cstr_rtrim(char* cstr, char remove)</code>
<p>
Removes all occurrences of <code>remove</code> from the right end of <code>cstr</code>.
</p>
<hr>
<a name="Endianess"></a>
<h2>Module Endianess</h2>
<a name="gt_is_little_endian"></a>

<code>bool  gt_is_little_endian(void)</code>
<p>
Returns <code>true</code> if host CPU is little-endian, <code>false</code> otherwise.
</p>
<hr>
<a name="Fileutils"></a>
<h2>Module Fileutils</h2>
<a name="gt_file_exists"></a>

<code>bool            gt_file_exists(const char *path)</code>
<p>
Returns true if the file with the given <code>path</code> exists, false otherwise.
</p>
<hr>
<a name="gt_file_is_newer"></a>

<code>bool            gt_file_is_newer(const char *a, const char *b)</code>
<p>
Returns true if the file with path <code>a</code> has a later modification time than the
   file with path <code>b</code>, false otherwise.
</p>
<hr>
<a name="gt_file_number_of_lines"></a>

<code>unsigned long   gt_file_number_of_lines(const char*)</code>
<p>
Returns the number of lines in a file.
</p>
<hr>
<a name="gt_file_suffix"></a>

<code>const char*     gt_file_suffix(const char *path)</code>
<p>
Returns the suffix of <code>path</code>, if there is any. Returns "" otherwise.
   The suffix is the part after and including the last '.' but after the last
   '/'. Except if <code>path</code> ends with ".gz" or ".bz2", then the suffix is the part
   after and including the second last '.'.
</p>
<hr>
<a name="gt_file_dirname"></a>

<code>void            gt_file_dirname(GtStr *path, const char *file)</code>
<p>
Set <code>path</code> to the dirname of <code>file</code>, if it has one, to "" otherwise.
</p>
<hr>
<a name="gt_file_find_in_path"></a>

<code>int             gt_file_find_in_path(GtStr *path, const char *file, GtError*)</code>
<p>
Find <code>file</code> in $PATH, if it has no dirname; set <code>path</code> to dirname otherwise.
   Sets <code>path</code> to the empty string if <code>file</code> could not be found in $PATH.
</p>
<hr>
<a name="gt_file_find_in_env"></a>

<code>int             gt_file_find_in_env(GtStr *path, const char *file,
                                   const char *env, GtError*)</code>
<p>
Find  <code>file</code> in the ':'-separated directory list specified in environment
   variable $<code>env</code>, if it has no dirname; set <code>path</code> to dirname otherwise.
   Sets <code>path</code> to the empty string if <code>file</code> could not be found in $<code>env</code>.
</p>
<hr>
<a name="gt_file_estimate_size"></a>

<code>off_t           gt_file_estimate_size(const char *file)</code>
<p>
Return the (estimated) size of <code>file</code>. If <code>file</code> is uncompressed, the exact
   size is returned. If <code>file</code> is compressed, an estimation which assumes that
   <code>file</code> contains a DNA sequence is returned.
</p>
<hr>
<a name="gt_files_estimate_total_size"></a>

<code>off_t           gt_files_estimate_total_size(const GtStrArray *filenames)</code>
<p>
Return the (estimated) total size of all files given in <code>filenames</code>.
   Uses <code>gt_file_estimate_size()</code>.
</p>
<hr>
<a name="gt_files_guess_if_protein_sequences"></a>

<code>int             gt_files_guess_if_protein_sequences(const GtStrArray *filenames,
                                                   GtError *err)</code>
<p>
Guesse if the sequences contained in the files given in <code>filenames</code> are
   protein sequences. Returns 1 if the guess is that the files contain protein
   sequences. Returns 0 if the guess is that the files contain DNA sequences.
   Returns -1 if an error occurs while reading the files (<code>err</code> is set
   accordingly).
</p>
<hr>
<a name="FunctionPointer"></a>
<h2>Module FunctionPointer</h2>
<code>int  (*GtCompare)(const void *a, const void *b)</code>
<p>
 Functions of this type return less than 0 if <code>a</code> is <em>smaller</em> than <code>b</code>,
   0 if <code>a</code> is <em>equal</em> to <code>b</code>, and greater 0 if <code>a</code> is <em>larger</em> than <code>b</code>.
   Thereby, the operators <em>smaller</em>, <em>equal</em>, and <em>larger</em> are
   implementation dependent.
   Do not count on these functions to return -1, 0, or 1!  
</p>
<hr>
<code>int  (*GtCompareWithData)(const void*, const void*, void *data)</code>
<p>
 Similar to <code>GtCompare</code>, but with an additional <code>data</code> pointer. 
</p>
<hr>
<code>void (*GtFree)(void*)</code>
<p>
 The generic free function pointer type. 
</p>
<hr>
<a name="Grep"></a>
<h2>Module Grep</h2>
<a name="gt_grep"></a>

<code>int   gt_grep(bool *match, const char *pattern, const char *line, GtError*)</code>
<p>
Sets <code>match</code> to <code>true</code> if <code>pattern</code> matches <code>line</code>, to <code>false</code> otherwise.
</p>
<hr>
<a name="Init"></a>
<h2>Module Init</h2>
<a name="gt_lib_init"></a>

<code>void  gt_lib_init(void)</code>
<p>
Initialize this GenomeTools instance.
   This has to be called before the library is used!
</p>
<hr>
<a name="gt_lib_reg_atexit_func"></a>

<code>void  gt_lib_reg_atexit_func(void)</code>
<p>
Registers exit function which calls <code>gt_lib_clean()</code>.
</p>
<hr>
<a name="gt_lib_clean"></a>

<code>int   gt_lib_clean(void)</code>
<p>
Returns 0 if no memory map, file pointer, or memory has been leaked and a
   value != 0 otherwise.
</p>
<hr>
<a name="Log"></a>
<h2>Module Log</h2>
<a name="gt_log_enable"></a>

<code>void  gt_log_enable(void)</code>
<p>
Enable logging.
</p>
<hr>
<a name="gt_log_enabled"></a>

<code>bool  gt_log_enabled(void)</code>
<p>
Returns true if logging is enabled, false otherwise
</p>
<hr>
<a name="gt_log_log"></a>

<code>void   gt_log_log(const char *format, ...)</code>
<p>
Prints the log message obtained from format and following parameters
   according if logging is enabled. The logging output is prefixed with the
   string "debug: " and finished by a newline.
</p>
<hr>
<a name="gt_log_vlog"></a>

<code>void   gt_log_vlog(const char *format, va_list)</code>
<p>
Prints the log message obtained from format and following parameter according
   to if logging is enabled analog to <code>gt_log_log()</code>. But in contrast to
   <code>gt_log_log()</code> <code>gt_log_vlog()</code> does not accept individual arguments but a single
   va_list argument instead.
</p>
<hr>
<a name="gt_log_fp"></a>

<code>FILE*  gt_log_fp(void)</code>
<p>
Return logging file pointer.
</p>
<hr>
<a name="gt_log_set_fp"></a>

<code>void   gt_log_set_fp(FILE *fp)</code>
<p>
Set logging file pointer to <code>fp</code>.
</p>
<hr>
<a name="MemoryAllocation"></a>
<h2>Module MemoryAllocation</h2>
<a name="gt_malloc"></a>

<code>#define gt_malloc(size)</code>
<p>
Allocate <strong>uninitialized</strong> space for an object whose size is specified by
   <code>size</code> and return it.
   Besides the fact that it never returns <code>NULL</code> analog to <code>malloc(3)</code>.
</p>
<hr>
<a name="gt_calloc"></a>

<code>#define gt_calloc(nmemb, size)</code>
<p>
Allocate contiguous space for an array of <code>nmemb</code> objects, each of whose size
   is <code>size</code>.  The space is initialized to zero.
   Besides the fact that it never returns <code>NULL</code> analog to <code>calloc(3)</code>.
</p>
<hr>
<a name="gt_realloc"></a>

<code>#define gt_realloc(ptr, size)</code>
<p>
Change the size of the object pointed to by <code>ptr</code> to <code>size</code> bytes and return
   a pointer to the (possibly moved) object.
   Besides the fact that it never returns <code>NULL</code> analog to <code>realloc(3)</code>.
</p>
<hr>
<a name="gt_free"></a>

<code>#define gt_free(ptr)</code>
<p>
Free the space pointed to by <code>ptr</code>. If <code>ptr</code> equals <code>NULL</code>, no action occurs.
   Analog to <code>free(3)</code>.
</p>
<hr>
<a name="gt_free_func"></a>

<code>void           gt_free_func(void *ptr)</code>
<p>
Analog to <code>gt_free()</code>, but usable as a function pointer.
</p>
<hr>
<a name="Msort"></a>
<h2>Module Msort</h2>
<a name="gt_msort"></a>

<code>void  gt_msort(void *base, size_t nmemb, size_t size, GtCompare compar)</code>
<p>
Sorts an array of <code>nmemb</code> elements, each of size <code>size</code>, according to compare
   function <code>compar</code>. Uses the merge sort algorithm, the interface equals
   <code>qsort(3)</code>.
</p>
<hr>
<a name="gt_msort_r"></a>

<code>void  gt_msort_r(void *base, size_t nmemb, size_t size, void *comparinfo,
                GtCompareWithData compar)</code>
<p>
Identical to <code>gt_msort()</code> except that the compare function is of
   <code>GtCompareWithData</code> type accepting <code>comparinfo</code> as arbitrary data.
</p>
<hr>
<a name="POSIX"></a>
<h2>Module POSIX</h2>
<a name="gt_basename"></a>

<code>char*  gt_basename(const char *path)</code>
<p>
This module implements the function <code>gt_basename()</code> according to the
  specifications in
  http://www.unix-systems.org/onlinepubs/7908799/xsh/basename.html
  and
  http://www.opengroup.org/onlinepubs/009695399/

  <code>gt_basename()</code> is equivalent to the function basename(3) which
  is available on most unix systems, but in different libraries and
  with slightly different functionality.

  <code>gt_basename()</code> takes the pathname pointed to by <code>path</code> and returns a pointer to
  the final component of the pathname, deleting any trailing '/' characters.

  If <code>path</code> consists entirely of the '/' character,  then <code>gt_basename()</code> returns
  a pointer to the string "/".

  If <code>path</code> is a null pointer or points to an empty string, <code>gt_basename()</code>
  returns a pointer to the string ".".

  See the implementation of <code>gt_basename_unit_test()</code> for additional examples.

  The caller is responsible for freeing the received pointer!
</p>
<hr>
<a name="Parseutils"></a>
<h2>Module Parseutils</h2>
<a name="gt_parse_int"></a>

<code>int  gt_parse_int(int *out, const char *nptr)</code>
<p>
Parse integer from <code>nptr</code> and store result in <code>out</code>.
   Returns 0 upon success and -1 upon failure.
</p>
<hr>
<a name="gt_parse_uint"></a>

<code>int  gt_parse_uint(unsigned int *out, const char *nptr)</code>
<p>
Parse unsigned integer from <code>nptr</code> and store result in <code>out</code>.
   Returns 0 upon success and -1 upon failure.
</p>
<hr>
<a name="gt_parse_long"></a>

<code>int  gt_parse_long(long *out, const char *nptr)</code>
<p>
Parse long from <code>nptr</code> and store result in <code>out</code>.
   Returns 0 upon success and -1 upon failure.
</p>
<hr>
<a name="gt_parse_ulong"></a>

<code>int  gt_parse_ulong(unsigned long *out, const char *nptr)</code>
<p>
Parse unsigned long from <code>nptr</code> and store result in <code>out</code>.
   Returns 0 upon success and -1 upon failure.
</p>
<hr>
<a name="gt_parse_double"></a>

<code>int  gt_parse_double(double *out, const char *nptr)</code>
<p>
Parse double from <code>nptr</code> and store result in <code>out</code>.
   Returns 0 upon success and -1 upon failure.
</p>
<hr>
<a name="gt_parse_range"></a>

<code>int  gt_parse_range(GtRange *rng, const char *start, const char *end,
                   unsigned int line_number, const char *filename, GtError*)</code>
<p>
Parse a range given by <code>start</code> and <code>end</code>, writing the result into <code>rng</code>.
   <code>Enforces that <start</code> <code>= <end</code>. Give <code>filename</code> and <code>line_number</code> for
   error reporting. Returns 0 upon success and -1 upon failure.
</p>
<hr>
<a name="gt_parse_range_tidy"></a>

<code>int  gt_parse_range_tidy(GtRange *rng, const char *start, const char *end,
                        unsigned int line_number, const char *filename,
                        GtError*)</code>
<p>
Like <code>gt_parse_range</code>, but issues a warning if <code>start</code> is larger then <code>end</code>
   and swaps both values.
</p>
<hr>
<a name="Qsort"></a>
<h2>Module Qsort</h2>
<a name="gt_qsort_r"></a>

<code>void  gt_qsort_r(void *a, size_t n, size_t es, void *data,
                GtCompareWithData cmp)</code>
<p>
Like <code>qsort(3)</code>, but allows an additional <code>data</code> pointer passed to the
   <code>GtCompareWithData</code> comparison function <code>cmp</code>.
</p>
<hr>
<a name="Unused"></a>
<h2>Module Unused</h2>
<a name="GT_UNUSED"></a>

<code>#define GT_UNUSED</code>
<p>
Unused function arguments should be annotated with this macro to get rid of
   compiler warnings.
</p>
<hr>
<a name="Version"></a>
<h2>Module Version</h2>
<a name="gt_version_check"></a>

<code>const char*  gt_version_check(unsigned int required_major,
                             unsigned int required_minor,
                             unsigned int required_micro)</code>
<p>
Check that the <em>GenomeTools</em> library in use is compatible with the given
   version. Generally you would pass in the constants <code>GT_MAJOR_VERSION</code>,
   <code>GT_MINOR_VERSION</code>, and <code>GT_MICRO_VERSION</code> as the three arguments to this
   function.

   Returns <code>NULL</code> if the <em>GenomeTools</em> library is compatible with the given
   version, or a string describing the version mismatch, if the library is not
   compatible.
</p>
<hr>
<a name="Warning"></a>
<h2>Module Warning</h2>
<code>void (*GtWarningHandler)(void *data, const char *format, va_list ap)</code>
<p>
 Handler type used to process warnings. 
</p>
<hr>
<a name="gt_warning"></a>

<code>void  gt_warning(const char *format, ...)</code>
<p>
Print a warning according to <code>format</code> and <code>...</code>, if a handler is set.
</p>
<hr>
<a name="gt_warning_disable"></a>

<code>void  gt_warning_disable(void)</code>
<p>
Disable that warnings are shown. That is, subsequent <code>gt_warning()</code> calls
   have no effect.
</p>
<hr>
<a name="gt_warning_set_handler"></a>

<code>void  gt_warning_set_handler(GtWarningHandler warn_handler, void *data)</code>
<p>
Set <code>warn_handler</code> to handle all warnings issued with <code>gt_warning()</code>.
   The <code>data</code> is passed to <code>warning_handler</code> on each invocation.
</p>
<hr>
<a name="gt_warning_default_handler"></a>

<code>void  gt_warning_default_handler(void *data, const char *format, va_list ap)</code>
<p>
The default warning handler which prints on <code>stderr</code>.
   "warning: " is prepended and a newline is appended to the message defined by
   <code>format</code> and <code>ap</code>. Does not use <code>data</code>.
</p>
<hr>
<a name="gt_warning_get_handler"></a>

<code>GtWarningHandler  gt_warning_get_handler(void)</code>
<p>
Return currently used <code>GtWarningHandler</code>.
</p>
<hr>
<a name="gt_warning_get_data"></a>

<code>void*  gt_warning_get_data(void)</code>
<p>
Return currently used <code>data</code> which is passed to the currently used
   <code>GtWarningHandler</code>.
</p>
<hr>
<a name="XANSI"></a>
<h2>Module XANSI</h2>
<a name="gt_xatexit"></a>

<code>void    gt_xatexit(void (*function)</code>
<p>
Similar to <code>atexit(3)</code>, terminates on error.
</p>
<hr>
<a name="gt_xfclose"></a>

<code>void    gt_xfclose(FILE*)</code>
<p>
Similar to <code>fclose(3)</code>, terminates on error.
</p>
<hr>
<a name="gt_xfflush"></a>

<code>void    gt_xfflush(FILE*)</code>
<p>
Similar to <code>fflush(3)</code>, terminates on error.
</p>
<hr>
<a name="gt_xfgetc"></a>

<code>int     gt_xfgetc(FILE*)</code>
<p>
Similar to <code>fgetc(3)</code>, terminates on error.
</p>
<hr>
<a name="gt_xfgets"></a>

<code>char*   gt_xfgets(char *s, int size, FILE *stream)</code>
<p>
Similar to <code>fgets(3)</code>, terminates on error.
</p>
<hr>
<a name="gt_xfgetpos"></a>

<code>void    gt_xfgetpos(FILE*, fpos_t*)</code>
<p>
Similar to <code>fgetpos(3)</code>, terminates on error.
</p>
<hr>
<a name="gt_xfopen"></a>

<code>FILE*   gt_xfopen(const char *path, const char *mode)</code>
<p>
Similar to <code>fopen(3)</code>, terminates on error.
</p>
<hr>
<a name="gt_xfputc"></a>

<code>void    gt_xfputc(int, FILE*)</code>
<p>
Similar to <code>fputc(3)</code>, terminates on error.
</p>
<hr>
<a name="gt_xfputs"></a>

<code>void    gt_xfputs(const char*, FILE*)</code>
<p>
Similar to <code>fputs(3)</code>, terminates on error.
</p>
<hr>
<a name="gt_xfread"></a>

<code>size_t  gt_xfread(void *ptr, size_t size, size_t nmemb, FILE*)</code>
<p>
Similar to <code>fread(3)</code>, terminates on error.
</p>
<hr>
<a name="gt_xfseek"></a>

<code>void    gt_xfseek(FILE*, long offset, int whence)</code>
<p>
Similar to <code>fseek(3)</code>, terminates on error.
</p>
<hr>
<a name="gt_xfsetpos"></a>

<code>void    gt_xfsetpos(FILE*, const fpos_t*)</code>
<p>
Similar to <code>fsetpos(3)</code>, terminates on error.
</p>
<hr>
<a name="gt_xfwrite"></a>

<code>void    gt_xfwrite(const void *ptr, size_t size, size_t nmemb, FILE*)</code>
<p>
Similar to <code>fwrite(3)</code>, terminates on error.
</p>
<hr>
<a name="gt_xputchar"></a>

<code>void    gt_xputchar(int)</code>
<p>
Similar to <code>putchar(3)</code>, terminates on error.
</p>
<hr>
<a name="gt_xputs"></a>

<code>void    gt_xputs(const char*)</code>
<p>
Similar to <code>puts(3)</code>, terminates on error.
</p>
<hr>
<a name="gt_xremove"></a>

<code>void    gt_xremove(const char*)</code>
<p>
Similar to <code>remove(3)</code>, terminates on error.
</p>
<hr>
<a name="gt_xungetc"></a>

<code>void    gt_xungetc(int, FILE*)</code>
<p>
Similar to <code>ungetc(3)</code>, terminates on error.
</p>
<hr>
<a name="gt_xvfprintf"></a>

<code>void    gt_xvfprintf(FILE *stream, const char *format, va_list ap)</code>
<p>
Similar to <code>vfprintf(3)</code>, terminates on error.
</p>
<hr>
<a name="gt_xvsnprintf"></a>

<code>int     gt_xvsnprintf(char *str, size_t size, const char *format, va_list ap)</code>
<p>
Similar to <code>vsnprintf(3)</code>, terminates on error.
</p>
<hr>
<a name="Index"></a>
<h2>Index</h2>

  <a href="#GT_PHASE_CHARS"><code>GT_PHASE_CHARS</code></a><br>

  <a href="#GT_STRAND_CHARS"><code>GT_STRAND_CHARS</code></a><br>

  <a href="#GT_UNUSED"><code>GT_UNUSED</code></a><br>

  <a href="#gt_alphabet_add_mapping"><code>gt_alphabet_add_mapping</code></a><br>

  <a href="#gt_alphabet_add_wildcard"><code>gt_alphabet_add_wildcard</code></a><br>

  <a href="#gt_alphabet_bits_per_symbol"><code>gt_alphabet_bits_per_symbol</code></a><br>

  <a href="#gt_alphabet_characters"><code>gt_alphabet_characters</code></a><br>

  <a href="#gt_alphabet_clone"><code>gt_alphabet_clone</code></a><br>

  <a href="#gt_alphabet_decode"><code>gt_alphabet_decode</code></a><br>

  <a href="#gt_alphabet_decode_seq_to_cstr"><code>gt_alphabet_decode_seq_to_cstr</code></a><br>

  <a href="#gt_alphabet_decode_seq_to_fp"><code>gt_alphabet_decode_seq_to_fp</code></a><br>

  <a href="#gt_alphabet_decode_seq_to_str"><code>gt_alphabet_decode_seq_to_str</code></a><br>

  <a href="#gt_alphabet_delete"><code>gt_alphabet_delete</code></a><br>

  <a href="#gt_alphabet_echo_pretty_symbol"><code>gt_alphabet_echo_pretty_symbol</code></a><br>

  <a href="#gt_alphabet_encode"><code>gt_alphabet_encode</code></a><br>

  <a href="#gt_alphabet_encode_seq"><code>gt_alphabet_encode_seq</code></a><br>

  <a href="#gt_alphabet_guess"><code>gt_alphabet_guess</code></a><br>

  <a href="#gt_alphabet_is_dna"><code>gt_alphabet_is_dna</code></a><br>

  <a href="#gt_alphabet_is_protein"><code>gt_alphabet_is_protein</code></a><br>

  <a href="#gt_alphabet_new"><code>gt_alphabet_new</code></a><br>

  <a href="#gt_alphabet_new_dna"><code>gt_alphabet_new_dna</code></a><br>

  <a href="#gt_alphabet_new_empty"><code>gt_alphabet_new_empty</code></a><br>

  <a href="#gt_alphabet_new_from_file"><code>gt_alphabet_new_from_file</code></a><br>

  <a href="#gt_alphabet_new_protein"><code>gt_alphabet_new_protein</code></a><br>

  <a href="#gt_alphabet_num_of_chars"><code>gt_alphabet_num_of_chars</code></a><br>

  <a href="#gt_alphabet_output"><code>gt_alphabet_output</code></a><br>

  <a href="#gt_alphabet_pretty_symbol"><code>gt_alphabet_pretty_symbol</code></a><br>

  <a href="#gt_alphabet_ref"><code>gt_alphabet_ref</code></a><br>

  <a href="#gt_alphabet_size"><code>gt_alphabet_size</code></a><br>

  <a href="#gt_alphabet_symbolmap"><code>gt_alphabet_symbolmap</code></a><br>

  <a href="#gt_alphabet_to_file"><code>gt_alphabet_to_file</code></a><br>

  <a href="#gt_alphabet_valid_input"><code>gt_alphabet_valid_input</code></a><br>

  <a href="#gt_alphabet_wildcard_show"><code>gt_alphabet_wildcard_show</code></a><br>

  <a href="#gt_array2dim_calloc"><code>gt_array2dim_calloc</code></a><br>

  <a href="#gt_array2dim_delete"><code>gt_array2dim_delete</code></a><br>

  <a href="#gt_array2dim_example"><code>gt_array2dim_example</code></a><br>

  <a href="#gt_array2dim_malloc"><code>gt_array2dim_malloc</code></a><br>

  <a href="#gt_array_add"><code>gt_array_add</code></a><br>

  <a href="#gt_array_add_array"><code>gt_array_add_array</code></a><br>

  <a href="#gt_array_add_elem"><code>gt_array_add_elem</code></a><br>

  <a href="#gt_array_clone"><code>gt_array_clone</code></a><br>

  <a href="#gt_array_cmp"><code>gt_array_cmp</code></a><br>

  <a href="#gt_array_delete"><code>gt_array_delete</code></a><br>

  <a href="#gt_array_elem_size"><code>gt_array_elem_size</code></a><br>

  <a href="#gt_array_get"><code>gt_array_get</code></a><br>

  <a href="#gt_array_get_first"><code>gt_array_get_first</code></a><br>

  <a href="#gt_array_get_last"><code>gt_array_get_last</code></a><br>

  <a href="#gt_array_get_space"><code>gt_array_get_space</code></a><br>

  <a href="#gt_array_new"><code>gt_array_new</code></a><br>

  <a href="#gt_array_pop"><code>gt_array_pop</code></a><br>

  <a href="#gt_array_ref"><code>gt_array_ref</code></a><br>

  <a href="#gt_array_rem"><code>gt_array_rem</code></a><br>

  <a href="#gt_array_rem_span"><code>gt_array_rem_span</code></a><br>

  <a href="#gt_array_reset"><code>gt_array_reset</code></a><br>

  <a href="#gt_array_reverse"><code>gt_array_reverse</code></a><br>

  <a href="#gt_array_set_size"><code>gt_array_set_size</code></a><br>

  <a href="#gt_array_size"><code>gt_array_size</code></a><br>

  <a href="#gt_array_sort"><code>gt_array_sort</code></a><br>

  <a href="#gt_array_sort_stable"><code>gt_array_sort_stable</code></a><br>

  <a href="#gt_array_sort_stable_with_data"><code>gt_array_sort_stable_with_data</code></a><br>

  <a href="#gt_array_sort_with_data"><code>gt_array_sort_with_data</code></a><br>

  <a href="#gt_assert"><code>gt_assert</code></a><br>

  <a href="#gt_basename"><code>gt_basename</code></a><br>

  <a href="#gt_bed_in_stream_new"><code>gt_bed_in_stream_new</code></a><br>

  <a href="#gt_bed_in_stream_set_block_type"><code>gt_bed_in_stream_set_block_type</code></a><br>

  <a href="#gt_bed_in_stream_set_feature_type"><code>gt_bed_in_stream_set_feature_type</code></a><br>

  <a href="#gt_bed_in_stream_set_thick_feature_type"><code>gt_bed_in_stream_set_thick_feature_type</code></a><br>

  <a href="#gt_bittab_and"><code>gt_bittab_and</code></a><br>

  <a href="#gt_bittab_and_equal"><code>gt_bittab_and_equal</code></a><br>

  <a href="#gt_bittab_bit_is_set"><code>gt_bittab_bit_is_set</code></a><br>

  <a href="#gt_bittab_cmp"><code>gt_bittab_cmp</code></a><br>

  <a href="#gt_bittab_complement"><code>gt_bittab_complement</code></a><br>

  <a href="#gt_bittab_count_set_bits"><code>gt_bittab_count_set_bits</code></a><br>

  <a href="#gt_bittab_delete"><code>gt_bittab_delete</code></a><br>

  <a href="#gt_bittab_equal"><code>gt_bittab_equal</code></a><br>

  <a href="#gt_bittab_get_all_bitnums"><code>gt_bittab_get_all_bitnums</code></a><br>

  <a href="#gt_bittab_get_first_bitnum"><code>gt_bittab_get_first_bitnum</code></a><br>

  <a href="#gt_bittab_get_last_bitnum"><code>gt_bittab_get_last_bitnum</code></a><br>

  <a href="#gt_bittab_get_next_bitnum"><code>gt_bittab_get_next_bitnum</code></a><br>

  <a href="#gt_bittab_nand"><code>gt_bittab_nand</code></a><br>

  <a href="#gt_bittab_new"><code>gt_bittab_new</code></a><br>

  <a href="#gt_bittab_or"><code>gt_bittab_or</code></a><br>

  <a href="#gt_bittab_or_equal"><code>gt_bittab_or_equal</code></a><br>

  <a href="#gt_bittab_set_bit"><code>gt_bittab_set_bit</code></a><br>

  <a href="#gt_bittab_shift_left_equal"><code>gt_bittab_shift_left_equal</code></a><br>

  <a href="#gt_bittab_shift_right_equal"><code>gt_bittab_shift_right_equal</code></a><br>

  <a href="#gt_bittab_show"><code>gt_bittab_show</code></a><br>

  <a href="#gt_bittab_size"><code>gt_bittab_size</code></a><br>

  <a href="#gt_bittab_unset"><code>gt_bittab_unset</code></a><br>

  <a href="#gt_bittab_unset_bit"><code>gt_bittab_unset_bit</code></a><br>

  <a href="#gt_block_caption_is_visible"><code>gt_block_caption_is_visible</code></a><br>

  <a href="#gt_block_clone"><code>gt_block_clone</code></a><br>

  <a href="#gt_block_delete"><code>gt_block_delete</code></a><br>

  <a href="#gt_block_get_caption"><code>gt_block_get_caption</code></a><br>

  <a href="#gt_block_get_range"><code>gt_block_get_range</code></a><br>

  <a href="#gt_block_get_range_ptr"><code>gt_block_get_range_ptr</code></a><br>

  <a href="#gt_block_get_size"><code>gt_block_get_size</code></a><br>

  <a href="#gt_block_get_strand"><code>gt_block_get_strand</code></a><br>

  <a href="#gt_block_get_top_level_feature"><code>gt_block_get_top_level_feature</code></a><br>

  <a href="#gt_block_has_only_one_fullsize_element"><code>gt_block_has_only_one_fullsize_element</code></a><br>

  <a href="#gt_block_merge"><code>gt_block_merge</code></a><br>

  <a href="#gt_block_new"><code>gt_block_new</code></a><br>

  <a href="#gt_block_new_from_node"><code>gt_block_new_from_node</code></a><br>

  <a href="#gt_block_ref"><code>gt_block_ref</code></a><br>

  <a href="#gt_block_set_caption"><code>gt_block_set_caption</code></a><br>

  <a href="#gt_block_set_caption_visibility"><code>gt_block_set_caption_visibility</code></a><br>

  <a href="#gt_block_set_strand"><code>gt_block_set_strand</code></a><br>

  <a href="#gt_bsearch_all"><code>gt_bsearch_all</code></a><br>

  <a href="#gt_bsearch_all_mark"><code>gt_bsearch_all_mark</code></a><br>

  <a href="#gt_bsearch_data"><code>gt_bsearch_data</code></a><br>

  <a href="#gt_calloc"><code>gt_calloc</code></a><br>

  <a href="#gt_canvas_cairo_context_new"><code>gt_canvas_cairo_context_new</code></a><br>

  <a href="#gt_canvas_cairo_file_new"><code>gt_canvas_cairo_file_new</code></a><br>

  <a href="#gt_canvas_cairo_file_to_file"><code>gt_canvas_cairo_file_to_file</code></a><br>

  <a href="#gt_canvas_cairo_file_to_stream"><code>gt_canvas_cairo_file_to_stream</code></a><br>

  <a href="#gt_canvas_delete"><code>gt_canvas_delete</code></a><br>

  <a href="#gt_canvas_get_height"><code>gt_canvas_get_height</code></a><br>

  <a href="#gt_codon_iterator_current_position"><code>gt_codon_iterator_current_position</code></a><br>

  <a href="#gt_codon_iterator_delete"><code>gt_codon_iterator_delete</code></a><br>

  <a href="#gt_codon_iterator_length"><code>gt_codon_iterator_length</code></a><br>

  <a href="#gt_codon_iterator_next"><code>gt_codon_iterator_next</code></a><br>

  <a href="#gt_codon_iterator_rewind"><code>gt_codon_iterator_rewind</code></a><br>

  <a href="#gt_color_delete"><code>gt_color_delete</code></a><br>

  <a href="#gt_color_equals"><code>gt_color_equals</code></a><br>

  <a href="#gt_color_new"><code>gt_color_new</code></a><br>

  <a href="#gt_color_set"><code>gt_color_set</code></a><br>

  <a href="#gt_comment_node_get_comment"><code>gt_comment_node_get_comment</code></a><br>

  <a href="#gt_comment_node_new"><code>gt_comment_node_new</code></a><br>

  <a href="#gt_countingsort"><code>gt_countingsort</code></a><br>

  <a href="#gt_countingsort_get_max"><code>gt_countingsort_get_max</code></a><br>

  <a href="#gt_cstr_dup"><code>gt_cstr_dup</code></a><br>

  <a href="#gt_cstr_dup_nt"><code>gt_cstr_dup_nt</code></a><br>

  <a href="#gt_cstr_length_up_to_char"><code>gt_cstr_length_up_to_char</code></a><br>

  <a href="#gt_cstr_rep"><code>gt_cstr_rep</code></a><br>

  <a href="#gt_cstr_rtrim"><code>gt_cstr_rtrim</code></a><br>

  <a href="#gt_cstr_show"><code>gt_cstr_show</code></a><br>

  <a href="#gt_cstr_table_add"><code>gt_cstr_table_add</code></a><br>

  <a href="#gt_cstr_table_delete"><code>gt_cstr_table_delete</code></a><br>

  <a href="#gt_cstr_table_get"><code>gt_cstr_table_get</code></a><br>

  <a href="#gt_cstr_table_get_all"><code>gt_cstr_table_get_all</code></a><br>

  <a href="#gt_cstr_table_new"><code>gt_cstr_table_new</code></a><br>

  <a href="#gt_custom_track_delete"><code>gt_custom_track_delete</code></a><br>

  <a href="#gt_custom_track_gc_content_new"><code>gt_custom_track_gc_content_new</code></a><br>

  <a href="#gt_custom_track_ref"><code>gt_custom_track_ref</code></a><br>

  <a href="#gt_custom_track_script_wrapper_new"><code>gt_custom_track_script_wrapper_new</code></a><br>

  <a href="#gt_diagram_add_custom_track"><code>gt_diagram_add_custom_track</code></a><br>

  <a href="#gt_diagram_delete"><code>gt_diagram_delete</code></a><br>

  <a href="#gt_diagram_get_range"><code>gt_diagram_get_range</code></a><br>

  <a href="#gt_diagram_new"><code>gt_diagram_new</code></a><br>

  <a href="#gt_diagram_new_from_array"><code>gt_diagram_new_from_array</code></a><br>

  <a href="#gt_diagram_reset_track_selector_func"><code>gt_diagram_reset_track_selector_func</code></a><br>

  <a href="#gt_diagram_set_track_selector_func"><code>gt_diagram_set_track_selector_func</code></a><br>

  <a href="#gt_dlist_add"><code>gt_dlist_add</code></a><br>

  <a href="#gt_dlist_delete"><code>gt_dlist_delete</code></a><br>

  <a href="#gt_dlist_example"><code>gt_dlist_example</code></a><br>

  <a href="#gt_dlist_find"><code>gt_dlist_find</code></a><br>

  <a href="#gt_dlist_first"><code>gt_dlist_first</code></a><br>

  <a href="#gt_dlist_last"><code>gt_dlist_last</code></a><br>

  <a href="#gt_dlist_new"><code>gt_dlist_new</code></a><br>

  <a href="#gt_dlist_remove"><code>gt_dlist_remove</code></a><br>

  <a href="#gt_dlist_size"><code>gt_dlist_size</code></a><br>

  <a href="#gt_dlistelem_get_data"><code>gt_dlistelem_get_data</code></a><br>

  <a href="#gt_dlistelem_next"><code>gt_dlistelem_next</code></a><br>

  <a href="#gt_dlistelem_previous"><code>gt_dlistelem_previous</code></a><br>

  <a href="#gt_encseq_alphabet"><code>gt_encseq_alphabet</code></a><br>

  <a href="#gt_encseq_builder_add_cstr"><code>gt_encseq_builder_add_cstr</code></a><br>

  <a href="#gt_encseq_builder_add_encoded"><code>gt_encseq_builder_add_encoded</code></a><br>

  <a href="#gt_encseq_builder_add_encoded_own"><code>gt_encseq_builder_add_encoded_own</code></a><br>

  <a href="#gt_encseq_builder_add_str"><code>gt_encseq_builder_add_str</code></a><br>

  <a href="#gt_encseq_builder_build"><code>gt_encseq_builder_build</code></a><br>

  <a href="#gt_encseq_builder_create_des_tab"><code>gt_encseq_builder_create_des_tab</code></a><br>

  <a href="#gt_encseq_builder_create_esq_tab"><code>gt_encseq_builder_create_esq_tab</code></a><br>

  <a href="#gt_encseq_builder_create_sds_tab"><code>gt_encseq_builder_create_sds_tab</code></a><br>

  <a href="#gt_encseq_builder_create_ssp_tab"><code>gt_encseq_builder_create_ssp_tab</code></a><br>

  <a href="#gt_encseq_builder_delete"><code>gt_encseq_builder_delete</code></a><br>

  <a href="#gt_encseq_builder_disable_description_support"><code>gt_encseq_builder_disable_description_support</code></a><br>

  <a href="#gt_encseq_builder_disable_multiseq_support"><code>gt_encseq_builder_disable_multiseq_support</code></a><br>

  <a href="#gt_encseq_builder_do_not_create_des_tab"><code>gt_encseq_builder_do_not_create_des_tab</code></a><br>

  <a href="#gt_encseq_builder_do_not_create_esq_tab"><code>gt_encseq_builder_do_not_create_esq_tab</code></a><br>

  <a href="#gt_encseq_builder_do_not_create_sds_tab"><code>gt_encseq_builder_do_not_create_sds_tab</code></a><br>

  <a href="#gt_encseq_builder_do_not_create_ssp_tab"><code>gt_encseq_builder_do_not_create_ssp_tab</code></a><br>

  <a href="#gt_encseq_builder_enable_description_support"><code>gt_encseq_builder_enable_description_support</code></a><br>

  <a href="#gt_encseq_builder_enable_multiseq_support"><code>gt_encseq_builder_enable_multiseq_support</code></a><br>

  <a href="#gt_encseq_builder_new"><code>gt_encseq_builder_new</code></a><br>

  <a href="#gt_encseq_builder_reset"><code>gt_encseq_builder_reset</code></a><br>

  <a href="#gt_encseq_builder_set_logger"><code>gt_encseq_builder_set_logger</code></a><br>

  <a href="#gt_encseq_create_reader_with_readmode"><code>gt_encseq_create_reader_with_readmode</code></a><br>

  <a href="#gt_encseq_delete"><code>gt_encseq_delete</code></a><br>

  <a href="#gt_encseq_description"><code>gt_encseq_description</code></a><br>

  <a href="#gt_encseq_effective_filelength"><code>gt_encseq_effective_filelength</code></a><br>

  <a href="#gt_encseq_encoder_create_des_tab"><code>gt_encseq_encoder_create_des_tab</code></a><br>

  <a href="#gt_encseq_encoder_create_sds_tab"><code>gt_encseq_encoder_create_sds_tab</code></a><br>

  <a href="#gt_encseq_encoder_create_ssp_tab"><code>gt_encseq_encoder_create_ssp_tab</code></a><br>

  <a href="#gt_encseq_encoder_delete"><code>gt_encseq_encoder_delete</code></a><br>

  <a href="#gt_encseq_encoder_des_tab_requested"><code>gt_encseq_encoder_des_tab_requested</code></a><br>

  <a href="#gt_encseq_encoder_disable_description_support"><code>gt_encseq_encoder_disable_description_support</code></a><br>

  <a href="#gt_encseq_encoder_disable_lossless_support"><code>gt_encseq_encoder_disable_lossless_support</code></a><br>

  <a href="#gt_encseq_encoder_disable_multiseq_support"><code>gt_encseq_encoder_disable_multiseq_support</code></a><br>

  <a href="#gt_encseq_encoder_do_not_create_des_tab"><code>gt_encseq_encoder_do_not_create_des_tab</code></a><br>

  <a href="#gt_encseq_encoder_do_not_create_sds_tab"><code>gt_encseq_encoder_do_not_create_sds_tab</code></a><br>

  <a href="#gt_encseq_encoder_do_not_create_ssp_tab"><code>gt_encseq_encoder_do_not_create_ssp_tab</code></a><br>

  <a href="#gt_encseq_encoder_enable_description_support"><code>gt_encseq_encoder_enable_description_support</code></a><br>

  <a href="#gt_encseq_encoder_enable_lossless_support"><code>gt_encseq_encoder_enable_lossless_support</code></a><br>

  <a href="#gt_encseq_encoder_enable_multiseq_support"><code>gt_encseq_encoder_enable_multiseq_support</code></a><br>

  <a href="#gt_encseq_encoder_encode"><code>gt_encseq_encoder_encode</code></a><br>

  <a href="#gt_encseq_encoder_get_timer"><code>gt_encseq_encoder_get_timer</code></a><br>

  <a href="#gt_encseq_encoder_is_input_dna"><code>gt_encseq_encoder_is_input_dna</code></a><br>

  <a href="#gt_encseq_encoder_is_input_protein"><code>gt_encseq_encoder_is_input_protein</code></a><br>

  <a href="#gt_encseq_encoder_new"><code>gt_encseq_encoder_new</code></a><br>

  <a href="#gt_encseq_encoder_representation"><code>gt_encseq_encoder_representation</code></a><br>

  <a href="#gt_encseq_encoder_sds_tab_requested"><code>gt_encseq_encoder_sds_tab_requested</code></a><br>

  <a href="#gt_encseq_encoder_set_input_dna"><code>gt_encseq_encoder_set_input_dna</code></a><br>

  <a href="#gt_encseq_encoder_set_input_protein"><code>gt_encseq_encoder_set_input_protein</code></a><br>

  <a href="#gt_encseq_encoder_set_logger"><code>gt_encseq_encoder_set_logger</code></a><br>

  <a href="#gt_encseq_encoder_set_timer"><code>gt_encseq_encoder_set_timer</code></a><br>

  <a href="#gt_encseq_encoder_ssp_tab_requested"><code>gt_encseq_encoder_ssp_tab_requested</code></a><br>

  <a href="#gt_encseq_encoder_symbolmap_file"><code>gt_encseq_encoder_symbolmap_file</code></a><br>

  <a href="#gt_encseq_encoder_use_representation"><code>gt_encseq_encoder_use_representation</code></a><br>

  <a href="#gt_encseq_encoder_use_symbolmap_file"><code>gt_encseq_encoder_use_symbolmap_file</code></a><br>

  <a href="#gt_encseq_extract_decoded"><code>gt_encseq_extract_decoded</code></a><br>

  <a href="#gt_encseq_extract_encoded"><code>gt_encseq_extract_encoded</code></a><br>

  <a href="#gt_encseq_filenames"><code>gt_encseq_filenames</code></a><br>

  <a href="#gt_encseq_filenum"><code>gt_encseq_filenum</code></a><br>

  <a href="#gt_encseq_filestartpos"><code>gt_encseq_filestartpos</code></a><br>

  <a href="#gt_encseq_get_decoded_char"><code>gt_encseq_get_decoded_char</code></a><br>

  <a href="#gt_encseq_get_encoded_char"><code>gt_encseq_get_encoded_char</code></a><br>

  <a href="#gt_encseq_has_description_support"><code>gt_encseq_has_description_support</code></a><br>

  <a href="#gt_encseq_has_multiseq_support"><code>gt_encseq_has_multiseq_support</code></a><br>

  <a href="#gt_encseq_is_mirrored"><code>gt_encseq_is_mirrored</code></a><br>

  <a href="#gt_encseq_loader_delete"><code>gt_encseq_loader_delete</code></a><br>

  <a href="#gt_encseq_loader_des_tab_required"><code>gt_encseq_loader_des_tab_required</code></a><br>

  <a href="#gt_encseq_loader_disable_autosupport"><code>gt_encseq_loader_disable_autosupport</code></a><br>

  <a href="#gt_encseq_loader_do_not_mirror"><code>gt_encseq_loader_do_not_mirror</code></a><br>

  <a href="#gt_encseq_loader_do_not_require_des_tab"><code>gt_encseq_loader_do_not_require_des_tab</code></a><br>

  <a href="#gt_encseq_loader_do_not_require_sds_tab"><code>gt_encseq_loader_do_not_require_sds_tab</code></a><br>

  <a href="#gt_encseq_loader_do_not_require_ssp_tab"><code>gt_encseq_loader_do_not_require_ssp_tab</code></a><br>

  <a href="#gt_encseq_loader_drop_description_support"><code>gt_encseq_loader_drop_description_support</code></a><br>

  <a href="#gt_encseq_loader_drop_lossless_support"><code>gt_encseq_loader_drop_lossless_support</code></a><br>

  <a href="#gt_encseq_loader_drop_multiseq_support"><code>gt_encseq_loader_drop_multiseq_support</code></a><br>

  <a href="#gt_encseq_loader_enable_autosupport"><code>gt_encseq_loader_enable_autosupport</code></a><br>

  <a href="#gt_encseq_loader_load"><code>gt_encseq_loader_load</code></a><br>

  <a href="#gt_encseq_loader_mirror"><code>gt_encseq_loader_mirror</code></a><br>

  <a href="#gt_encseq_loader_new"><code>gt_encseq_loader_new</code></a><br>

  <a href="#gt_encseq_loader_require_des_tab"><code>gt_encseq_loader_require_des_tab</code></a><br>

  <a href="#gt_encseq_loader_require_description_support"><code>gt_encseq_loader_require_description_support</code></a><br>

  <a href="#gt_encseq_loader_require_lossless_support"><code>gt_encseq_loader_require_lossless_support</code></a><br>

  <a href="#gt_encseq_loader_require_multiseq_support"><code>gt_encseq_loader_require_multiseq_support</code></a><br>

  <a href="#gt_encseq_loader_require_sds_tab"><code>gt_encseq_loader_require_sds_tab</code></a><br>

  <a href="#gt_encseq_loader_require_ssp_tab"><code>gt_encseq_loader_require_ssp_tab</code></a><br>

  <a href="#gt_encseq_loader_sds_tab_required"><code>gt_encseq_loader_sds_tab_required</code></a><br>

  <a href="#gt_encseq_loader_set_logger"><code>gt_encseq_loader_set_logger</code></a><br>

  <a href="#gt_encseq_loader_ssp_tab_required"><code>gt_encseq_loader_ssp_tab_required</code></a><br>

  <a href="#gt_encseq_mirror"><code>gt_encseq_mirror</code></a><br>

  <a href="#gt_encseq_num_of_files"><code>gt_encseq_num_of_files</code></a><br>

  <a href="#gt_encseq_num_of_sequences"><code>gt_encseq_num_of_sequences</code></a><br>

  <a href="#gt_encseq_reader_delete"><code>gt_encseq_reader_delete</code></a><br>

  <a href="#gt_encseq_reader_next_decoded_char"><code>gt_encseq_reader_next_decoded_char</code></a><br>

  <a href="#gt_encseq_reader_next_encoded_char"><code>gt_encseq_reader_next_encoded_char</code></a><br>

  <a href="#gt_encseq_reader_reinit_with_readmode"><code>gt_encseq_reader_reinit_with_readmode</code></a><br>

  <a href="#gt_encseq_ref"><code>gt_encseq_ref</code></a><br>

  <a href="#gt_encseq_seqlength"><code>gt_encseq_seqlength</code></a><br>

  <a href="#gt_encseq_seqnum"><code>gt_encseq_seqnum</code></a><br>

  <a href="#gt_encseq_seqstartpos"><code>gt_encseq_seqstartpos</code></a><br>

  <a href="#gt_encseq_total_length"><code>gt_encseq_total_length</code></a><br>

  <a href="#gt_encseq_unmirror"><code>gt_encseq_unmirror</code></a><br>

  <a href="#gt_eof_node_new"><code>gt_eof_node_new</code></a><br>

  <a href="#gt_error_check"><code>gt_error_check</code></a><br>

  <a href="#gt_error_delete"><code>gt_error_delete</code></a><br>

  <a href="#gt_error_get"><code>gt_error_get</code></a><br>

  <a href="#gt_error_is_set"><code>gt_error_is_set</code></a><br>

  <a href="#gt_error_new"><code>gt_error_new</code></a><br>

  <a href="#gt_error_set"><code>gt_error_set</code></a><br>

  <a href="#gt_error_set_nonvariadic"><code>gt_error_set_nonvariadic</code></a><br>

  <a href="#gt_error_unset"><code>gt_error_unset</code></a><br>

  <a href="#gt_error_vset"><code>gt_error_vset</code></a><br>

  <a href="#gt_feature_index_add_feature_node"><code>gt_feature_index_add_feature_node</code></a><br>

  <a href="#gt_feature_index_add_gff3file"><code>gt_feature_index_add_gff3file</code></a><br>

  <a href="#gt_feature_index_add_region_node"><code>gt_feature_index_add_region_node</code></a><br>

  <a href="#gt_feature_index_delete"><code>gt_feature_index_delete</code></a><br>

  <a href="#gt_feature_index_get_features_for_range"><code>gt_feature_index_get_features_for_range</code></a><br>

  <a href="#gt_feature_index_get_features_for_seqid"><code>gt_feature_index_get_features_for_seqid</code></a><br>

  <a href="#gt_feature_index_get_first_seqid"><code>gt_feature_index_get_first_seqid</code></a><br>

  <a href="#gt_feature_index_get_range_for_seqid"><code>gt_feature_index_get_range_for_seqid</code></a><br>

  <a href="#gt_feature_index_get_seqids"><code>gt_feature_index_get_seqids</code></a><br>

  <a href="#gt_feature_index_has_seqid"><code>gt_feature_index_has_seqid</code></a><br>

  <a href="#gt_feature_index_memory_new"><code>gt_feature_index_memory_new</code></a><br>

  <a href="#gt_feature_node_add_attribute"><code>gt_feature_node_add_attribute</code></a><br>

  <a href="#gt_feature_node_add_child"><code>gt_feature_node_add_child</code></a><br>

  <a href="#gt_feature_node_get_attribute"><code>gt_feature_node_get_attribute</code></a><br>

  <a href="#gt_feature_node_get_attribute_list"><code>gt_feature_node_get_attribute_list</code></a><br>

  <a href="#gt_feature_node_get_phase"><code>gt_feature_node_get_phase</code></a><br>

  <a href="#gt_feature_node_get_score"><code>gt_feature_node_get_score</code></a><br>

  <a href="#gt_feature_node_get_source"><code>gt_feature_node_get_source</code></a><br>

  <a href="#gt_feature_node_get_strand"><code>gt_feature_node_get_strand</code></a><br>

  <a href="#gt_feature_node_get_type"><code>gt_feature_node_get_type</code></a><br>

  <a href="#gt_feature_node_has_source"><code>gt_feature_node_has_source</code></a><br>

  <a href="#gt_feature_node_has_type"><code>gt_feature_node_has_type</code></a><br>

  <a href="#gt_feature_node_iterator_delete"><code>gt_feature_node_iterator_delete</code></a><br>

  <a href="#gt_feature_node_iterator_new"><code>gt_feature_node_iterator_new</code></a><br>

  <a href="#gt_feature_node_iterator_new_direct"><code>gt_feature_node_iterator_new_direct</code></a><br>

  <a href="#gt_feature_node_iterator_next"><code>gt_feature_node_iterator_next</code></a><br>

  <a href="#gt_feature_node_new"><code>gt_feature_node_new</code></a><br>

  <a href="#gt_feature_node_new_standard_gene"><code>gt_feature_node_new_standard_gene</code></a><br>

  <a href="#gt_feature_node_score_is_defined"><code>gt_feature_node_score_is_defined</code></a><br>

  <a href="#gt_feature_node_set_attribute"><code>gt_feature_node_set_attribute</code></a><br>

  <a href="#gt_feature_node_set_phase"><code>gt_feature_node_set_phase</code></a><br>

  <a href="#gt_feature_node_set_score"><code>gt_feature_node_set_score</code></a><br>

  <a href="#gt_feature_node_set_source"><code>gt_feature_node_set_source</code></a><br>

  <a href="#gt_feature_node_set_strand"><code>gt_feature_node_set_strand</code></a><br>

  <a href="#gt_feature_node_set_type"><code>gt_feature_node_set_type</code></a><br>

  <a href="#gt_feature_node_unset_score"><code>gt_feature_node_unset_score</code></a><br>

  <a href="#gt_file_delete"><code>gt_file_delete</code></a><br>

  <a href="#gt_file_dirname"><code>gt_file_dirname</code></a><br>

  <a href="#gt_file_estimate_size"><code>gt_file_estimate_size</code></a><br>

  <a href="#gt_file_exists"><code>gt_file_exists</code></a><br>

  <a href="#gt_file_find_in_env"><code>gt_file_find_in_env</code></a><br>

  <a href="#gt_file_find_in_path"><code>gt_file_find_in_path</code></a><br>

  <a href="#gt_file_is_newer"><code>gt_file_is_newer</code></a><br>

  <a href="#gt_file_new"><code>gt_file_new</code></a><br>

  <a href="#gt_file_number_of_lines"><code>gt_file_number_of_lines</code></a><br>

  <a href="#gt_file_suffix"><code>gt_file_suffix</code></a><br>

  <a href="#gt_file_xfputs"><code>gt_file_xfputs</code></a><br>

  <a href="#gt_files_estimate_total_size"><code>gt_files_estimate_total_size</code></a><br>

  <a href="#gt_files_guess_if_protein_sequences"><code>gt_files_guess_if_protein_sequences</code></a><br>

  <a href="#gt_free"><code>gt_free</code></a><br>

  <a href="#gt_free_func"><code>gt_free_func</code></a><br>

  <a href="#gt_genome_node_add_user_data"><code>gt_genome_node_add_user_data</code></a><br>

  <a href="#gt_genome_node_delete"><code>gt_genome_node_delete</code></a><br>

  <a href="#gt_genome_node_get_end"><code>gt_genome_node_get_end</code></a><br>

  <a href="#gt_genome_node_get_filename"><code>gt_genome_node_get_filename</code></a><br>

  <a href="#gt_genome_node_get_length"><code>gt_genome_node_get_length</code></a><br>

  <a href="#gt_genome_node_get_line_number"><code>gt_genome_node_get_line_number</code></a><br>

  <a href="#gt_genome_node_get_range"><code>gt_genome_node_get_range</code></a><br>

  <a href="#gt_genome_node_get_seqid"><code>gt_genome_node_get_seqid</code></a><br>

  <a href="#gt_genome_node_get_start"><code>gt_genome_node_get_start</code></a><br>

  <a href="#gt_genome_node_get_user_data"><code>gt_genome_node_get_user_data</code></a><br>

  <a href="#gt_genome_node_ref"><code>gt_genome_node_ref</code></a><br>

  <a href="#gt_genome_node_release_user_data"><code>gt_genome_node_release_user_data</code></a><br>

  <a href="#gt_genome_node_set_range"><code>gt_genome_node_set_range</code></a><br>

  <a href="#gt_gff3_in_stream_check_id_attributes"><code>gt_gff3_in_stream_check_id_attributes</code></a><br>

  <a href="#gt_gff3_in_stream_enable_tidy_mode"><code>gt_gff3_in_stream_enable_tidy_mode</code></a><br>

  <a href="#gt_gff3_in_stream_new_sorted"><code>gt_gff3_in_stream_new_sorted</code></a><br>

  <a href="#gt_gff3_in_stream_new_unsorted"><code>gt_gff3_in_stream_new_unsorted</code></a><br>

  <a href="#gt_gff3_in_stream_show_progress_bar"><code>gt_gff3_in_stream_show_progress_bar</code></a><br>

  <a href="#gt_gff3_out_stream_new"><code>gt_gff3_out_stream_new</code></a><br>

  <a href="#gt_gff3_out_stream_retain_id_attributes"><code>gt_gff3_out_stream_retain_id_attributes</code></a><br>

  <a href="#gt_gff3_out_stream_set_fasta_width"><code>gt_gff3_out_stream_set_fasta_width</code></a><br>

  <a href="#gt_gff3_parser_check_id_attributes"><code>gt_gff3_parser_check_id_attributes</code></a><br>

  <a href="#gt_gff3_parser_delete"><code>gt_gff3_parser_delete</code></a><br>

  <a href="#gt_gff3_parser_enable_tidy_mode"><code>gt_gff3_parser_enable_tidy_mode</code></a><br>

  <a href="#gt_gff3_parser_new"><code>gt_gff3_parser_new</code></a><br>

  <a href="#gt_gff3_parser_parse_genome_nodes"><code>gt_gff3_parser_parse_genome_nodes</code></a><br>

  <a href="#gt_gff3_parser_reset"><code>gt_gff3_parser_reset</code></a><br>

  <a href="#gt_gff3_parser_set_offset"><code>gt_gff3_parser_set_offset</code></a><br>

  <a href="#gt_graphics_delete"><code>gt_graphics_delete</code></a><br>

  <a href="#gt_graphics_draw_arrowhead"><code>gt_graphics_draw_arrowhead</code></a><br>

  <a href="#gt_graphics_draw_box"><code>gt_graphics_draw_box</code></a><br>

  <a href="#gt_graphics_draw_caret"><code>gt_graphics_draw_caret</code></a><br>

  <a href="#gt_graphics_draw_colored_text"><code>gt_graphics_draw_colored_text</code></a><br>

  <a href="#gt_graphics_draw_curve_data"><code>gt_graphics_draw_curve_data</code></a><br>

  <a href="#gt_graphics_draw_dashes"><code>gt_graphics_draw_dashes</code></a><br>

  <a href="#gt_graphics_draw_horizontal_line"><code>gt_graphics_draw_horizontal_line</code></a><br>

  <a href="#gt_graphics_draw_line"><code>gt_graphics_draw_line</code></a><br>

  <a href="#gt_graphics_draw_rectangle"><code>gt_graphics_draw_rectangle</code></a><br>

  <a href="#gt_graphics_draw_text"><code>gt_graphics_draw_text</code></a><br>

  <a href="#gt_graphics_draw_text_centered"><code>gt_graphics_draw_text_centered</code></a><br>

  <a href="#gt_graphics_draw_text_clip"><code>gt_graphics_draw_text_clip</code></a><br>

  <a href="#gt_graphics_draw_text_left"><code>gt_graphics_draw_text_left</code></a><br>

  <a href="#gt_graphics_draw_text_right"><code>gt_graphics_draw_text_right</code></a><br>

  <a href="#gt_graphics_draw_vertical_line"><code>gt_graphics_draw_vertical_line</code></a><br>

  <a href="#gt_graphics_get_image_height"><code>gt_graphics_get_image_height</code></a><br>

  <a href="#gt_graphics_get_image_width"><code>gt_graphics_get_image_width</code></a><br>

  <a href="#gt_graphics_get_text_height"><code>gt_graphics_get_text_height</code></a><br>

  <a href="#gt_graphics_get_text_width"><code>gt_graphics_get_text_width</code></a><br>

  <a href="#gt_graphics_get_xmargins"><code>gt_graphics_get_xmargins</code></a><br>

  <a href="#gt_graphics_get_ymargins"><code>gt_graphics_get_ymargins</code></a><br>

  <a href="#gt_graphics_save_to_file"><code>gt_graphics_save_to_file</code></a><br>

  <a href="#gt_graphics_save_to_stream"><code>gt_graphics_save_to_stream</code></a><br>

  <a href="#gt_graphics_set_background_color"><code>gt_graphics_set_background_color</code></a><br>

  <a href="#gt_graphics_set_font"><code>gt_graphics_set_font</code></a><br>

  <a href="#gt_graphics_set_margins"><code>gt_graphics_set_margins</code></a><br>

  <a href="#gt_grep"><code>gt_grep</code></a><br>

  <a href="#gt_gtf_in_stream_new"><code>gt_gtf_in_stream_new</code></a><br>

  <a href="#gt_hashmap_add"><code>gt_hashmap_add</code></a><br>

  <a href="#gt_hashmap_delete"><code>gt_hashmap_delete</code></a><br>

  <a href="#gt_hashmap_foreach"><code>gt_hashmap_foreach</code></a><br>

  <a href="#gt_hashmap_foreach_in_key_order"><code>gt_hashmap_foreach_in_key_order</code></a><br>

  <a href="#gt_hashmap_foreach_ordered"><code>gt_hashmap_foreach_ordered</code></a><br>

  <a href="#gt_hashmap_get"><code>gt_hashmap_get</code></a><br>

  <a href="#gt_hashmap_new"><code>gt_hashmap_new</code></a><br>

  <a href="#gt_hashmap_remove"><code>gt_hashmap_remove</code></a><br>

  <a href="#gt_hashmap_reset"><code>gt_hashmap_reset</code></a><br>

  <a href="#gt_image_info_delete"><code>gt_image_info_delete</code></a><br>

  <a href="#gt_image_info_get_height"><code>gt_image_info_get_height</code></a><br>

  <a href="#gt_image_info_get_rec_map"><code>gt_image_info_get_rec_map</code></a><br>

  <a href="#gt_image_info_new"><code>gt_image_info_new</code></a><br>

  <a href="#gt_image_info_num_of_rec_maps"><code>gt_image_info_num_of_rec_maps</code></a><br>

  <a href="#gt_interval_tree_delete"><code>gt_interval_tree_delete</code></a><br>

  <a href="#gt_interval_tree_find_all_overlapping"><code>gt_interval_tree_find_all_overlapping</code></a><br>

  <a href="#gt_interval_tree_find_first_overlapping"><code>gt_interval_tree_find_first_overlapping</code></a><br>

  <a href="#gt_interval_tree_insert"><code>gt_interval_tree_insert</code></a><br>

  <a href="#gt_interval_tree_new"><code>gt_interval_tree_new</code></a><br>

  <a href="#gt_interval_tree_node_get_data"><code>gt_interval_tree_node_get_data</code></a><br>

  <a href="#gt_interval_tree_node_new"><code>gt_interval_tree_node_new</code></a><br>

  <a href="#gt_interval_tree_size"><code>gt_interval_tree_size</code></a><br>

  <a href="#gt_interval_tree_traverse"><code>gt_interval_tree_traverse</code></a><br>

  <a href="#gt_is_little_endian"><code>gt_is_little_endian</code></a><br>

  <a href="#gt_layout_delete"><code>gt_layout_delete</code></a><br>

  <a href="#gt_layout_get_height"><code>gt_layout_get_height</code></a><br>

  <a href="#gt_layout_new"><code>gt_layout_new</code></a><br>

  <a href="#gt_layout_new_with_twc"><code>gt_layout_new_with_twc</code></a><br>

  <a href="#gt_layout_set_track_ordering_func"><code>gt_layout_set_track_ordering_func</code></a><br>

  <a href="#gt_layout_sketch"><code>gt_layout_sketch</code></a><br>

  <a href="#gt_lib_clean"><code>gt_lib_clean</code></a><br>

  <a href="#gt_lib_init"><code>gt_lib_init</code></a><br>

  <a href="#gt_lib_reg_atexit_func"><code>gt_lib_reg_atexit_func</code></a><br>

  <a href="#gt_log_enable"><code>gt_log_enable</code></a><br>

  <a href="#gt_log_enabled"><code>gt_log_enabled</code></a><br>

  <a href="#gt_log_fp"><code>gt_log_fp</code></a><br>

  <a href="#gt_log_log"><code>gt_log_log</code></a><br>

  <a href="#gt_log_set_fp"><code>gt_log_set_fp</code></a><br>

  <a href="#gt_log_vlog"><code>gt_log_vlog</code></a><br>

  <a href="#gt_logger_disable"><code>gt_logger_disable</code></a><br>

  <a href="#gt_logger_enable"><code>gt_logger_enable</code></a><br>

  <a href="#gt_logger_enabled"><code>gt_logger_enabled</code></a><br>

  <a href="#gt_logger_log"><code>gt_logger_log</code></a><br>

  <a href="#gt_logger_log_force"><code>gt_logger_log_force</code></a><br>

  <a href="#gt_logger_log_va"><code>gt_logger_log_va</code></a><br>

  <a href="#gt_logger_log_va_force"><code>gt_logger_log_va_force</code></a><br>

  <a href="#gt_logger_new"><code>gt_logger_new</code></a><br>

  <a href="#gt_logger_set_target"><code>gt_logger_set_target</code></a><br>

  <a href="#gt_logger_target"><code>gt_logger_target</code></a><br>

  <a href="#gt_malloc"><code>gt_malloc</code></a><br>

  <a href="#gt_merge_stream_new"><code>gt_merge_stream_new</code></a><br>

  <a href="#gt_msort"><code>gt_msort</code></a><br>

  <a href="#gt_msort_r"><code>gt_msort_r</code></a><br>

  <a href="#gt_node_stream_cast"><code>gt_node_stream_cast</code></a><br>

  <a href="#gt_node_stream_class_new"><code>gt_node_stream_class_new</code></a><br>

  <a href="#gt_node_stream_create"><code>gt_node_stream_create</code></a><br>

  <a href="#gt_node_stream_delete"><code>gt_node_stream_delete</code></a><br>

  <a href="#gt_node_stream_is_sorted"><code>gt_node_stream_is_sorted</code></a><br>

  <a href="#gt_node_stream_next"><code>gt_node_stream_next</code></a><br>

  <a href="#gt_node_stream_pull"><code>gt_node_stream_pull</code></a><br>

  <a href="#gt_node_stream_ref"><code>gt_node_stream_ref</code></a><br>

  <a href="#gt_node_visitor_delete"><code>gt_node_visitor_delete</code></a><br>

  <a href="#gt_node_visitor_visit_comment_node"><code>gt_node_visitor_visit_comment_node</code></a><br>

  <a href="#gt_node_visitor_visit_feature_node"><code>gt_node_visitor_visit_feature_node</code></a><br>

  <a href="#gt_node_visitor_visit_region_node"><code>gt_node_visitor_visit_region_node</code></a><br>

  <a href="#gt_node_visitor_visit_sequence_node"><code>gt_node_visitor_visit_sequence_node</code></a><br>

  <a href="#gt_parse_double"><code>gt_parse_double</code></a><br>

  <a href="#gt_parse_int"><code>gt_parse_int</code></a><br>

  <a href="#gt_parse_long"><code>gt_parse_long</code></a><br>

  <a href="#gt_parse_range"><code>gt_parse_range</code></a><br>

  <a href="#gt_parse_range_tidy"><code>gt_parse_range_tidy</code></a><br>

  <a href="#gt_parse_uint"><code>gt_parse_uint</code></a><br>

  <a href="#gt_parse_ulong"><code>gt_parse_ulong</code></a><br>

  <a href="#gt_phase_get"><code>gt_phase_get</code></a><br>

  <a href="#gt_qsort_r"><code>gt_qsort_r</code></a><br>

  <a href="#gt_queue_add"><code>gt_queue_add</code></a><br>

  <a href="#gt_queue_delete"><code>gt_queue_delete</code></a><br>

  <a href="#gt_queue_get"><code>gt_queue_get</code></a><br>

  <a href="#gt_queue_head"><code>gt_queue_head</code></a><br>

  <a href="#gt_queue_new"><code>gt_queue_new</code></a><br>

  <a href="#gt_queue_remove"><code>gt_queue_remove</code></a><br>

  <a href="#gt_queue_size"><code>gt_queue_size</code></a><br>

  <a href="#gt_range_compare"><code>gt_range_compare</code></a><br>

  <a href="#gt_range_compare_with_delta"><code>gt_range_compare_with_delta</code></a><br>

  <a href="#gt_range_contains"><code>gt_range_contains</code></a><br>

  <a href="#gt_range_join"><code>gt_range_join</code></a><br>

  <a href="#gt_range_length"><code>gt_range_length</code></a><br>

  <a href="#gt_range_offset"><code>gt_range_offset</code></a><br>

  <a href="#gt_range_overlap"><code>gt_range_overlap</code></a><br>

  <a href="#gt_range_overlap_delta"><code>gt_range_overlap_delta</code></a><br>

  <a href="#gt_range_within"><code>gt_range_within</code></a><br>

  <a href="#gt_readmode_parse"><code>gt_readmode_parse</code></a><br>

  <a href="#gt_readmode_show"><code>gt_readmode_show</code></a><br>

  <a href="#gt_realloc"><code>gt_realloc</code></a><br>

  <a href="#gt_rec_map_get_genome_feature"><code>gt_rec_map_get_genome_feature</code></a><br>

  <a href="#gt_rec_map_get_northwest_x"><code>gt_rec_map_get_northwest_x</code></a><br>

  <a href="#gt_rec_map_get_northwest_y"><code>gt_rec_map_get_northwest_y</code></a><br>

  <a href="#gt_rec_map_get_southeast_x"><code>gt_rec_map_get_southeast_x</code></a><br>

  <a href="#gt_rec_map_get_southeast_y"><code>gt_rec_map_get_southeast_y</code></a><br>

  <a href="#gt_rec_map_has_omitted_children"><code>gt_rec_map_has_omitted_children</code></a><br>

  <a href="#gt_region_node_new"><code>gt_region_node_new</code></a><br>

  <a href="#gt_sequence_node_get_description"><code>gt_sequence_node_get_description</code></a><br>

  <a href="#gt_sequence_node_get_sequence"><code>gt_sequence_node_get_sequence</code></a><br>

  <a href="#gt_sequence_node_get_sequence_length"><code>gt_sequence_node_get_sequence_length</code></a><br>

  <a href="#gt_sequence_node_new"><code>gt_sequence_node_new</code></a><br>

  <a href="#gt_sort_stream_new"><code>gt_sort_stream_new</code></a><br>

  <a href="#gt_splitter_delete"><code>gt_splitter_delete</code></a><br>

  <a href="#gt_splitter_get_token"><code>gt_splitter_get_token</code></a><br>

  <a href="#gt_splitter_get_tokens"><code>gt_splitter_get_tokens</code></a><br>

  <a href="#gt_splitter_new"><code>gt_splitter_new</code></a><br>

  <a href="#gt_splitter_reset"><code>gt_splitter_reset</code></a><br>

  <a href="#gt_splitter_size"><code>gt_splitter_size</code></a><br>

  <a href="#gt_splitter_split"><code>gt_splitter_split</code></a><br>

  <a href="#gt_str_append_char"><code>gt_str_append_char</code></a><br>

  <a href="#gt_str_append_cstr"><code>gt_str_append_cstr</code></a><br>

  <a href="#gt_str_append_cstr_nt"><code>gt_str_append_cstr_nt</code></a><br>

  <a href="#gt_str_append_double"><code>gt_str_append_double</code></a><br>

  <a href="#gt_str_append_int"><code>gt_str_append_int</code></a><br>

  <a href="#gt_str_append_str"><code>gt_str_append_str</code></a><br>

  <a href="#gt_str_append_uint"><code>gt_str_append_uint</code></a><br>

  <a href="#gt_str_append_ulong"><code>gt_str_append_ulong</code></a><br>

  <a href="#gt_str_array_add"><code>gt_str_array_add</code></a><br>

  <a href="#gt_str_array_add_cstr"><code>gt_str_array_add_cstr</code></a><br>

  <a href="#gt_str_array_add_cstr_nt"><code>gt_str_array_add_cstr_nt</code></a><br>

  <a href="#gt_str_array_delete"><code>gt_str_array_delete</code></a><br>

  <a href="#gt_str_array_get"><code>gt_str_array_get</code></a><br>

  <a href="#gt_str_array_new"><code>gt_str_array_new</code></a><br>

  <a href="#gt_str_array_ref"><code>gt_str_array_ref</code></a><br>

  <a href="#gt_str_array_set"><code>gt_str_array_set</code></a><br>

  <a href="#gt_str_array_set_cstr"><code>gt_str_array_set_cstr</code></a><br>

  <a href="#gt_str_array_set_size"><code>gt_str_array_set_size</code></a><br>

  <a href="#gt_str_array_size"><code>gt_str_array_size</code></a><br>

  <a href="#gt_str_clone"><code>gt_str_clone</code></a><br>

  <a href="#gt_str_cmp"><code>gt_str_cmp</code></a><br>

  <a href="#gt_str_delete"><code>gt_str_delete</code></a><br>

  <a href="#gt_str_get"><code>gt_str_get</code></a><br>

  <a href="#gt_str_length"><code>gt_str_length</code></a><br>

  <a href="#gt_str_new"><code>gt_str_new</code></a><br>

  <a href="#gt_str_new_cstr"><code>gt_str_new_cstr</code></a><br>

  <a href="#gt_str_ref"><code>gt_str_ref</code></a><br>

  <a href="#gt_str_reset"><code>gt_str_reset</code></a><br>

  <a href="#gt_str_set"><code>gt_str_set</code></a><br>

  <a href="#gt_str_set_length"><code>gt_str_set_length</code></a><br>

  <a href="#gt_strand_get"><code>gt_strand_get</code></a><br>

  <a href="#gt_style_clone"><code>gt_style_clone</code></a><br>

  <a href="#gt_style_delete"><code>gt_style_delete</code></a><br>

  <a href="#gt_style_is_unsafe"><code>gt_style_is_unsafe</code></a><br>

  <a href="#gt_style_load_file"><code>gt_style_load_file</code></a><br>

  <a href="#gt_style_load_str"><code>gt_style_load_str</code></a><br>

  <a href="#gt_style_new"><code>gt_style_new</code></a><br>

  <a href="#gt_style_ref"><code>gt_style_ref</code></a><br>

  <a href="#gt_style_reload"><code>gt_style_reload</code></a><br>

  <a href="#gt_style_safe_mode"><code>gt_style_safe_mode</code></a><br>

  <a href="#gt_style_set_bool"><code>gt_style_set_bool</code></a><br>

  <a href="#gt_style_set_color"><code>gt_style_set_color</code></a><br>

  <a href="#gt_style_set_num"><code>gt_style_set_num</code></a><br>

  <a href="#gt_style_set_str"><code>gt_style_set_str</code></a><br>

  <a href="#gt_style_to_str"><code>gt_style_to_str</code></a><br>

  <a href="#gt_style_unsafe_mode"><code>gt_style_unsafe_mode</code></a><br>

  <a href="#gt_style_unset"><code>gt_style_unset</code></a><br>

  <a href="#gt_text_width_calculator_cairo_new"><code>gt_text_width_calculator_cairo_new</code></a><br>

  <a href="#gt_text_width_calculator_delete"><code>gt_text_width_calculator_delete</code></a><br>

  <a href="#gt_text_width_calculator_get_text_width"><code>gt_text_width_calculator_get_text_width</code></a><br>

  <a href="#gt_text_width_calculator_ref"><code>gt_text_width_calculator_ref</code></a><br>

  <a href="#gt_timer_delete"><code>gt_timer_delete</code></a><br>

  <a href="#gt_timer_new"><code>gt_timer_new</code></a><br>

  <a href="#gt_timer_new_with_progress_description"><code>gt_timer_new_with_progress_description</code></a><br>

  <a href="#gt_timer_omit_last_stage"><code>gt_timer_omit_last_stage</code></a><br>

  <a href="#gt_timer_show"><code>gt_timer_show</code></a><br>

  <a href="#gt_timer_show_cpu_time_by_progress"><code>gt_timer_show_cpu_time_by_progress</code></a><br>

  <a href="#gt_timer_show_formatted"><code>gt_timer_show_formatted</code></a><br>

  <a href="#gt_timer_show_progress"><code>gt_timer_show_progress</code></a><br>

  <a href="#gt_timer_show_progress_final"><code>gt_timer_show_progress_final</code></a><br>

  <a href="#gt_timer_start"><code>gt_timer_start</code></a><br>

  <a href="#gt_timer_stop"><code>gt_timer_stop</code></a><br>

  <a href="#gt_trans_table_delete"><code>gt_trans_table_delete</code></a><br>

  <a href="#gt_trans_table_description"><code>gt_trans_table_description</code></a><br>

  <a href="#gt_trans_table_get_scheme_descriptions"><code>gt_trans_table_get_scheme_descriptions</code></a><br>

  <a href="#gt_trans_table_new"><code>gt_trans_table_new</code></a><br>

  <a href="#gt_trans_table_new_standard"><code>gt_trans_table_new_standard</code></a><br>

  <a href="#gt_trans_table_translate_codon"><code>gt_trans_table_translate_codon</code></a><br>

  <a href="#gt_translator_delete"><code>gt_translator_delete</code></a><br>

  <a href="#gt_translator_find_codon"><code>gt_translator_find_codon</code></a><br>

  <a href="#gt_translator_find_startcodon"><code>gt_translator_find_startcodon</code></a><br>

  <a href="#gt_translator_find_stopcodon"><code>gt_translator_find_stopcodon</code></a><br>

  <a href="#gt_translator_new"><code>gt_translator_new</code></a><br>

  <a href="#gt_translator_new_with_table"><code>gt_translator_new_with_table</code></a><br>

  <a href="#gt_translator_next"><code>gt_translator_next</code></a><br>

  <a href="#gt_translator_set_codon_iterator"><code>gt_translator_set_codon_iterator</code></a><br>

  <a href="#gt_translator_set_translation_table"><code>gt_translator_set_translation_table</code></a><br>

  <a href="#gt_type_checker_delete"><code>gt_type_checker_delete</code></a><br>

  <a href="#gt_type_checker_is_valid"><code>gt_type_checker_is_valid</code></a><br>

  <a href="#gt_type_checker_obo_new"><code>gt_type_checker_obo_new</code></a><br>

  <a href="#gt_type_checker_ref"><code>gt_type_checker_ref</code></a><br>

  <a href="#gt_version_check"><code>gt_version_check</code></a><br>

  <a href="#gt_visitor_stream_new"><code>gt_visitor_stream_new</code></a><br>

  <a href="#gt_warning"><code>gt_warning</code></a><br>

  <a href="#gt_warning_default_handler"><code>gt_warning_default_handler</code></a><br>

  <a href="#gt_warning_disable"><code>gt_warning_disable</code></a><br>

  <a href="#gt_warning_get_data"><code>gt_warning_get_data</code></a><br>

  <a href="#gt_warning_get_handler"><code>gt_warning_get_handler</code></a><br>

  <a href="#gt_warning_set_handler"><code>gt_warning_set_handler</code></a><br>

  <a href="#gt_xatexit"><code>gt_xatexit</code></a><br>

  <a href="#gt_xfclose"><code>gt_xfclose</code></a><br>

  <a href="#gt_xfflush"><code>gt_xfflush</code></a><br>

  <a href="#gt_xfgetc"><code>gt_xfgetc</code></a><br>

  <a href="#gt_xfgetpos"><code>gt_xfgetpos</code></a><br>

  <a href="#gt_xfgets"><code>gt_xfgets</code></a><br>

  <a href="#gt_xfopen"><code>gt_xfopen</code></a><br>

  <a href="#gt_xfputc"><code>gt_xfputc</code></a><br>

  <a href="#gt_xfputs"><code>gt_xfputs</code></a><br>

  <a href="#gt_xfread"><code>gt_xfread</code></a><br>

  <a href="#gt_xfseek"><code>gt_xfseek</code></a><br>

  <a href="#gt_xfsetpos"><code>gt_xfsetpos</code></a><br>

  <a href="#gt_xfwrite"><code>gt_xfwrite</code></a><br>

  <a href="#gt_xputchar"><code>gt_xputchar</code></a><br>

  <a href="#gt_xputs"><code>gt_xputs</code></a><br>

  <a href="#gt_xremove"><code>gt_xremove</code></a><br>

  <a href="#gt_xungetc"><code>gt_xungetc</code></a><br>

  <a href="#gt_xvfprintf"><code>gt_xvfprintf</code></a><br>

  <a href="#gt_xvsnprintf"><code>gt_xvsnprintf</code></a><br>

<div id="footer">
Copyright &copy; 2008-2011
<a href="mailto:gremme@gmail.com">Gordon Gremme.</a>
Last update: 2011-05-21
</div>
</div>
<!-- Piwik -->
<script type="text/javascript">
var pkBaseURL = (("https:" == document.location.protocol) ?  "https://gremme.org/piwik/" : "http://gremme.org/piwik/");
document.write(unescape("%3Cscript src='" + pkBaseURL + "piwik.js' type='text/javascript'%3E%3C/script%3E"));
</script><script type="text/javascript">
try {
var piwikTracker = Piwik.getTracker(pkBaseURL + "piwik.php", 5);
piwikTracker.trackPageView();
piwikTracker.enableLinkTracking();
} catch( err ) {}
</script><noscript><p><img src="http://gremme.org/piwik/piwik.php?idsite=5" style="border:0" alt="" /></p></noscript>
<!-- End Piwik Tracking Tag -->
</body>
</html>
