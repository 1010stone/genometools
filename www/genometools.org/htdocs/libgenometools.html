<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>gtscript documentation</title>
<link rel="stylesheet" type="text/css" href="style.css">
</head>
<body>
<div id="menu">
<ul>
<li><a href="index.html">Overview</a></li>
<li><a href="pub/">Download</a></li>
<li><a href="cgi-bin/gitweb.cgi?p=genometools.git;a=summary">Browse source</a></li>
<li><a href="design.html">Design</a></li>
<li><a id="current" href="libgenometools.html">C API</a></li>
<li><a href="docs.html"><tt>gtscript</tt> docs</a></li>
<li><a href="annotationsketch.html"><tt>AnnotationSketch</tt></a></li>
<li><a href="license.html">License</a></li>
</ul>
</div>
<div id="main">
<h1><i>GenomeTools</i> C API</h1>
<p>
This document describes the <i>GenomeTools</i> C API (<tt>libgenometools</tt>).
</p>
<h2>Classes</h2>
<ul>

  <li><a href="#GT_Array">GT_Array</a>

  <li><a href="#GT_Str">GT_Str</a>

</ul>
<a name="GT_Array"></a>
<h2>Class GT_Array</h2>

<p> Objects of the <code>GT_Array</code> class grow on demand. </p>

<hr>
<code>GT_Array* gt_array_new(size_t size_of_elem)</code>
<p>
Return a new <code>GT_Array*</code> object whose elements have the size
   <code>size_of_elem</code>.
</p>
<hr>
<code>GT_Array* gt_array_ref(GT_Array *array)</code>
<p>
Increase the reference count for <code>array</code> and return it.
   If <code>array</code> is <code>NULL</code>, <code>NULL</code> is returned without any side effects.
</p>
<hr>
<code>GT_Array* gt_array_clone(const GT_Array *array)</code>
<p>
Return a clone of <code>array</code>.
</p>
<hr>
<code>void* gt_array_get(const GT_Array *array, unsigned long index)</code>
<p>
Return pointer to element number <code>index</code> of <code>array</code>. <code>index</code> has to be
   smaller than <code>gt_array_size(array)</code>.
</p>
<hr>
<code>void* gt_array_get_first(const GT_Array *array)</code>
<p>
Return pointer to first element of <code>array</code>.
</p>
<hr>
<code>void* gt_array_get_last(const GT_Array *array)</code>
<p>
Return pointer to last element of <code>array</code>.
</p>
<hr>
<code>void* gt_array_pop(GT_Array *array)</code>
<p>
Return pointer to last element of <code>array</code> and remove it from <code>array</code>.
</p>
<hr>
<code>void* gt_array_get_space(const GT_Array *array)</code>
<p>
Return pointer to the internal space of <code>array</code> where the elements are
   stored.
</p>
<hr>
<code>#define gt_array_add(array, elem)</code>
<p>
Add element <code>elem</code> to <code>array</code>. The size of <code>elem</code> must equal the given
   element size when the <code>array</code> was created and is determined automatically
   with the <code>sizeof</code> operator.
</p>
<hr>
<code>void gt_array_add_elem(GT_Array *array, void *elem,
                                size_t size_of_elem)</code>
<p>
Add element <code>elem</code> with size <code>size_of_elem</code> to <code>array</code>. <code>size_of_elem</code> must
   equal the given element size when the <code>array</code> was created. Usually, this
   method is not used directly and the macro <code>gt_array_add()</code> is used
   instead.
</p>
<hr>
<code>void gt_array_add_array(GT_Array *dest, const GT_Array *src)</code>
<p>
Add all elements of array <code>src</code> to the array <code>dest</code>. The element sizes of
   both arrays must be equal.
</p>
<hr>
<code>void gt_array_rem(GT_Array *array, unsigned long index)</code>
<p>
Remove element with number <code>index</code> from <code>array</code> in O(<code>gt_array_size(array)</code>)
   time. <code>index</code> has to be smaller than <code>gt_array_size(array)</code>.
</p>
<hr>
<code>void gt_array_reverse(GT_Array *array)</code>
<p>
Reverse the order of the elements in <code>array</code>.
</p>
<hr>
<code>void gt_array_set_size(GT_Array *array, unsigned long size)</code>
<p>
Set the size of <code>array</code> to <code>size</code>. <code>size</code> must be smaller than
   <code>gt_array_size(array)</code>.
</p>
<hr>
<code>void gt_array_reset(GT_Array *array)</code>
<p>
Reset the <code>array</code>. That is, afterwards the array has size 0.
</p>
<hr>
<code>size_t gt_array_elem_size(const GT_Array *array)</code>
<p>
Return the size of the elements stored in <code>array</code>.
</p>
<hr>
<code>unsigned long gt_array_size(const GT_Array *array)</code>
<p>
Return the number of elements in <code>array</code>. If <code>array</code> equals <code>NULL</code>, 0 is
   returned.
</p>
<hr>
<code>void gt_array_sort(GT_Array *array, GT_Compare compar)</code>
<p>
Sort <code>array</code> with the given compare function <code>compar</code>.
</p>
<hr>
<code>int gt_array_cmp(const GT_Array *array_a, const GT_Array *array_b)</code>
<p>
Compare the content of <code>array_a</code> with the content of <code>array_b</code>.
   <code>array_a</code> and <code>array_b</code> must have the same <code>gt_array_size()</code> and
   <code>gt_array_elem_size()</code>.
</p>
<hr>
<code>void gt_array_delete(GT_Array *array)</code>
<p>
Decrease the reference count for <code>array</code> or delete it, if this was the last
   reference.
</p>
<hr>
<a name="GT_Str"></a>
<h2>Class GT_Str</h2>

<p> Objects of the <code>GT_Str</code> class are strings which grow on demand. </p>

<hr>
<code>GT_Str* gt_str_new(void)</code>
<p>
Return an empty <code>GT_Str*</code> object.
</p>
<hr>
<code>GT_Str* gt_str_new_cstr(const char *cstr)</code>
<p>
Return a new <code>GT_Str*</code> object whose content is set to <code>cstr</code>.
</p>
<hr>
<code>GT_Str* gt_str_clone(const GT_Str *str)</code>
<p>
Return a clone of <code>str</code>.
</p>
<hr>
<code>GT_Str* gt_str_ref(GT_Str *str)</code>
<p>
Increase the reference count for <code>str</code> and return it.
   If <code>str</code> is <code>NULL</code>, <code>NULL</code> is returned without any side effects.
</p>
<hr>
<code>char* gt_str_get(const GT_Str *str)</code>
<p>
Return the content of <code>str</code>.  Never returns NULL, and the content is always
   <code>\0</code>-terminated
</p>
<hr>
<code>void gt_str_set(GT_Str *str, const char *cstr)</code>
<p>
Set the content of <code>str</code> to <code>cstr</code>.
</p>
<hr>
<code>void gt_str_append_str(GT_Str *dest, const GT_Str *src)</code>
<p>
Append the string <code>src</code> to <code>dest</code>.
</p>
<hr>
<code>void gt_str_append_cstr(GT_Str *str, const char *cstr)</code>
<p>
Append the <code>\0</code>-terminated <code>cstr</code> to <code>str</code>.
</p>
<hr>
<code>void gt_str_append_cstr_nt(GT_Str *str,
                                    const char *cstr, unsigned long length)</code>
<p>
Append the non <code>\0</code>-terminated <code>cstr</code> with given <code>length</code> to <code>str</code>.
</p>
<hr>
<code>void gt_str_append_char(GT_Str *str, char c)</code>
<p>
Append character <code>c</code> to <code>str</code>.
</p>
<hr>
<code>void gt_str_append_double(GT_Str*, double d, int precision)</code>
<p>
Append double <code>d</code> to <code>str</code> with given <code>precision</code>.
</p>
<hr>
<code>void gt_str_append_ulong(GT_Str*, unsigned long ulong)</code>
<p>
Append <code>ulong</code> to <code>str</code>.
</p>
<hr>
<code>void gt_str_set_length(GT_Str*, unsigned long)</code>
<p>
Set length of <code>str</code> to <code>length</code>. <code>length</code> must be smaller than
   <code>gt_str_length(str)</code>.
</p>
<hr>
<code>void gt_str_reset(GT_Str *str)</code>
<p>
Reset <code>str</code> to length 0.
</p>
<hr>
<code>int gt_str_cmp(const GT_Str *str1, const GT_Str *str2)</code>
<p>
Compare <code>str1</code> and <code>str2</code> and return the result (similar to <code>strcmp(3)</code>).
</p>
<hr>
<code>int gt_str_read_next_line(GT_Str *str, FILE *fpin)</code>
<p>
Read the next line from file pointer <code>fpin</code> and store the result in <code>str</code>
   (without the terminal newline). If the end of file <code>fpin</code> is reached, <code>EOF</code>
   is returned, otherwise 0.
</p>
<hr>
<code>unsigned long gt_str_length(const GT_Str *str)</code>
<p>
Return the length of <code>str</code>. If <code>str</code> is <code>NULL</code>, 0 is returned.
</p>
<hr>
<code>void gt_str_delete(GT_Str *str)</code>
<p>
Decrease the reference count for <code>str</code> or delete it, if this was the last
   reference.
</p>
<hr>
<div id="footer">
Copyright &copy; 2008
<a href="mailto:gremme@gmail.com">Gordon Gremme.</a>
Last update: 2008-09-11
</div>
</div>
<script src="http://www.google-analytics.com/urchin.js" type="text/javascript">
</script>
<script type="text/javascript">
_uacct = "UA-301256-4";
urchinTracker();
</script>
</body>
</html>
