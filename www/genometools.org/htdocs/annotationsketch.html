<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>The AnnotationSketch module</title>
<link rel="stylesheet" type="text/css" href="style.css">
</head>
<body>
<div id="menu">
<ul>
<li><a href="index.html">Overview</a></li>
<li><a href="pub/">Download</a></li>
<li><a href="cgi-bin/gitweb.cgi?p=genometools.git;a=summary">Browse source</a></li>
<li><a href="design.html">Design</a></li>
<li><a href="libgenometools.html">C API</a></li>
<li><a href="docs.html"><tt>gtscript</tt> docs</a></li>
<li><a id="current" href="annotationsketch.html"><tt>AnnotationSketch</tt></a></li>
<li><a href="license.html">License</a></li>
</ul>
</div>


<div id="main">
<h1>The <tt>AnnotationSketch</tt> module</h1>

<p>
The <a href="http://genometools.org/cgi-bin/gitweb.cgi?p=genometools.git;a=tree;f=src/annotationsketch;hb=HEAD"><em>AnnotationSketch</em></a>
module is a versatile and efficient C-based drawing library for GFF3-compatible genomic annotations. It is included in the <em>GenomeTools</em> <a href="http://genometools.org/pub">distribution</a>.
<h2>Contents</h2>
<ul>
 <li><a href="#overview">Overview</a></li>
 <ul>
   <li><a href="#collapsing">Collapsing</a></li>
   <li><a href="#styles">Styles</a></li>
 </ul>
  <li><a href="#gtsketch">The <tt>gt sketch</tt> tool</a></li>
 <li><a href="#examples">Library code examples</a></li>
  <ul>
   <li><a href="#examples-parsed">Creating images of GFF3 files</a></li>
   <li><a href="#examples-generated">Creating images of user-generated annotations</a></li>
 </ul>
 <li><a href="#api">API Reference</a></li>
</ul>

<h2>Overview</h2>
<a name="overview"></a>

<em>AnnotationSketch</em> consists of several classes, which take part in
three visualization  <em>phases</em>.
</p>
<div class="figure">
  <p><a name="fig1"></a><img src="images/dataflow.png" alt="[Dataflow]"></p>
  <p><b>Figure 1: </b>Schematic of the classes involved in image creation.</p>
</div>


<h3>Phase I: Feature selection</h3>
<p>
The GFF3 input data are parsed into a directed acyclic graph (<em>annotation graph</em>, see Fig. <a href="#fig2">2</a> for an example) whose nodes are single features (lines from the GFF3 file). Edges represent the <em>part-of</em> relationships between
groups of genomic features according to the
<a href="http://www.sequenceontology.org/">Sequence Ontology</a> hierarchy. A validating GFF3 parser is available in <em>GenomeTools</em>. GFF3 files <em>must</em> be valid according to the <a href="http://www.sequenceontology.org/gff3.shtml">GFF3 specification</a> to ensure that they can be read for <em>AnnotationSketch</em> drawing.
</p>
<div class="figure">
  <p><a name="fig2"></a><img src="images/gfftree.png" alt="[GFF3 tree]"></p>
  <p><b>Figure 2: </b>Example sequence region containing two genes in an annotation graph depicting the <em>part-of</em> relationships between their components.</p>
</div>
<p>
Each top-level node is then registered into a persistent <em>FeatureIndex</em> object that can be (repeatedly) queried for all the features in a genomic region of interest.
</p>
<p>
Alternatively, annotation graphs can be built by the user by creating each node explicitly and then connecting the nodes in a way such that the relationships are reflected in the graph structure (see <a href="#examples-generated">example section</a> for example code).
</p>
<h3>Phase II: Layout</h3>
<p>
The next step consists of processing the features (given via a <em>FeatureIndex</em> or a simple array of top level nodes) into a structural <em>Diagram</em> object which first builds <em>blocks</em> from features by grouping and overlaying them semantically according to several options (see <a href="#collapsing">Collapsing</a>). During image generation, the <em>Block</em> objects are distributed into <em>Line</em> (each containing non-overlapping blocks) and <em>Track</em> objects (containing all lines of a given type). <em>Tracks</em> and <em>Lines</em> are contained within the <em>Diagram</em> object and correspond to particular building blocks of the resulting diagram (see Fig. <a href="fig3">3</a>). The overall layout of the diagram tries to keep the amount of vertical space as compact as possible. How new <em>Lines</em> are created depends on the chosen  implementation of the <em>LineBreaker</em> interface, by default a <em>Block</em> is pushed into a new <em>Line</em> when either the <em>Block</em> or its caption overlaps with another one.
</p>

<div class="figure">
  <p><a name="fig3"></a><img src="images/diagram.png" alt="[Diagram]"></p>
  <p><b>Figure 3: </b>The components of the <em>Diagram</em> class reflect sections of the resulting image.</p>
</div>
<h3>Phase III: Rendering</h3>
<p>
In the final phase, the <em>Diagram</em> object is used as a blueprint to create an
image of a given type and size, considering user-defined options.

Rendering logic is implemented in the <em>Canvas</em> class, whose methods are called while traversal of the <em>Diagram</em> structure. It encapsulates the state of a drawing and works independently of the chosen rendering back-end. In contrast, rendering backend-aware subclasses of the <em>Canvas</em> are closely tied to a specific implementation of the <em>Graphics</em> interface, which provides methods to draw a number of primitives to a
drawing surface abstraction. It wraps around the low-level graphics library and allows for easy extension or replacement of the graphics back-end. Currently, there are <em>Graphics</em> implementations for the <a href="http://cairographics.org">Cairo</a> 2D graphics library (<em>GraphicsCairo</em>) and two <em>Canvas</em> subclasses providing access to the image file formats supported by Cairo (<em>CanvasCairoFile</em>) and to arbitrary Cairo contexts (<em>CanvasCairoContext</em>, which directly accesses a <a href="http://cairographics.org/manual/cairo-cairo-t.html"><tt>cairo_t</tt></a>). This class can be used, for example, to directly draw <em>AnnotationSketch</em> output in any graphical environment which is supported by Cairo (see <a href="http://www.cairographics.org/manual/Surfaces.html"> list of supported surface types</a>).
</p>

<a name="collapsing"></a>
<h3>Collapsing</h3>
<p>
By default, features are grouped by the Sequence Ontology type associated with them, resulting in one track per type.
To obtain a shorter yet concise output, tracks for parent types in the feature graph can be enabled to contain all the features of their child types. The features with the given type are then drawn on top of their parent features (e.g. all <em>exon</em> and <em>intron</em> features are placed into their parent <em>mRNA</em> or <em>gene</em> track). This process is called <em>collapsing</em>. Collapsing can be enabled by setting the <tt>collapse_to_parent</tt> option for the respective child type to <tt>true</tt>, e.g. the following options:
</p>
<pre class="code">
config = {
  exon = {
    ...,
    collapse_to_parent = true,
    ...,
  },
  intron = {
    ...,
    collapse_to_parent = true,
    ...,
  },
  CDS = {
    ...,
    collapse_to_parent = true,
    ...,
  },
}
</pre>
would lead to all features of there types collapsing into the <em>mRNA</em> track (see Fig. <a href="#fig4">4</a> and <a href="#fig5">5</a>).
<div class="figure">
<div class="subfigure">
<p><b>Figure 4:</b> Schematic of the relationships between the <em>gene</em>, <em>mRNA</em>, <em>exon</em>, <em>intron</em> and <em>CDS</em> types and the colors of their representations in a diagram. The arrows illustrate how the relationships influence the collapsing process if collapsing is enabled for the <em>exon</em>, <em>intron</em> and <em>CDS</em> types. In this example, they will be drawn on top of their parent <em>mRNA</em> features.</p>
</div>
<div class="subfigure">
<p><a name="fig4"></a><img src="images/collapse_types.png" alt="[collapsing]"></p>
</div>
<div style="clear:both;"></div>
</div>
<div class="figure">
<p><a name="fig5"></a><a style="background-color: white; border: none;" href="images/cnn_large.png"><img src="images/collapsing.png" alt="[collapsed/uncollapsed views]"></a></p>
<p><b>Figure 5:</b>(click to enlarge) Example image of the <em>cnn</em> and <em>cbs</em> genes from <em>Drosophila melanogaster</em> (<a href="http://www.ensembl.org/Drosophila_melanogaster/contigview?region=2R&vc_start=9326816&vc_end=9341000">Ensembl release 50, positions 9326816--9341000 on chromosome arm 2R</a>) as drawn by <em>AnnotationSketch</em>. (a) shows a collapsed view in which all <em>exon</em>, <em>intron</em> and <em>CDS</em> types are collapsed into their parent type's track. In contrast, (b) shows the <em>cbs</em> gene with all collapsing options set to <tt>false</tt>, resulting in each type being drawn in its own track.</p>
</div>

<a name="styles"></a>
<h3> Styles</h3>
<p>
The <a href="http://www.lua.org/">Lua</a> scripting language is used to provide
user-defined settings. Settings can be imported from a script that is executed
when loaded, thus eliminating the need for another parser. The Lua configuration
data are made accessible to C via the <em>Style</em> class. Configurable options
include assignment of display styles to each feature type, spacer and margin
sizes, and collapsing parameters.
</p>
<p>Instead of giving direct values, callback Lua functions can be used in some options to generate feature-dependent configuration settings at run-time. During layout and/or rendering, the <a href="http://genometools.org/docs.html#GenomeNode"><em>GenomeNode</em></a> object for the feature to be rendered is passed to the callback function which can then be evaluated and the appropriate type can be returned.</p>
<p>For example, setting the following options in the style file (or via the Lua bindings):</p>
<pre class="code">
config = {
  ...,
  mRNA = {
    block_caption      = function(gn)
                           rng = gn:get_range()
                           return string.format("%s/%s (%dbp, %d exons)",
                                 gn:get_attribute("Parent"),
                                 gn:get_attribute("ID"),
                                 rng:get_end() - rng:get_start() + 1,
                                 #(gn:get_exons()))
                         end,
    ...
  },

  exon = {
    -- Color definitions
    fill               = function(gn)
                           if gn:get_score() then
                             redval = gn:get_score()*1.0
                           else
                             redval = 0.0
                           end
                           return {red=redval, green=0.0, blue=0.0}
                         end,
    ...
  },
  ...
}
</pre>
<p>will result in a changed rendering (see Fig. <a href="#fig_callbacks">6</a>). The <tt>block_caption</tt> function overrides the default block naming scheme, allowing to set custom captions to each block depending on feature properties. Color definitions such as the <tt>fill</tt> setting for a feature's fill color can also be individually styled using callbacks. In this case, the color intensity is shaded by the <em>exon</em> feature's score value (e.g. given in a <a href="annotationsketch/callback_examples_with_score.gff3">GFF file</a>).</p>
<div class="figure">
  <p><a name="fig_callbacks"></a><img src="images/callbacks.png" alt="[Example rendering with callback functions]"></p>
  <p><b>Figure 6: </b>Example rendering of a <a href="annotationsketch/callback_examples_with_score.gff3">GFF file</a> using callback functions to enable custom block captions and score-dependent shading of exon features.</p>
</div>

<a name="gtsketch"></a>
<h2>The <tt>gt sketch</tt> tool</h2>

The <em>GenomeTools</em> <tt>gt</tt> executable provides a new tool which uses the <em>AnnotationSketch</em> library to create a drawing in PNG, PDF, PostScript or SVG format from GFF3 annotations. The annotations can be given by supplying one or more file names as command line arguments:
<pre>
$ gt sketch output.png annotation.gff3
$
</pre>
or by receiving GFF3 data via the standard input:
<pre>
$ gt gff3 -sort -addintrons annotation.gff3 | gt sketch output.png
$
</pre>
Furthermore, the <tt>-force</tt> switch can be used to force overwriting of the output file. The <tt>-pipe</tt> option allows to pass the GFF3 input through the sketch tool via the standard output, allowing the intermediate visualisation of results in a longer pipeline of connected GFF3 tools. More command line options are available; their documentation can be viewed using the <tt>-help</tt> switch.

<a name="examples"></a>
<h2>Examples</h2>
<a name="examples-parsed"></a>
<h3>Using <em>AnnotationSketch</em> to draw annotations from a file</h3>
The following code examples (in C and Lua) illustrate how to produce an image from a given GFF3 file using <em>AnnotationSketch</em>. The result is shown in Fig. <a href="#fig7">7</a>.
<div class="figure">
  <p><a name="fig7"></a><img src="images/parsed.png" alt="[Example rendering from parsed GFF3 file]"></p>
  <p><b>Figure 7: </b>Example rendering of a GFF3 file with default style.</p>
</div>

<h4>C code</h4>
(See <tt>src/examples/sketch_parsed.c</tt> in the source distribution.)
<pre class="code">
#include "genometools.h"

static void handle_error(GT_Error *err)
{
  fprintf(stderr, "error writing canvas %s\n", gt_error_get(err));
  exit(EXIT_FAILURE);
}

int main(int argc, char *argv[])
{
  const char *style_file, *png_file, *gff3_file, *seqid;
  GT_Style *style;
  GT_FeatureIndex *feature_index;
  GT_Range range;
  GT_Diagram *diagram;
  GT_Canvas *canvas;
  GT_Error *err = gt_error_new();

  if (argc != 4) {
    fprintf(stderr, "Usage: %s style_file PNG_file GFF3_file\n", argv[0]);
    return EXIT_FAILURE;
  }

  style_file = argv[1];
  png_file = argv[2];
  gff3_file = argv[3];

  /* create style */
  if (!(style = gt_style_new(false, err)))
    handle_error(err);

  /* load style file */
  if (gt_style_load_file(style, style_file, err))
    handle_error(err);

  /* create feature index */
  feature_index = gt_feature_index_new();

  /* add GFF3 file to index */
  if (gt_feature_index_add_gff3file(feature_index, gff3_file, err))
    handle_error(err);

  /* create diagram for first sequence ID in feature index */
  seqid = gt_feature_index_get_first_seqid(feature_index);
  gt_feature_index_get_range_for_seqid(feature_index, &range, seqid);
  diagram = gt_diagram_new(feature_index, seqid, &range, style);

  /* create canvas */
  canvas = gt_canvas_cairo_file_new(style, GT_GRAPHICS_PNG, 600, NULL);

  /* sketch diagram on canvas */
  gt_diagram_sketch(diagram, canvas);

  /* write canvas to file */
  if (gt_canvas_cairo_file_to_file((GT_CanvasCairoFile*) canvas, png_file, err))
    handle_error(err);

  /* free */
  gt_canvas_delete(canvas);
  gt_diagram_delete(diagram);
  gt_feature_index_delete(feature_index);
  gt_style_delete(style);
  gt_error_delete(err);

  return EXIT_SUCCESS;
}
</pre>

<h4>Lua code</h4>
(See <tt>gtscripts/sketch_parsed.lua</tt> in the source distribution. This example can be run by the command line <tt>gt gtscripts/sketch_parsed.lua &lt;style_file&gt; &lt;PNG_file&gt; &lt;GFF3_file&gt;</tt>)
<pre class="code">
function usage()
  io.stderr:write(string.format("Usage: %s Style_file PNG_file GFF3_file\n", arg[0]))
  io.stderr:write("Create PNG representation of GFF3 annotation file.\n")
  os.exit(1)
end

if #arg == 3 then
  style_file = arg[1]
  png_file   = arg[2]
  gff3_file  = arg[3]
else
  usage()
end

-- load style file
dofile(style_file)

-- create feature index
feature_index = gt.feature_index_new()

-- add GFF3 file to index
feature_index:add_gff3file(gff3_file)

-- create diagram for first sequence ID in feature index
seqid = feature_index:get_first_seqid()
range = feature_index:get_range_for_seqid(seqid)
diagram = gt.diagram_new(feature_index, seqid, range)

-- create canvas
canvas = gt.canvas_new_png(600, nil)

-- sketch diagram on canvas
diagram:sketch(canvas)

-- write canvas to file
canvas:to_file(png_file)
</pre>

<a name="examples-generated"></a>
<h3>Using <em>AnnotationSketch</em> to draw user-generated annotations</h3>
The following C code example illustrates how to produce an image from annotation graphs created by user code.
 The result is shown in Fig. <a href="#fig8">8</a>.
<div class="figure">
  <p><a name="fig8"></a><img src="images/constructed.png" alt="[Example rendering from user-generated annotations]"></p>
  <p><b>Figure 8: </b>Example rendering of user-generated annotations with default style.</p>
</div>

<h4>C code</h4>
(See <tt>src/examples/sketch_constructed.c</tt> in the source distribution.)
<pre class="code">
#include "genometools.h"

static GT_Array* create_example_features(void)
{
  GT_Array *features;
  GT_GenomeNode *forward_gene, *reverse_gene, *exon, *intron; /* features */
  GT_Str *seqid; /* holds the sequence id the features refer to */
  GT_TypeFactory *type_factory; /* used the create feature types */
  GT_FeatureType *type; /* hold a feature type */
  GT_Range range; /* used to define intervals on the genomic sequence */

  /* construct the example features */
  features = gt_array_new(sizeof (GT_GenomeNode*));
  type_factory = gt_type_factory_any_new();
  seqid = gt_str_new_cstr("chromosome_21");

  /* construct a gene on the forward strand with two exons */
  type = gt_type_factory_create_gft(type_factory, "gene");
  range.start = 100; range.end = 900;
  forward_gene = gt_genome_feature_new(seqid, type, range, GT_STRAND_FORWARD);

  type = gt_type_factory_create_gft(type_factory, "exon");
  range.start = 100; range.end = 200;
  exon = gt_genome_feature_new(seqid, type, range, GT_STRAND_FORWARD);
  /* exon belongs to forward gene */
  gt_genome_node_add_child(forward_gene, exon);

  type = gt_type_factory_create_gft(type_factory, "intron");
  range.start = 201; range.end = 799;
  intron = gt_genome_feature_new(seqid, type, range, GT_STRAND_FORWARD);
  /* intron belongs to forward gene */
  gt_genome_node_add_child(forward_gene, intron);

  type = gt_type_factory_create_gft(type_factory, "exon");
  range.start = 800; range.end = 900;
  exon = gt_genome_feature_new(seqid, type, range, GT_STRAND_FORWARD);
  /* exon belongs to forward gene */
  gt_genome_node_add_child(forward_gene, exon);

  /* store forward gene in feature array */
  gt_array_add(features, forward_gene);

  /* construct a single-exon gene on the reverse strand
     (within the intron of the forward strand gene) */
  type = gt_type_factory_create_gft(type_factory, "gene");
  range.start = 400; range.end = 600;
  reverse_gene = gt_genome_feature_new(seqid, type, range, GT_STRAND_REVERSE);

  type = gt_type_factory_create_gft(type_factory, "exon");
  range.start = 400; range.end = 600;
  exon = gt_genome_feature_new(seqid, type, range, GT_STRAND_REVERSE);
  /* exon belongs to reverse gene */
  gt_genome_node_add_child(reverse_gene, exon);

  /* store reverse gene in feature array */
  gt_array_add(features, reverse_gene);

  /* free */
  gt_str_delete(seqid);
  gt_type_factory_delete(type_factory);

  return features;
}

static void handle_error(GT_Error *err)
{
  fprintf(stderr, "error writing canvas %s\n", gt_error_get(err));
  exit(EXIT_FAILURE);
}

static void draw_example_features(GT_Array *features, const char *style_file,
                                  const char *output_file)
{
  GT_Range range = { 1, 1000 }; /* the genomic range to draw */
  GT_Style *style;
  GT_Diagram *diagram;
  GT_Canvas *canvas;
  GT_Error *err = gt_error_new();

  /* create style */
  if (!(style = gt_style_new(false, err)))
    handle_error(err);

  /* load style file */
  if (gt_style_load_file(style, style_file, err))
    handle_error(err);

  /* create diagram */
  diagram = gt_diagram_new_from_array(features, &range, style);

  /* create canvas */
  canvas = gt_canvas_cairo_file_new(style, GT_GRAPHICS_PNG, 600, NULL);

  /* sketch diagram on canvas */
  gt_diagram_sketch(diagram, canvas);

  /* write canvas to file */
  if (gt_canvas_cairo_file_to_file((GT_CanvasCairoFile*) canvas, output_file,
                                   err)) {
    handle_error(err);
  }

  /* free */
  gt_canvas_delete(canvas);
  gt_diagram_delete(diagram);
  gt_style_delete(style);
  gt_error_delete(err);
}

static void delete_example_features(GT_Array *features)
{
  unsigned long i;
  for (i = 0; i < gt_array_size(features); i++)
    gt_genome_node_rec_delete(*(GT_GenomeNode**) gt_array_get(features, i));
  gt_array_delete(features);
}

int main(int argc, char *argv[])
{
  GT_Array *features; /* stores the created example features */

  if (argc != 3) {
    fprintf(stderr, "Usage: %s style_file output_file\n", argv[0]);
    return EXIT_FAILURE;
  }

  features = create_example_features();

  draw_example_features(features, argv[1], argv[2]);

  delete_example_features(features);

  return EXIT_SUCCESS;
}
</pre>

<h4>Lua code</h4>
(See <tt>gtscripts/sketch_constructed.lua</tt> in the source distribution.  This example can be run by the command line <tt>gt gtscripts/sketch_parsed.lua &lt;style_file&gt; &lt;PNG_file&gt;</tt>)
<pre class="code">
function usage()
  io.stderr:write(string.format("Usage: %s Style_file PNG_file\n", arg[0]))
  os.exit(1)
end

if #arg == 2 then
  style_file = arg[1]
  png_file   = arg[2]
else
  usage()
end

-- load style file
dofile(style_file)

-- construct the example features
seqid = "chromosome_21"
nodes = {}

-- construct a gene on the forward strand with two exons
gene   = gt.genome_feature_new(seqid, "gene", gt.range_new(100, 900), "+")
exon   = gt.genome_feature_new(seqid, "exon", gt.range_new(100, 200), "+")
gene:add_child(exon)
intron = gt.genome_feature_new(seqid, "intron", gt.range_new(201, 799), "+")
gene:add_child(intron)
exon   = gt.genome_feature_new(seqid, "exon", gt.range_new(800, 900), "+")
gene:add_child(exon)
nodes[1] = gene

-- construct a single-exon gene on the reverse strand
-- (within the intron of the forward strand gene)
reverse_gene = gt.genome_feature_new(seqid, "gene", gt.range_new(400, 600), "-")
reverse_exon = gt.genome_feature_new(seqid, "exon", gt.range_new(400, 600), "-")
reverse_gene:add_child(reverse_exon)
nodes[2] = reverse_gene

-- create diagram
diagram = gt.diagram_new_from_array(nodes, gt.range_new(1, 1000))

-- create canvas
canvas = gt.canvas_new_png(600, nil)

-- sketch diagram on canvas
diagram:sketch(canvas)

-- write canvas to file
canvas:to_file(png_file)
</pre>


<a name="api"></a>
<h2>API Reference</h2>

A function reference for the <em>AnnotationSketch</em> classes can be found in
the <em>GenomeTools</em> <a href="libgenometools.html">C API reference</a>.

<div id="footer">
Copyright &copy; 2007-2008 Sascha Steinbiss. Last update: 2008-09-09
</div>
</div>
<script src="http://www.google-analytics.com/urchin.js" type="text/javascript">
</script>
<script type="text/javascript">
_uacct = "UA-301256-4";
urchinTracker();
</script>
</body>
</html>
